<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SheronW</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sheronw.github.io/"/>
  <updated>2019-01-16T01:01:20.914Z</updated>
  <id>http://sheronw.github.io/</id>
  
  <author>
    <name>SheronW</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Graph part 3 - 简单粗暴数据结构（12）</title>
    <link href="http://sheronw.github.io/2019/01/15/ds-graph3/"/>
    <id>http://sheronw.github.io/2019/01/15/ds-graph3/</id>
    <published>2019-01-16T00:58:31.000Z</published>
    <updated>2019-01-16T01:01:20.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Minimum-Spanning-Tree"><a href="#Minimum-Spanning-Tree" class="headerlink" title="Minimum Spanning Tree"></a>Minimum Spanning Tree</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>我不知道该怎么描述，总的来说，给一个图，选出来一些互相相连但不成环（connected but acyclic）的edge，使得这些edge的总和最小，并且每一个点都能通过这个集合走到另外任意一个点。”connect network at min cost”<br><a id="more"></a></p><h3 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h3><p>这个算法把图里面所有的点分为两部分：已经连起来的和还没有连起来的。我们先从起点r开始，这样r自己属于连起来的，别的点都是还没连起来的。因为是minimum，所以我们又用到了『贪心』的思想，所以要找到一个和r相连的值最小的edge，用它把r和另外一个点连起来，这样这个点也被加到了『连起来的』这个集合里面了，然后我们在找一个能和这个集合搭界的最小的edge……直到所有的点都被连起来了为止。</p><p><img src="https://i.loli.net/2019/01/16/5c3e7d51808f3.png" alt="enter image description here"></p><pre><code>S={r}T={}while S != V(the set of all vertices):    find the cheapest edge crossing S and V/S(就是所有点的集合里面除了S之外的部分), let it be e    add e to T    vertex=end of e not in S    add vertex to Sreturn e</code></pre><p>首先我们每次都要和一个新的点相连，图里一共|V|个点，所以while loop要运行|V|次吧。最坏情况下所有的edge都和这个点相连，所以循环里面最坏要运行|E|次吧。所以时间复杂度是O(|V||E|)。</p><h3 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h3><p>如果上一个算法是找一棵大树，那么这个算法是要找一片森林，然后把它们拼成一棵大树……<br>首先先将给所有edge的值排个序，然后一个一个从最小的开始往上加——只要加上这个edge图里面不会出现任何圈，那么就可以放心地加上去……直到我们发现所有的vertices都被连起来了为止。<br>（我画了一下图，结果发现和上面那个图一模一样？）</p><pre><code>sort all edges by weightT={}for each edge e(in sorted order):    if adding e doesn&apos;t create a cycle:        add e to Treturn T</code></pre><p>看一下时间复杂度。开头给edge排序可以就用之前的任何一种排序算法，最快的是O(|E|log|E|)。循环一共是O(|E|)次。检查是否有cycle需要用到广度优先搜索，就是O(|V|+|E|)。这么分析的话时间复杂度应该是O(|E|log|E|+|E|(|V|+|E|))=O(|E|<sup>2</sup>)。<br>不过有奇技淫巧可以把这个的时间复杂度降到O(|E|log|V|)<br>，具体怎么操作的我也不太清楚……</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Minimum-Spanning-Tree&quot;&gt;&lt;a href=&quot;#Minimum-Spanning-Tree&quot; class=&quot;headerlink&quot; title=&quot;Minimum Spanning Tree&quot;&gt;&lt;/a&gt;Minimum Spanning Tree&lt;/h2&gt;&lt;h3 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h3&gt;&lt;p&gt;我不知道该怎么描述，总的来说，给一个图，选出来一些互相相连但不成环（connected but acyclic）的edge，使得这些edge的总和最小，并且每一个点都能通过这个集合走到另外任意一个点。”connect network at min cost”&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Graph part 2 - 简单粗暴数据结构（11）</title>
    <link href="http://sheronw.github.io/2019/01/14/ds-graph2/"/>
    <id>http://sheronw.github.io/2019/01/14/ds-graph2/</id>
    <published>2019-01-15T01:57:54.000Z</published>
    <updated>2019-01-15T01:59:39.274Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章就是各种奇怪的算法了……但考试中给一个图能画出来算法每一步得到的结果就ok，实在不理解的话，死记硬背其实也是可以的hhh</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>以下算法针对indirect graph，用来遍历图中每个点。</p><h3 id="Breadth-First-Search-BFS"><a href="#Breadth-First-Search-BFS" class="headerlink" title="Breadth First Search(BFS)"></a>Breadth First Search(BFS)</h3><p>广度优先搜索。如名字所示，就是把当前所在的vertex周围的vertex都搜索一遍，然后<strong>依次</strong>对它周围的vertex都执行相同的这个操作……<br>咦，好像可以用队列呀？只要检查完它周围的vertex，然后把它们全加进队列里面，然后从队列里面取出下一个就可以咯？<br>当然，秉着效率优先的原则，我们要把已经检查过了的vertex进行标记，这样就不用再搜一遍了。<br><a id="more"></a></p><pre><code>将开始搜索的vertex（就记作s吧）放入队列q中当队列q不为空时：    dequeue出来一个vertex u    检查是否是我们要找的，是的话就return该vertex    将u进行标记    for u的所有邻居 v：        如果v没有标记：            将v加入队列qreturn『无结果』</code></pre><p>时间复杂度：O(V+E)<br>首先所有的vertex都要被enqueue和dequeue一次，所以是O(V)；其次对每个u来说，所有的邻居都要被扫描一遍检查是否有标记（也就是说扫描一遍和u有关系的所有edge），这样每个edge都被扫描了两遍（因为它和两个vertex有关系），所以是O(E)。</p><p><a href="https://blog.csdn.net/raphealguo/article/details/7523411" target="_blank" rel="external">可以看这一篇</a></p><h3 id="Depth-First-Search-DFS"><a href="#Depth-First-Search-DFS" class="headerlink" title="Depth First Search(DFS)"></a>Depth First Search(DFS)</h3><p>深度优先搜索。就是一条路走到黑，走不下去了就退到上一个节点，再换另一条路。<br>……退回到上一个节点？我们可以用递归或者是栈。<br>stack的话和广度搜索有点相似：</p><pre><code>将起点s标记，放进栈stack中当stack不为空时：    peek最上面的元素u（只是peek，不拿出来）    检查是否u是我们想要的，是的话就return它    在与它相邻的vertices中，看看还有没有没被标记的    要是有的话，找一个没被标记的v，将其标记并放到栈里面    没有的话，就把u从栈里面拿出来return 『无结果』</code></pre><p>递归：</p><pre><code>dfs(V,E,u):    将u进行标记    如果就是我们要找的，结束搜索直接return    for u所有的邻居v：        如果v没有被标记：            dfs(V,E,v)dfs(V,E,起点s)</code></pre><p>时间复杂度和广度优先搜索一样，也是一个vertex都会至少检查一次，每个edge都会检查两次，也是O(V+E)</p><h2 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h2><p>以下算法用于weighted graph寻找图中两点间最短路径。</p><h3 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h3><p>这个名字看起来挺奇怪，其实那个j好像不发音，是个荷兰的计算机科学家的姓。这个人名言超级多，忘了听谁说的被誉为是计算机科学界的米兰昆德拉……<br>跑题了，这个算法利用一个表<strong>d</strong>来记录从出发点<strong>s</strong>到图中每一个点的最短距离（初始值是无穷大），然后不断更新它。<br>为了能够找到确切的路径，我们又准备了另外一个表<strong>prev</strong>（初始值为空），用来存储路径中该点前面的那个点，当然也要不断更新它，这样就可以从我们找到的终点一路开倒车找回s了。<br>那么如何不断更新呢？把所有的点都放在一个set里面，然后每次拿出来一个距离最小的（可以用priority queue？）（其实这里用到了一种叫做『贪心』的策略，即既然想要最短路径，那就从最短的开始下手）。<br>给定任意一点u和它的某个邻居v，如何判定我们找到了新的最小距离呢？如果到u的最小距离加上u与v之间的距离竟然小于到v的最小距离，那么就说明经过u到v距离会更短，那么我们就要把到v的最小距离改成之前那个了……</p><pre><code>for all vertices v in graph G: // 初始化    d[v]=infinity    prev[v]=NULLd[s]=0 // 起点到它本身的距离为零while 存在未标记的点:    u=未标记的点中有最小d[u]的那个    for all neighbors v of u:        if d[u]+(u,v)&lt;d[v]:            d[v]=d[u]+(u,v)            prev[v]=u    将u进行标记</code></pre><p>来分析一下这个的时间复杂度，while循环里面包着的for循环有点熟悉，往上一翻发现和广度优先搜索如出一辙，所以这一块儿应该是O(E)。剩下的就是while里面包着的找最小d[u]的那个了，之前我们说过可以用priority queue，这个的时间复杂度是O(logn)，剩下的部分是和点（vertices）有关的，因此是O(VlogV)。加起来总的时间复杂度应该是O(VlogV)。</p><p>那么输出完整路径的算法为：</p><pre><code>v=我们要找的终点while prev[v]!=s:    print v    v=prev[v]print s</code></pre><p>悄悄地说一句，这是我们当初期末考试中唯一一个真正考了的关于graph的算法……hhh</p><h3 id="Floyd’s-Algorithms"><a href="#Floyd’s-Algorithms" class="headerlink" title="Floyd’s Algorithms"></a>Floyd’s Algorithms</h3><p>dijkstra 的算法虽然快，但有一个问题：当weighted graph中有值为负的edge的时候就用不了了（dijkstra的『贪心』找最短距离的邻居这个策略就行不通了，如果有负edge的话，经过它那里到邻居的距离可能比它的距离还短）。<br>Floyd呢，运用了『动态规划』的算法思想，如果没记错的话<strong>不管是考试还是lab都不太可能会出现，看不懂也没关系</strong>……<br>动态规划比较浅显的解释就是这样：准备一个表，然后开始填表，有一些值要事先填好，每一个需要填的值都与已经填好的某些值有固定关系（类似递归）。<br>之前说到，已经不能用找邻居的方式来解决这个问题了，但我们可以列一张表，把任意两点之间的最短距离都列出来。<br>和之前的adjacency matrix一样，我们需要一个二维数组来记录两点间最小距离（就叫这张表是memo[|V|][|V|]吧）。<br>首先把base case填好。为了便于更新最小值，把所有值都初始化为无穷大。每一点和自己的距离目前是0。任意两个edge之间的距离，我们先初始化为edge的值本身。<br>然后我们来找到填表的关系。因为可能会出现负值，所以不能像之前那样只走一遍了。对于这个图中的每一个点k，我们都要考虑是否有可能有<strong>任何两点之间的最短距离(i,j)</strong>会使用(1…k)这些点（就是将所有点都排一下序）。所以对每个点k来说我们都要从头到尾重新把这个表再填一下，看看会不会有更小的值。如果这个最小距离和k根本没关系的话，那么使用(1…k)这些点和使用(1…k-1)这些点的结果是一样的。如果有关系的话，那么最小距离就可以分成两半——使用从(1…k-1)这些点，从i到k的距离加上从k到j的距离。</p><pre><code>momo[][]=new int[V][V]for i in range (1,V):    for j in range (1,V):        if i==j, memo[i][j]=0        else, memo[i][j]=infinityfor edges (u,v) in G:    memo[u][v]=d(u,v)for k from 1 to V:    for i from 1 to V:        for j from 1 to V:            if memo[i][j]&gt;memo[i][k]+memo[k][j]:                memo[i][j]=memo[i][k]+memo[k][j]</code></pre><p>时间复杂度倒是一看便知，三个for循环，O(V<sup>3</sup>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇文章就是各种奇怪的算法了……但考试中给一个图能画出来算法每一步得到的结果就ok，实在不理解的话，死记硬背其实也是可以的hhh&lt;/p&gt;
&lt;h2 id=&quot;Search&quot;&gt;&lt;a href=&quot;#Search&quot; class=&quot;headerlink&quot; title=&quot;Search&quot;&gt;&lt;/a&gt;Search&lt;/h2&gt;&lt;p&gt;以下算法针对indirect graph，用来遍历图中每个点。&lt;/p&gt;
&lt;h3 id=&quot;Breadth-First-Search-BFS&quot;&gt;&lt;a href=&quot;#Breadth-First-Search-BFS&quot; class=&quot;headerlink&quot; title=&quot;Breadth First Search(BFS)&quot;&gt;&lt;/a&gt;Breadth First Search(BFS)&lt;/h3&gt;&lt;p&gt;广度优先搜索。如名字所示，就是把当前所在的vertex周围的vertex都搜索一遍，然后&lt;strong&gt;依次&lt;/strong&gt;对它周围的vertex都执行相同的这个操作……&lt;br&gt;咦，好像可以用队列呀？只要检查完它周围的vertex，然后把它们全加进队列里面，然后从队列里面取出下一个就可以咯？&lt;br&gt;当然，秉着效率优先的原则，我们要把已经检查过了的vertex进行标记，这样就不用再搜一遍了。&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>写在最后，或者最前 - 简单粗暴数据结构（13）</title>
    <link href="http://sheronw.github.io/2019/01/14/ds-finally/"/>
    <id>http://sheronw.github.io/2019/01/14/ds-finally/</id>
    <published>2019-01-15T00:29:37.000Z</published>
    <updated>2019-01-18T00:30:33.927Z</updated>
    
    <content type="html"><![CDATA[<p>  虽然成绩看着没啥大毛病，但是我知道我数据结构学得十分垃圾。本来复习数构这个计划会被无限期拖延下去的，直到鲸鱼小姐姐作为一位文科生想要勇敢地尝试一下这门传说中『劝退好多人major cs』的数据结构。她跟我说哎呀要不这个冬天我稍微预习一下吧，我说好啊那我给你粗略地写点知识点，再用纯正的大白话稍微解释一下。<br><a id="more"></a></p><p>  然后在她的微信远程监督下，直到今天我算是把当初学过的知识点都过了一遍。其实当初很多觉得学得恶心得不行的东西，现在看来其实也就那样。当然我不是说这些文章好到能够当教程了——我真的不敢，这玩意儿顶多当笔记我自己看看，或者分享给小圈子里的人。不过也就因为这样，我可能会在今后的很长一段时间里继续加工这些文章，添加一点别的东西——这就是为什么我在标题里写『或者最前』的意思，这只是开始。</p><p>以下是目录：</p><ul><li><p><a href="https://sheronw.github.io/2019/01/03/ds-list/">The List Interface</a></p></li><li><p><a href="https://sheronw.github.io/2019/01/04/ds-stackandqueue/">Stack &amp; Queue</a></p></li><li><p><a href="https://sheronw.github.io/2019/01/05/ds-algs_analysis/">Algorithm Analysis</a></p></li><li><p><a href="https://sheronw.github.io/2019/01/06/ds-arithmetic_expression/">Arithmetic Expression</a></p></li><li><p>Tree</p><ul><li><a href="https://sheronw.github.io/2019/01/07/ds-tree1/">Basic &amp; Binary Tree</a></li><li><a href="https://sheronw.github.io/2019/01/09/ds-tree2/">Binary Search Tree &amp; AVL Tree &amp; Red Black Tree</a></li><li><a href="https://sheronw.github.io/2019/01/10/ds-tree3/">B Tree &amp; Trie &amp; Huffman Tree</a></li></ul></li><li><p><a href="https://sheronw.github.io/2019/01/11/ds-pq/">Priority Queue</a></p></li><li><p><a href="https://sheronw.github.io/2019/01/12/ds-hashing/">Hashing</a></p></li><li><p>Graph</p><ul><li><a href="https://sheronw.github.io/2019/01/12/ds-hashing/">Basic &amp; Representation</a></li><li><a href="https://sheronw.github.io/2019/01/12/ds-hashing/">Search &amp; Shortest Paths</a></li><li><a href="https://sheronw.github.io/2019/01/12/ds-hashing/">Minimum Spanning Tree</a></li></ul></li><li>Sorting<br>  这一篇我根本没写。有一个<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="external">现成的gitbook</a>我觉得写得就挺好的，只不过我们那节课没有学希尔排序、计数排序和桶排序，空间复杂度也暂时没讲。</li></ul><p>因为写得挺匆忙的，外加自身水平也不够，要是有任何谬误跪求各位读者老爷们赏个脸指出来……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  虽然成绩看着没啥大毛病，但是我知道我数据结构学得十分垃圾。本来复习数构这个计划会被无限期拖延下去的，直到鲸鱼小姐姐作为一位文科生想要勇敢地尝试一下这门传说中『劝退好多人major cs』的数据结构。她跟我说哎呀要不这个冬天我稍微预习一下吧，我说好啊那我给你粗略地写点知识点，再用纯正的大白话稍微解释一下。&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Graph part 1 - 简单粗暴数据结构（10）</title>
    <link href="http://sheronw.github.io/2019/01/13/ds-graph1/"/>
    <id>http://sheronw.github.io/2019/01/13/ds-graph1/</id>
    <published>2019-01-13T18:40:08.000Z</published>
    <updated>2019-01-13T19:14:43.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Terminology"><a href="#Basic-Terminology" class="headerlink" title="Basic Terminology"></a>Basic Terminology</h2><p>这学期最后一个数据结构是图。简单地来说就是『由线连起来的点』，由Vertex（点）和Edge（线）组成。G=(V,E)<br>下面的很多定义都是从图论（数学）里面拿来用的hhh</p><h3 id="direct-amp-indirect"><a href="#direct-amp-indirect" class="headerlink" title="direct &amp; indirect"></a>direct &amp; indirect</h3><p>根据edge是否有方向（带箭头），graph可以分成direct graph（digraph）和indirect graph（没有方向的）。<br>如果是direct graph，那么edge可以用两个<strong>有序的</strong>vertices来表示。<br><a id="more"></a></p><h3 id="dense-amp-sparse"><a href="#dense-amp-sparse" class="headerlink" title="dense &amp; sparse"></a>dense &amp; sparse</h3><p>根据edge的数量多少，graph又可以分成dense graph和sparse graph。<br>如果这个图比较dense，那么对每一个vertex来说，都几乎和剩下所有的edge相连，那么E=O(V<sup>2</sup>)。<br>如果这个图比较sparse，edge的数量肯定是小于O(V<sup>2</sup>)的。<br>一般来说，sparse graph更适合用adjacency list来represent（见后面）。</p><p>cycle是一条从一个vertex出发，又回到它这里的一段路径。</p><h3 id="weighted-amp-unweighted"><a href="#weighted-amp-unweighted" class="headerlink" title="weighted &amp; unweighted"></a>weighted &amp; unweighted</h3><p>weighted graph其实就是在edge上标了数值。一个实际应用的例子就是走不同edge所需要的旅行成本。</p><h2 id="Representation-Methods"><a href="#Representation-Methods" class="headerlink" title="Representation Methods"></a>Representation Methods</h2><p><img src="https://i.loli.net/2019/01/14/5c3b845879e26.png" alt="enter image description here"></p><h3 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a>Adjacency Matrix</h3><p>适用于dense graph。<br>简单来讲就是搞一个矩阵，横纵座标分别代表一个vertex，如果这两个vertices之间有edge，这一格的值就为1，否则为0。<br>如果是directed graph的话，可以规定横或纵中的一个为起始vertex。<br>如果是weighted graph的话，把1换成值就可以了。</p><h3 id="Adjacency-Lists"><a href="#Adjacency-Lists" class="headerlink" title="Adjacency Lists"></a>Adjacency Lists</h3><p>适用于sparse graph。<br>简单地说就是每一个vertex都有一个相应的linked-list，记录了所有与它相连的vertices。<br>如果是directed graph的话，就只记录以它为起点的edge对应的vertices。<br>如果是weighted graph的话，linked-list中再增加一项edge的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-Terminology&quot;&gt;&lt;a href=&quot;#Basic-Terminology&quot; class=&quot;headerlink&quot; title=&quot;Basic Terminology&quot;&gt;&lt;/a&gt;Basic Terminology&lt;/h2&gt;&lt;p&gt;这学期最后一个数据结构是图。简单地来说就是『由线连起来的点』，由Vertex（点）和Edge（线）组成。G=(V,E)&lt;br&gt;下面的很多定义都是从图论（数学）里面拿来用的hhh&lt;/p&gt;
&lt;h3 id=&quot;direct-amp-indirect&quot;&gt;&lt;a href=&quot;#direct-amp-indirect&quot; class=&quot;headerlink&quot; title=&quot;direct &amp;amp; indirect&quot;&gt;&lt;/a&gt;direct &amp;amp; indirect&lt;/h3&gt;&lt;p&gt;根据edge是否有方向（带箭头），graph可以分成direct graph（digraph）和indirect graph（没有方向的）。&lt;br&gt;如果是direct graph，那么edge可以用两个&lt;strong&gt;有序的&lt;/strong&gt;vertices来表示。&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Hashing - 简单粗暴数据结构（9）</title>
    <link href="http://sheronw.github.io/2019/01/12/ds-hashing/"/>
    <id>http://sheronw.github.io/2019/01/12/ds-hashing/</id>
    <published>2019-01-12T18:39:54.000Z</published>
    <updated>2019-01-12T18:41:11.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>之前在array里面查找一个东西，要么线性搜索，要么把这个array排好再搜……<br>hashing就是一种简单粗暴放东西的方法，它用一个hash function，放东西的时候把这个东西的key转换成index，值放在相应的格子里，这样下次搜索这个key的时候就可以秒搜了。</p><p><img src="https://i.loli.net/2019/01/13/5c3a2aaf801be.png" alt="enter image description here"></p><a id="more"></a><h2 id="Hash-Function-Design"><a href="#Hash-Function-Design" class="headerlink" title="Hash Function Design"></a>Hash Function Design</h2><p>就是把keys转换成整数（index）的函数啦，Java好像有现成的method可以用。<br>如果keys都是整数，而且整数都不算大的话，f(key)=key。<br>一个好的hash function，当然是要做到『均匀』——首先，不能黏在一起，比如尽可能降低不同的key值指向同一个hashing值的情况（也就是说collision）。其次，也不能距离太远，array不能搞得太大，至少要控制在空间复杂度小于O(2<sup>n</sup>)吧。</p><h3 id="Division-Method"><a href="#Division-Method" class="headerlink" title="Division Method"></a>Division Method</h3><p>现在最常用的方法。<br>假设key值已经转换成整数了，hash(key)=key%table size<br>为了减少collision，比较适合做table size的数：prime numbers或者是numbers without small prime factors<br>（power of 2 不是一个好的table size，太容易撞了）</p><h3 id="MAD"><a href="#MAD" class="headerlink" title="MAD"></a>MAD</h3><p>是multiply，add，divide的缩写。<br>hash(key)=(a*key+b)%table size<br>上面的加强版。</p><p>……我能想起来的只有这么多了，上课看下笔记吧。</p><h2 id="Collision-Handing"><a href="#Collision-Handing" class="headerlink" title="Collision Handing"></a>Collision Handing</h2><p>当然，虽然理论上说可以秒搜，但实际上经常是达不到这个情况的——万一正好两个不同key的hash值相等呢？所以我们就要处理这些重复的值。</p><h3 id="Open-Addressing"><a href="#Open-Addressing" class="headerlink" title="Open Addressing"></a>Open Addressing</h3><h4 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h4><p>最简单粗暴的解决办法。要是hash对应的格子已经满了，就放到下一个，这样以此类推直到找到空位。<br>搜索的时候也是，如果这个格子的key值和想要搜的key不相等，就搜下一个，以此类推。<br>缺点是，最坏情况下你可能要把整个表都搜一遍，也就是O(n)。</p><h4 id="Double-Hashing"><a href="#Double-Hashing" class="headerlink" title="Double Hashing"></a>Double Hashing</h4><p>其实也很简单粗暴，准备两个hash function，第一个撞了就换第二个，第二个还撞就用上面那个方法……<br>类似地，还有一种方法叫做rehashing，就是准备i个不同的hash function……（也不是说这i个函数完全不一样，可以只是稍微改动一下系数什么的）</p><h3 id="Separate-Chaining"><a href="#Separate-Chaining" class="headerlink" title="Separate Chaining"></a>Separate Chaining</h3><p>可以说是表中表了。array中的每一个格子里面都存放一个linked list，要是有重复了就把新加进来的key和value存放在linked list里面就好啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-Concepts&quot;&gt;&lt;a href=&quot;#Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Basic Concepts&quot;&gt;&lt;/a&gt;Basic Concepts&lt;/h2&gt;&lt;p&gt;之前在array里面查找一个东西，要么线性搜索，要么把这个array排好再搜……&lt;br&gt;hashing就是一种简单粗暴放东西的方法，它用一个hash function，放东西的时候把这个东西的key转换成index，值放在相应的格子里，这样下次搜索这个key的时候就可以秒搜了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/13/5c3a2aaf801be.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Priority Queue - 简单粗暴数据结构（8）</title>
    <link href="http://sheronw.github.io/2019/01/11/ds-pq/"/>
    <id>http://sheronw.github.io/2019/01/11/ds-pq/</id>
    <published>2019-01-11T18:45:37.000Z</published>
    <updated>2019-01-11T18:46:39.722Z</updated>
    
    <content type="html"><![CDATA[<p>Priority Queue（优先队列）就是一个Queue，不过每次添加进新的元素都会将queue里面所有东西都按照优先级排一下顺序，有最高优先级的在最前面。</p><h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><p>和queue一样嘛，enqueue，dequeue，peek<br>当然和queue不一样的是，当你dequeue或者peek的时候，出来的那个元素肯定是优先级最高的（比如说，最大的元素，或者最小的元素）<br><a id="more"></a></p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>enqueue就是把元素加到list中，O(1)<br>dequeue或者是peek的话要找出优先级最高的，因此要把整个list遍历一遍，所以就是O(n)<br>当然也可以反过来，每次enqueue的时候就把这个元素放在正确的位置上，这样index为零的格子里面就是优先级最高的了，enqueue变成了O(n)，但dequeue和peek都是O(1)<br>但这种implementation显然有点慢，一般来说我们都用heap。</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><h4 id="什么是Heap？"><a href="#什么是Heap？" class="headerlink" title="什么是Heap？"></a>什么是Heap？</h4><p>heap也是一种binary tree。和binary  search tree不同的是，爸爸总是大于等于（或者小于等于）两个儿子，两个儿子之间的大小关系并没有规定。爸爸大于等于俩儿子的heap叫max heap，反之叫min heap。</p><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h4><p>其实也就是在heap中插入一个元素。<br>方法是，将新加进的元素放在底层最后面，检查它和爸爸是否符合原则，如果不符合就和爸爸交换，直到满足条件（或者它自己成为了root）为止。这种方法叫做sift up。<br>可以看出这个方法和树的层数有关，因此是O(logn)。</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>这个简单，直接return root的值就好，O(1)。</p><h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p>其实就是在heap里面删除最上面的那个元素。<br>方法是，把底层最后一个元素拿出来放在要删除的这个元素的空缺里，然后检查它的儿子是否满足原则，不满足就交换，直到满足条件（或者它再次回到最底层）为止。这种方法叫做sift down。<br>可以看出这个方法和树的层数有关，因此是O(logn)。</p><p><img src="https://i.loli.net/2019/01/12/5c38e41add166.png" alt="enter image description here"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Priority Queue（优先队列）就是一个Queue，不过每次添加进新的元素都会将queue里面所有东西都按照优先级排一下顺序，有最高优先级的在最前面。&lt;/p&gt;
&lt;h2 id=&quot;Basic-Operations&quot;&gt;&lt;a href=&quot;#Basic-Operations&quot; class=&quot;headerlink&quot; title=&quot;Basic Operations&quot;&gt;&lt;/a&gt;Basic Operations&lt;/h2&gt;&lt;p&gt;和queue一样嘛，enqueue，dequeue，peek&lt;br&gt;当然和queue不一样的是，当你dequeue或者peek的时候，出来的那个元素肯定是优先级最高的（比如说，最大的元素，或者最小的元素）&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree part 3 - 简单粗暴数据结构（7）</title>
    <link href="http://sheronw.github.io/2019/01/10/ds-tree3/"/>
    <id>http://sheronw.github.io/2019/01/10/ds-tree3/</id>
    <published>2019-01-11T01:01:35.000Z</published>
    <updated>2019-01-11T01:09:15.414Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章讲一下关于树的几个变种，lab里面并没有相关的内容，考试虽然也考但也不是重点。</p><h2 id="B-Trees-amp-2-3-Trees"><a href="#B-Trees-amp-2-3-Trees" class="headerlink" title="B-Trees &amp; 2-3 Trees"></a>B-Trees &amp; 2-3 Trees</h2><p>在最前面放一张凡凡制作的表情包：</p><p><img src="https://i.loli.net/2019/01/11/5c378b209ed47.jpg" style="zoom:50%"></p><p>逼数，哦不，B-Tree是这样的，它的一个node里面可以存放好几个变量（可以用linked list来实现），也有不止一个儿子。这样它的层数比其他树都小，搜索起来也会更快。<br>因为一个node里面可以放不止一个变量，所以对于每个逼数，我们都规定一个branching factor t，代表最多能有几个儿子。</p><p>B-Tree的特点：</p><ol><li>Every path from the root to a leaf has the same length（层高是统一的）</li><li>If a node has  t  children, it contains  t−1  keys.（keys就是这个node里面的变量数）</li><li>Every node (except the root) is at least half full.（每个node里面的变量数最少是n/2）</li><li>The elements stored in a given subtree all have keys that are between the keys in the parent node on either side of the subtree pointer. (This generalizes the BST invariant.) </li><li>The root has at least two children if it is not a leaf.</li></ol><a id="more"></a><p><img src="https://i.loli.net/2019/01/11/5c37da39c6c43.png" style="zoom:50%"><br>因为是BST的衍生，所以搜索和遍历都和它大同小异。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>比较理想一点的状况是，在原来的树里，正好就有适合它的一个空位（因为每一个node不一定都是满的），这样直接插进去就好了。但有的时候，属于这个node的范围里面正好满了……<br>解决办法就是，把这个node中间的那个元素取出来，放在他爸爸那里，然后把已经满了的node分成两个半满的node，连在相应的位置上（要是爸爸满了就再往上推）。<br>用刚刚那个图举例子，假设我们要插一个0进去：<br><img src="https://i.loli.net/2019/01/11/5c37dd492e812.png" style="zoom:50%"></p><h3 id="2-3-Trees"><a href="#2-3-Trees" class="headerlink" title="2-3 Trees"></a>2-3 Trees</h3><p>哦，这个就是branch factor=3的逼数，一个node最多可以有三个儿子，两个元素。</p><h2 id="Tries"><a href="#Tries" class="headerlink" title="Tries"></a>Tries</h2><p>这是一个用来保存各种字符串的树，因为重合部分很多，所以挺省内存的，插入之类的原理挺简单，只要会读里面有哪些字符串就可以了。<br>一般来讲，只要从root开始读，只要读到一个特殊的node就算字符串结尾（至于这个特殊的node怎么表示，不同的方法有轻微的区别，比如加一个空node，或者这个node有个特殊值，可以看一下上课老师怎么讲的）<br><img src="https://i.loli.net/2019/01/11/5c37ea6fe329b.png" style="zoom:50%"><br>好吧，假设上图里面绿色的node全都是终止node，那么上面这个trie里面存在的字符串有：a, an, and, any, all, be, been</p><h2 id="Huffman-Trees"><a href="#Huffman-Trees" class="headerlink" title="Huffman Trees"></a>Huffman Trees</h2><p>实现这个这个其实是CS 241的最后一个作业（压轴），但在151阶段，考试时给一个文本（或者每个字母对应的频率），能够手写一棵树就够。<br>huffman tree就是一个能够压缩文本的“密码表”，向左就记0，向右就记1，字母出现频率越高就离root越近，也就是说encode的二进制字符串就越短。<br>生成这棵树的方法，死记硬背的话很简单：找到频率最小的俩字母，连在同一个爸爸上，这个爸爸的值就是这两个的频率之和，然后把这个爸爸作为一个整体放到剩下的那堆字母里，再找两个频率最小的……直到表为空，最后一个爸爸就是root。<br><img src="https://i.loli.net/2019/01/11/5c3791ebaa2ef.png" alt="enter image description here"><br>根据上面的树，可以得到编码如下：<br> e  0 h  100  s  101  c  11<br>最后安利一篇<a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/" target="_blank" rel="external">关于huffman tree原理的高阶讲解</a>（在文章靠后的位置）</p><blockquote><p>参考链接<br><a href="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/rec25.html" target="_blank" rel="external">https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/rec25.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇文章讲一下关于树的几个变种，lab里面并没有相关的内容，考试虽然也考但也不是重点。&lt;/p&gt;
&lt;h2 id=&quot;B-Trees-amp-2-3-Trees&quot;&gt;&lt;a href=&quot;#B-Trees-amp-2-3-Trees&quot; class=&quot;headerlink&quot; title=&quot;B-Trees &amp;amp; 2-3 Trees&quot;&gt;&lt;/a&gt;B-Trees &amp;amp; 2-3 Trees&lt;/h2&gt;&lt;p&gt;在最前面放一张凡凡制作的表情包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/11/5c378b209ed47.jpg&quot; style=&quot;zoom:50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;逼数，哦不，B-Tree是这样的，它的一个node里面可以存放好几个变量（可以用linked list来实现），也有不止一个儿子。这样它的层数比其他树都小，搜索起来也会更快。&lt;br&gt;因为一个node里面可以放不止一个变量，所以对于每个逼数，我们都规定一个branching factor t，代表最多能有几个儿子。&lt;/p&gt;
&lt;p&gt;B-Tree的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Every path from the root to a leaf has the same length（层高是统一的）&lt;/li&gt;
&lt;li&gt;If a node has  t  children, it contains  t−1  keys.（keys就是这个node里面的变量数）&lt;/li&gt;
&lt;li&gt;Every node (except the root) is at least half full.（每个node里面的变量数最少是n/2）&lt;/li&gt;
&lt;li&gt;The elements stored in a given subtree all have keys that are between the keys in the parent node on either side of the subtree pointer. (This generalizes the BST invariant.) &lt;/li&gt;
&lt;li&gt;The root has at least two children if it is not a leaf.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree part 2 - 简单粗暴数据结构（6）</title>
    <link href="http://sheronw.github.io/2019/01/09/ds-tree2/"/>
    <id>http://sheronw.github.io/2019/01/09/ds-tree2/</id>
    <published>2019-01-10T04:33:35.000Z</published>
    <updated>2019-01-10T04:33:34.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Search-Trees"><a href="#Binary-Search-Trees" class="headerlink" title="Binary Search Trees"></a>Binary Search Trees</h2><p>BST是binary tree的一个变种（如名字所示，是便于搜索的变种……？），特点是这样的：<br>对于任何一个node来说，<br>左sub-tree的所有node都比它小，<br>右sub-tree的所有node都比他大。<br>（sub-tree就是以它的left child为root的tree）<br><img src="https://i.loli.net/2019/01/09/5c356a9fd8e70.png" alt="enter image description here"></p><a id="more"></a><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>比较目标和root，目标更小就在左半边搜，目标更大就在右半边搜，这个用递归就很好实现。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>类似查找，如果比root小肯定要插在左半边的树里，如果比root大就要插在右半边，直到要搜的sub-tree为空为止。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除就有点麻烦了，需要分类讨论：<br>首先我们要找到想要删除的那个node的位置吧，这个我们刚刚说了，这个node的位置有三种情况：</p><ol><li>它自己是个叶子，直接删了完事（如果是光杆root就return NULL吧）</li><li>它只有一个儿子（可能是左也可能是右），这种情况可以把以这个儿子为root的树整个挪到它所在的地方</li><li>它有两个儿子，这种情况就需要想一下了。根据binary search tree的定义，left sub-tree的值都要比right sub-tree里的小，而想要删除的这个node的值就在这两者之间，所以我们需要在这些node里面找出来一个也能满足这个条件的node然后替换掉。方法就是找到左边的树里面最大的（一路向右），或者右边的树里面最小的（一路向左）。</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>不难发现上面几个算法的时间复杂度（big-oh notation）和层数都有关系，但最操蛋的binary search tree 可能是长这样的：<br><img src="https://i.loli.net/2019/01/09/5c356ded29a72.png" alt="enter image description here"><br>如果你按照大小排序的顺序往里插入node，最后就会变成这个长歪了的狗样子，和List没什么区别了。也就是说最坏情况下层数就是n，因此是O(n)。<br>至于如何解决这个问题，请看下面：</p><h2 id="Balanced-Binary-Search-Trees"><a href="#Balanced-Binary-Search-Trees" class="headerlink" title="Balanced Binary Search Trees"></a>Balanced Binary Search Trees</h2><h3 id="AVL-Trees"><a href="#AVL-Trees" class="headerlink" title="AVL Trees"></a>AVL Trees</h3><p>维基百科的定义是这样的： In an AVL tree, the heights of the two child sub-trees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.<br><img src="https://i.loli.net/2019/01/09/5c36121100904.png" alt="enter image description here"><br>这样，既然限制了两个sub-tree层高的差值，那么上面的问题似乎就解决了。不过问题来了，怎么让它rebalance啊……<br>答案就是，扭。</p><h4 id="Single-Rotation"><a href="#Single-Rotation" class="headerlink" title="Single Rotation"></a>Single Rotation</h4><p>怎么扭？要么往左，要么往右。<br>自己是爸爸的右儿子，爸爸也是爷爷的右儿子，就往左扭。<br>都是左儿子，就往右扭。<br><img src="https://i.loli.net/2019/01/09/5c3619efbc4c1.png" alt="enter image description here"></p><h4 id="Double-Rotation"><a href="#Double-Rotation" class="headerlink" title="Double Rotation"></a>Double Rotation</h4><p>可惜的是，这两种扭法好像并不能解决生活中出现的全部复杂情况，因此我们需要扭两次，先右再左或者先左再右。<br>先左再右适用于自己是爸爸的右儿子，爸爸是爷爷的左儿子这种拧巴的情况。先右再左适用于自己是爸爸的左儿子，爸爸是爷爷的右儿子这种情况。<br><img src="https://i.loli.net/2019/01/10/5c364008a425b.png" alt="enter image description here"></p><h4 id="轴的儿子该放哪儿"><a href="#轴的儿子该放哪儿" class="headerlink" title="轴的儿子该放哪儿"></a>轴的儿子该放哪儿</h4><p>这样，一共就四种怎么转的方法，但一个很微小的问题是，上面的几张图里面都没有画这几个node的全部sub-tree（好吧，我承认我比较懒）。<br>因为一个爸爸只能有两个儿子，一些儿子需要认新爸爸。认谁做爸爸呢？假设这个儿子没转之前是左儿子（比转轴小），那么就要认转完之后的新左儿子（比转轴小）做爸爸，做他的右儿子（比新爸爸大），反过来也同理。<br>直接用刚刚那张图了……红色是轴，蓝色是要认新爸爸的node。<br><img src="https://i.loli.net/2019/01/10/5c3644fe6b49e.png" alt="enter image description here"></p><h4 id="rebalance"><a href="#rebalance" class="headerlink" title="rebalance"></a>rebalance</h4><p>不论是插入新的node还是删除，基本上都是按照之前binary search tree的套路，只不过要更新一下每棵树的层高，还有balance factor（就是左sub-tree的层高减去右边的），一旦发现有不平衡的情况，就判断是上面的哪种情况，然后转。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="external">我在网上找到了一个演示AVL Tree的页面</a></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>因为AVL不会斜的太厉害，所以树的层高和n都是对数关系，这几个算法的时间复杂度都是O(logn)。</p><h3 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a>Red-Black Trees</h3><p>红黑树也是一种改进的binary search tree，只不过node有红有黑，所有的叶子都是一种叫做NIL的黑node，里面不存放任何数据。<br>这是<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="external">wikipedia</a>中关于红黑树的定义：</p><ol><li>Each node is either red or black.</li><li>The root is black. </li><li>All leaves (NIL) are black.</li><li>If a node is red, then both its children are black.</li><li>Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes.</li></ol><p>和AVL一样，想要保持它的这些特性，就需要在添加或者删除之后进行rebalance。扭在这里仍然好用，但我们还需要重新涂色。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>因为每一个路径都要有同样的black node，所以新node作为red node插进去是最简单的方法。<br>用binary search tree的方法插入，被插的node（我们就叫N吧）最后都是叶子，可是规则3告诉我们所有的叶子都是NIL，因此我们需要把某个NIL替换成N（附赠两个NIL儿子）。<br>下面是所有可能出现的情况：</p><ol><li>N自己是root</li><li>N的爸爸就是黑的</li><li>N的爸爸是红的，舅舅也是红的</li><li>N的爸爸是红的，舅舅是黑的</li></ol><p>第一种就很好解决啦，把N涂成黑色的就OK。<br>第二种的话也好解决，其实就是把一个黑node替换成了一个（有两个黑儿子的）红node，每条路径上黑node的数量不变，不用做其他处理。<br>第三种靠重新涂色来解决，爸爸和舅舅都涂黑，然后爷爷涂红，这样个树上所有的路径黑node的数量仍然不变。但这样就有了一个问题——万一爷爷就是root怎么办呢？方法是处理完之后再对爷爷使用一次这个function。<br>第四种就麻烦了，因为这种情况下我们要扭。和AVL相似，我们需要四种不同的情况：<br>（下面的图示中，假设从g出发的每条路径上的黑node数为n，T代表subtree而不是NIL，T下面写的是这个tree种每条路径上的黑node数量）</p><h5 id="Left-Rotation"><a href="#Left-Rotation" class="headerlink" title="Left Rotation"></a>Left Rotation</h5><p>此情况适用于自己是爸爸的右儿子，爸爸是爷爷的右儿子的时候。<br>扭完之后右侧分支的黑node数不变，左侧多了一个黑node（g），因此我们把g涂红，让数目恢复原状。T<sub>3</sub>之前和红色的p混，因此不用考虑它的颜色是否和红色node兼容。<br><img src="https://i.loli.net/2019/01/10/5c36ad5f9a825.png" alt="enter image description here"></p><h5 id="Right-Rotation"><a href="#Right-Rotation" class="headerlink" title="Right Rotation"></a>Right Rotation</h5><p>此情况适用于自己是爸爸的左儿子，爸爸是爷爷的左儿子的时候。<br>扭完之后你会发现左侧sub-tree的黑node数目没变，而右边多了一个黑node（g），所以我们把g涂成红色。因为T<sub>3</sub>之前就和红色的p混，所以不用考虑重新处理。<br><img src="https://i.loli.net/2019/01/10/5c36a23f5b5ad.png" alt="enter image description here"></p><h5 id="Left-Right-Rotation"><a href="#Left-Right-Rotation" class="headerlink" title="Left-Right Rotation"></a>Left-Right Rotation</h5><p>适用于自己是爸爸的右儿子，爸爸却是爷爷的左儿子的情况。<br><img src="https://i.loli.net/2019/01/10/5c36b992cefb4.png" alt="enter image description here"></p><h5 id="Right-Left-Rotation"><a href="#Right-Left-Rotation" class="headerlink" title="Right-Left Rotation"></a>Right-Left Rotation</h5><p>适用于自己是爸爸的左儿子，爸爸却是爷爷的右儿子的情况。<br><img src="https://i.loli.net/2019/01/10/5c36b73474c33.png" alt="enter image description here"></p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>和之前AVL同理，也是O(logn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Binary-Search-Trees&quot;&gt;&lt;a href=&quot;#Binary-Search-Trees&quot; class=&quot;headerlink&quot; title=&quot;Binary Search Trees&quot;&gt;&lt;/a&gt;Binary Search Trees&lt;/h2&gt;&lt;p&gt;BST是binary tree的一个变种（如名字所示，是便于搜索的变种……？），特点是这样的：&lt;br&gt;对于任何一个node来说，&lt;br&gt;左sub-tree的所有node都比它小，&lt;br&gt;右sub-tree的所有node都比他大。&lt;br&gt;（sub-tree就是以它的left child为root的tree）&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/01/09/5c356a9fd8e70.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree part 1 - 简单粗暴数据结构（5）</title>
    <link href="http://sheronw.github.io/2019/01/07/ds-tree1/"/>
    <id>http://sheronw.github.io/2019/01/07/ds-tree1/</id>
    <published>2019-01-08T03:54:35.000Z</published>
    <updated>2019-01-08T03:59:31.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Terminology"><a href="#Basic-Terminology" class="headerlink" title="Basic Terminology"></a>Basic Terminology</h2><p><img src="https://i.loli.net/2019/01/08/5c34127fa2bf6.png" alt="enter image description here"><br>树，它有一个树干，然后分成很多树枝，树枝再有很多分支（好吧我可能在说废话）。虽然这么说，“树”作为一个数据结构，它通常是倒过来画的，不如说是根更合适hhh<br>和表栈队列不同的是，树是我们接触的第一个非线性（nonlinear）的数据结构（所以难度会飙升）。<br>就和之前的linked list一样，树中的每个单元都是一个node。<br>既然不是线性的，树中的那些nodes是如何联系起来的呢？<br>近一点说，两个node之间是由edge相连（好像是废话），就是图示里面的那条线。<br>那宏观一点呢，一般来讲，树干死了基本上树枝也得挂，所以树干比树枝牛逼——你可以看到，树这个结构是有“阶级制度”的。</p><a id="more"></a><p>每棵树最顶上的那个node叫root（根）。<br>只要一个node在另一个node上面，那么它就是爸爸parent，另外一个就是child儿子。（是的，在lab里面还会看到爷爷和叔伯）<br>如果一个node没有儿子，那么它就是最low的，叫leaf。<br>height是<strong>一棵树</strong>从root到某个leaf的最长路径长度。<br>depth是<strong>一个node</strong>到root的路径长度。</p><h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><p>这就简单了，binary嘛，每一个node都顶多俩儿子，一个叫left child另一个叫right child（如果有的话）。<br><img src="https://i.loli.net/2019/01/08/5c341a504448a.png" alt="enter image description here"></p><h2 id="Tree-traversals"><a href="#Tree-traversals" class="headerlink" title="Tree traversals"></a>Tree traversals</h2><p>因为树不是线性的，所以访问不同node的先后顺序也有很多：</p><h3 id="depth-first"><a href="#depth-first" class="headerlink" title="depth first"></a>depth first</h3><p>其实就是把每个node都当作是某个sub-tree的root然后写递归……下面这三种也只是顺序不太一样而已。而且不觉得这些前缀有些眼熟嘛，就是之前讲的不同运算顺序啊！（可以对比一下想想看hhh？）</p><h4 id="in-order"><a href="#in-order" class="headerlink" title="in-order"></a>in-order</h4><p>爸爸在中间，儿子站两边。<br>用上面的那个图举例子：D B E A F C</p><pre><code>inorder(root):    if root is not NULL:        inorder(root&apos;s left child)        visit root        inorder(root&apos;s right child)</code></pre><h4 id="pre-order"><a href="#pre-order" class="headerlink" title="pre-order"></a>pre-order</h4><p>爸爸站最前面，两个儿子站后面。<br>上图例子：A B D E C F</p><pre><code>preorder(root):    if root is not NULL:        visit root        inorder(root&apos;s left child)        inorder(root&apos;s right child)</code></pre><h4 id="post-order"><a href="#post-order" class="headerlink" title="post-order"></a>post-order</h4><p>爸爸殿后，两个儿子打头阵。<br>上图例子：D E B F C A</p><pre><code>inorder(root):    if root is not NULL:        inorder(root&apos;s left child)        inorder(root&apos;s right child)        visit root</code></pre><h3 id="breath-first"><a href="#breath-first" class="headerlink" title="breath first"></a>breath first</h3><p>也就是说level first。一层一层来，从左到右。<br>上图例子：A B C D E F<br>这个的算法就要用到刚刚讲的队列了：</p><pre><code>create an empty queueenqueue rootwhile queue is not empty:    dequeue a node N    visit N    if N&apos;s left child is not NULL:        enqueue N&apos;s left child    if N&apos;s right child is not NULL:        enqueue N&apos;s right child</code></pre><h2 id="Implementing-Binary-Trees"><a href="#Implementing-Binary-Trees" class="headerlink" title="Implementing Binary Trees"></a>Implementing Binary Trees</h2><p>这段等学完java再仔细讲。<br>和linked list一样，都需要一个叫做node的单元，只不过把prev和next换成了left和right而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-Terminology&quot;&gt;&lt;a href=&quot;#Basic-Terminology&quot; class=&quot;headerlink&quot; title=&quot;Basic Terminology&quot;&gt;&lt;/a&gt;Basic Terminology&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34127fa2bf6.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;br&gt;树，它有一个树干，然后分成很多树枝，树枝再有很多分支（好吧我可能在说废话）。虽然这么说，“树”作为一个数据结构，它通常是倒过来画的，不如说是根更合适hhh&lt;br&gt;和表栈队列不同的是，树是我们接触的第一个非线性（nonlinear）的数据结构（所以难度会飙升）。&lt;br&gt;就和之前的linked list一样，树中的每个单元都是一个node。&lt;br&gt;既然不是线性的，树中的那些nodes是如何联系起来的呢？&lt;br&gt;近一点说，两个node之间是由edge相连（好像是废话），就是图示里面的那条线。&lt;br&gt;那宏观一点呢，一般来讲，树干死了基本上树枝也得挂，所以树干比树枝牛逼——你可以看到，树这个结构是有“阶级制度”的。&lt;/p&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Arithmetic expression - 简单粗暴数据结构（4）</title>
    <link href="http://sheronw.github.io/2019/01/06/ds-arithmetic_expression/"/>
    <id>http://sheronw.github.io/2019/01/06/ds-arithmetic_expression/</id>
    <published>2019-01-06T23:58:47.000Z</published>
    <updated>2019-01-07T02:08:26.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="infix-prefix-postfix"><a href="#infix-prefix-postfix" class="headerlink" title="infix, prefix, postfix"></a>infix, prefix, postfix</h2><p>如下是三种不同的表达式的写法：</p><h3 id="infix"><a href="#infix" class="headerlink" title="infix"></a>infix</h3><p>就是我们从小学到现在一直用的那种。<br>举个例子吧：(A+B)/C-D*C<br>一般来说运算符号都是放在两个数中间的，默认从左到右、不同符号优先级不同，还有括号来规定运算顺序。<br>当然，虽然你懂怎么算，但除非特殊说明，计算机并不知道哪个优先，所以有一种叫做fully parenthesized expression的东西，大概是这样的：(((A+B)/C)-(D*C))。</p><a id="more"></a><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>prefix，顾名思义，就是运算符号放在了两个数字前面，比如这样：A + B变成了+ A B<br>那之前的(A+B)/C-D*C要怎么写呢？从最小的单位（比如A+B）开始改成prefix，然后把这个单位作为一个整体带入到下一轮的转换中：- / + A B C * D C</p><h3 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h3><p>postfix就同理了，只不过符号在数字后面，比如之前的(A+B)/C-D*C就是 A B + C / D C * -</p><h2 id="expression-objects"><a href="#expression-objects" class="headerlink" title="expression objects"></a>expression objects</h2><p>在还没有讲面向对象之前，这一块儿都跳过。反正下面的算法里面在实际程序里面带去的的都不是字符，而是两种不同的东西——要么是一种叫做『运算符』的object，要么是一种叫『数字』的object。</p><h2 id="infix-to-postfix-algorithm"><a href="#infix-to-postfix-algorithm" class="headerlink" title="infix-to-postfix algorithm"></a>infix-to-postfix algorithm</h2><p>这个算法中用栈来暂存运算符号。建议你自己在纸上找一个infix然后自己写写看看hhh<br>首先我们有了一串用infix表示的式子，我们从左到右每次读取一个运算符号或者数字x：<br>如果x是左括号，那么就把它放到stack上；<br>如果x是数字，就把它放到postfix的列表里；<br>如果x是符号，比较x和stack最上面那个符号的优先级，把优先级大于等于它的符号全拿出来放到postfix里，再把x放到stack上；<br>如果x是右括号，就把x丢掉，再把stack上所有东西一个一个拿出来放到postfix里，直到遇到左括号，拿出来删掉。<br>然后最后postfix里面就是我们想要的了。</p><h2 id="evaluate-postfix-algorithm"><a href="#evaluate-postfix-algorithm" class="headerlink" title="evaluate postfix algorithm"></a>evaluate postfix algorithm</h2><p>这个就和我们之前手动转换infix和postfix的原理很像了，就是两个数字和一个运算符号作为一个小单元。<br>还是那样子，还是需要一个stack，假设我们有一串用postfix表示的式子，从左到右每次读取一个运算符号或者数字x：<br>如果x是一个数字，就放在stack上；<br>如果x是一个运算符号，就把stack最上面的两个数拿出来（最先拿出来的是正常从左到右运算里面的第二个数），算一个数值，再把这个数放回stack上；<br>最后，如果式子正确，读取完毕后，stack上应该只有唯一的一个数，这个就是我们所要求的结果。</p><p><a href="http://interactivepython.org/runestone/static/pythonds/BasicDS/InfixPrefixandPostfixExpressions.html" target="_blank" rel="external">可以参考这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;infix-prefix-postfix&quot;&gt;&lt;a href=&quot;#infix-prefix-postfix&quot; class=&quot;headerlink&quot; title=&quot;infix, prefix, postfix&quot;&gt;&lt;/a&gt;infix, prefix, postfix&lt;/h2&gt;&lt;p&gt;如下是三种不同的表达式的写法：&lt;/p&gt;
&lt;h3 id=&quot;infix&quot;&gt;&lt;a href=&quot;#infix&quot; class=&quot;headerlink&quot; title=&quot;infix&quot;&gt;&lt;/a&gt;infix&lt;/h3&gt;&lt;p&gt;就是我们从小学到现在一直用的那种。&lt;br&gt;举个例子吧：(A+B)/C-D*C&lt;br&gt;一般来说运算符号都是放在两个数中间的，默认从左到右、不同符号优先级不同，还有括号来规定运算顺序。&lt;br&gt;当然，虽然你懂怎么算，但除非特殊说明，计算机并不知道哪个优先，所以有一种叫做fully parenthesized expression的东西，大概是这样的：(((A+B)/C)-(D*C))。&lt;/p&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm Analysis - 简单粗暴数据结构（3）</title>
    <link href="http://sheronw.github.io/2019/01/05/ds-algs_analysis/"/>
    <id>http://sheronw.github.io/2019/01/05/ds-algs_analysis/</id>
    <published>2019-01-06T04:32:05.000Z</published>
    <updated>2019-01-06T04:41:00.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="big-oh-notation"><a href="#big-oh-notation" class="headerlink" title="big-oh notation"></a>big-oh notation</h2><p>其实大O符号的标准定义是这样的：<br>设f和g是定义域为自然数集N上的函数，若存在正数c和n，使得对一切n&gt;n<sub>0</sub>，0&lt;=f(n)&lt;=cg(n)成立，则称<strong>f(n)的渐进上界g(n)，记作f(n)=O(g(n))</strong>。<br>……虽然我希望你认真地 阅读以上定义并理解，但如果是非本专业的学生，只是学学数据结构的话，算法分析方面的知识只要下狠心背下来就ok，这个定义不看也可以的（当然知道这玩意儿是渐进上界倒是能够帮助理解）。</p><a id="more"></a><p>大白话来讲（虽然可能这么说有点差错），big-oh notation就是一个近似函数，而且是比原函数要大的那种。当然也不要求一直都大，但一定要在某个值之后一定比这个值要大。<br>大概就是下图这样？不要纠结函数形状，只要g(n)超过一个值之后一直比O(g(n))大就行……<br><img src="https://i.loli.net/2019/01/06/5c31685b1e670.png" alt="enter image description here"><br>几个在这个阶段会比较有用的定理：</p><ul><li>if f(n) is O(c*g(n)) for some constant c, then f(n) is O(g(n))</li><li>(前面的系数是可以忽略的)</li><li>If f<sub>1</sub>(n) is O(g<sub>1</sub>(n))and f<sub>2</sub>(n) is O(g<sub>2</sub>(n), then f<sub>1</sub>(n)+f<sub>2</sub>(n) is O(max(g<sub>1</sub>(n), g<sub>2</sub>(n))</li><li>(两个函数相加，对长远趋势起决定性作用的肯定是增的更快的那个，所以忽略更小的函数)</li><li>对数的底并不重要（有个公式也很好推导，不放了）</li></ul><h2 id="running-times-for-common-algorithms"><a href="#running-times-for-common-algorithms" class="headerlink" title="running times for common algorithms"></a>running times for common algorithms</h2><p>但是，这个big-oh notation到底有什么用呢？它是衡量一个程序（或者说，算法）好坏的重要指标。毕竟我们总是希望一个程序需要的内存越少越好，运行的时间越快越好。因为这节课没有涉及内存（空间复杂度）的分析，所以只需要知道如何分析时间就好了。<br>程序运行的时间其实和运行这个程序的机器还有编译器之类的都有关，但我们暂时不去管它们，那么还有关的就是输入的<strong>数据量</strong>（也就是说n）还有<strong>算法</strong>本身了。running time就是一个自变量为n的函数，但因为还有别的影响因素，也没有那个成本一个个程序统计精确的函数值（也不需要），所以就用到了近似函数Big-Oh notation啦。<br>当然，同一个算法，由于输入的数据不同，running time也是不一样的，总的来说，有如下三种：</p><ul><li>best-case running time</li><li>average-case running time</li><li>worst-case running time</li></ul><p>默认情况下，都是分析worst-case running time，毕竟最坏情况下的运行时间也肯定是平均情况的上界……best-case感觉很少分析，因为好像没用……？</p><p>举个例子，最简单粗暴的线性搜索，共有n个数据，for循环从第一个开始一个个查的那种。</p><ul><li>要是我们人品好，发现第一个就是我们要的，一次就搜到了，best-case running time就是O(1)。</li><li>要是我们运气没那么差，数据的index在1~n-1之间，那也是小于n的某个值，不会超过n，那么渐进上界仍然是n，average-case running time就是O(n)。</li><li>要是正好最后一个数据才是我们要找的……就说明我们搜了n次，worst-case running time还是O(n)。</li></ul><p>那么其他的程序怎么分析呢？<br>遇到循环体，不管是for还是while先看看这段程序要运行几次（用n表示），然后它就是循环的这部分前面的系数。<br>而一段程序可以分为多个运行部分的和，按照前面的定理，只要找出最耗时间的那一部分，剩下的全忽略就好。</p><pre><code>printf(&quot;WOW&quot;); //不管输入的数据有多少，运行上面这行代码所需要的都是常数时间，只要是常数时间都算O(1)for(int i=0;i&lt;n;i++){//运行了n次    printf(&quot;???&quot;);    //同理O(1)}//所以是O(1+n*1)=O(n)</code></pre><p>Binary Search是O(logn)，这个显然比刚刚那个快。大概就是给定一堆排好序的数据，看看中间的数据比搜索数据大还是小，这样就可以排除一半的数据，然后以此类推，最坏的情况是直到搜索范围只剩下1。<br>因为每次比较搜索数据和数据中的某个数据哪个大都是常数时间，所以只需要找出最坏要搜索多少次就可以了。如果一共有8个数据，第一次没搜到，缩小到4个数据，还没找到，缩小到2个数据……你会发现数据的总数=2^(总搜索次数)，也就是说总搜索次数=log<sub>2</sub>n，也就是O(logn)。</p><h2 id="recurrence-relations"><a href="#recurrence-relations" class="headerlink" title="recurrence relations"></a>recurrence relations</h2><p>虽然老师上课没这么讲，但我觉得对付递归的最好方法是一个叫做递归树的画图方法。<br>比如用递归来求斐波那契数列吧（请注意，这是一个非常糟糕的算法）。<br>伪代码差不多是这样事儿的：</p><pre><code>f(n):    if n==0 or n==1:        return n    else:        return f(n-1)+f(n-2)</code></pre><p>首先，要找出来T(n)和下一层递归的关系。在n比较大的情况下，想求f(n)就要把f(n-1)和f(n-2)都算出来，两个都需要时间，而得到这两个值之后相加是常数时间O(1)，所以关系就是T(n)=T(n-1)+T(n-2)。<br>递归树的原理是这样的，先在每一个节点都写上这一层需要运行的时间，然后把这个运行时间拆成一棵树，只属于这个节点的运行时间留下，剩下的放到下一层。每画一个树，三个节点的和都等于没拆分之前单独一个节点的运行时间。<br><img src="https://i.loli.net/2019/01/06/5c317ff7b4aa8.png" alt="enter image description here"><br>这样我们就画出来了一棵树……其实每个分支节点的高度不应该是一样的，但毕竟是渐进上界嘛，这个树差不多有n层（最长的那一条应该是一路往左，每次减一），每个节点是O(1)，那么T(n)=O(1)+O(2)+O(4)+…+O(2<sup>n</sup>)，按照公式T(n)=O(2<sup>n</sup>)。<br>所以这个玩意儿显然是成指数增长的，数一大就会变得巨慢无比（不信可以跑跑看看），不是个好算法……<br>一般来说，O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^a)&lt;O(a^n)，a是一个常数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;big-oh-notation&quot;&gt;&lt;a href=&quot;#big-oh-notation&quot; class=&quot;headerlink&quot; title=&quot;big-oh notation&quot;&gt;&lt;/a&gt;big-oh notation&lt;/h2&gt;&lt;p&gt;其实大O符号的标准定义是这样的：&lt;br&gt;设f和g是定义域为自然数集N上的函数，若存在正数c和n，使得对一切n&amp;gt;n&lt;sub&gt;0&lt;/sub&gt;，0&amp;lt;=f(n)&amp;lt;=cg(n)成立，则称&lt;strong&gt;f(n)的渐进上界g(n)，记作f(n)=O(g(n))&lt;/strong&gt;。&lt;br&gt;……虽然我希望你认真地 阅读以上定义并理解，但如果是非本专业的学生，只是学学数据结构的话，算法分析方面的知识只要下狠心背下来就ok，这个定义不看也可以的（当然知道这玩意儿是渐进上界倒是能够帮助理解）。&lt;/p&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Stack &amp; Queue - 简单粗暴数据结构（2）</title>
    <link href="http://sheronw.github.io/2019/01/04/ds-stackandqueue/"/>
    <id>http://sheronw.github.io/2019/01/04/ds-stackandqueue/</id>
    <published>2019-01-05T01:57:50.000Z</published>
    <updated>2019-01-05T01:57:30.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Stack，中文名叫栈。<br>和之前说到的表一样都是线性的数据结构。但区别是只能在一个方向上进行添加或者移除的操作，也就是先进先出。比较形象化的比喻是，一沓盘子，每次只能取走最上面的那个盘子，或者在最上面放一个盘子。<br>至于可以执行的操作，可以看<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html" target="_blank" rel="external">官方文档</a>。加盘子叫push，拿盘子叫pop，查看最上面的盘子是啥（但是不拿走）叫peek。<br><a id="more"></a></p><p>Queue，中文名叫队列。<br>和stack很像，只不过这次是先进后出，就像排队等车一样，前面的人上车走了，新来的人要排队尾。<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html" target="_blank" rel="external">官方文档</a>，拉新人排队叫enqueue，前面的人上车叫dequeue，peek是看排在最前面的是谁（但不叫上车）。</p><p>Deque，全称是double-ended queue，它作为一个队列就比较牛逼了，不管是队尾还是对首都可以随便加人或者拉人，就像一个只能在表尾或者表首进行添加删除操作的List……</p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><p>老样子，2 implementations: Array &amp; LinkedList</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>用array来implement的话就很简单了，而且方法显然不止一种。首先我们需要一个计数器n来记录这个stack里面有多少个盘子，空的时候默认为0，这样最上面的盘子index就是n-1，peek就可以直接读n-1这个格子的值了，加盘子就加到第n个格子里面然后更新计数器为n+1，拿盘子同理。如果遇到array不够用的情况，就用之前在list里面遇到的方法把容量扩充一下。<br>用linked list的话更简单，只要把之前list里面添加或者删除node的操作在最前面那里操作一下然后改一下计数器就可以了。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>用array的话，首先可以用front和back两个变量来记录队首和队尾的坐标，然后和刚刚一样添加删除，就是下图的这种情况：<br><img src="https://i.loli.net/2019/01/05/5c3006700c652.png" alt="草图.png"><br>然后你会惊恐地发现现在已经没法再往里加任何新的东西了……但这个array却有大块的内存没被填满，和之前一样将array扩充显然不是一个好主意hmmmm<br>为了让前面那块内存不白白浪费，把之后新加进来的东西放进去可能是个好主意。具体怎么放呢？想象这个array就是一张纸，然后把这张纸卷起来首尾相连，然后按照之前的方法添加删除就好啦！这样只有里面空间全满才需要重新将array扩充了。</p><p>可是如果这么做的话，在front或者back的index变成n（就是这个array的容量）的时候，显然这个index不合法，毕竟不能再往后加了，这个时候要把这个index改成零重新来过了。（实际操作的时候在每个地方写判断语句显然很麻烦，不如写一个function然后每次用到index的时候都调用）<br>array扩充的时候也要小心，不能和之前的list一样从头复制到尾，应该把最前面的东西放在index为零的位置，然后一个一个向后。<br><img src="https://i.loli.net/2019/01/05/5c300de927fbe.png" alt="enter image description here"><br>用linked list的话就没什么难度了，还是添加删除node然后更新计数器的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;p&gt;Stack，中文名叫栈。&lt;br&gt;和之前说到的表一样都是线性的数据结构。但区别是只能在一个方向上进行添加或者移除的操作，也就是先进先出。比较形象化的比喻是，一沓盘子，每次只能取走最上面的那个盘子，或者在最上面放一个盘子。&lt;br&gt;至于可以执行的操作，可以看&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。加盘子叫push，拿盘子叫pop，查看最上面的盘子是啥（但是不拿走）叫peek。&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>the List interface - 简单粗暴数据结构（1）</title>
    <link href="http://sheronw.github.io/2019/01/03/ds-list/"/>
    <id>http://sheronw.github.io/2019/01/03/ds-list/</id>
    <published>2019-01-04T01:45:50.000Z</published>
    <updated>2019-01-05T00:13:25.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-List-Interface"><a href="#The-List-Interface" class="headerlink" title="The List Interface"></a>The List Interface</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>顾名思义，就是一个表。<br>按照惯例，index从零开始，每一个元素都有一个相应的index。<br>至于可以执行的操作，可以看<a href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html" target="_blank" rel="external">官方文档</a>。比较基本的有添加、删除、查找等。<br><a id="more"></a></p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><p>2 implementations: ArrayList &amp; LinkedList</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>什么是Array？<br>我的理解是，指定数据型（或者object）T，array可以在内存里面画出一块区域来储存<strong>给定数量</strong>的T。因此array的长度在初始化时必须声明。之后也不能改。<br>所以用array来搞list的话，其实还是挺麻烦的，比如在非list的结尾进行删除或者添加的操作，就得把所有后面的元素一个一个往后挪。<br>还有一个就是，因为array是给定数量的，但list指不定会往里加多少东西，所以一旦这个array快满了的时候我们就得新建一个array，把现有元素都一个个复制到新的里面，然后重定向list的array指针为这个新的array。<br>（*其实并不是真的用到了指针这个东西，只是为了帮助理解，具体的之后会说）<br><img src="https://i.loli.net/2019/01/04/5c2eaff197a53.png" alt="enter image description here"></p><h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><p>linked list就是一串首尾相连的单位，每个单位叫node。<br>最基本的node里面需要两种东西，第一种是这个node里面真正储存的数据，另外一种是指向下一个node的指针next。</p><h4 id="head-and-tail-pointers"><a href="#head-and-tail-pointers" class="headerlink" title="head and tail pointers"></a>head and tail pointers</h4><p>为了让我们能够在处理的时候能够找得着北，我们需要知道哪一个node是第一个，哪一个node是最后一个。每一个这样的liked list里面都有一个head node和一个tail node，指向相应的node，进行添加删除首尾node之类的操作的时候需要相应地update。<br>至于如何添加或删除node，首先我们需要一个叫做iterator的特殊的node指针来确定我们正在操作的node是哪一个（就跟基础课里面while循环的index计数器i一样），将它挪到相应的位置之后新建一个node并赋值，然后就是相关的几个指向的替换游戏了hmmm<br><img src="https://i.loli.net/2019/01/04/5c2eba55b74be.png" alt="enter image description here"></p><h4 id="doubly-linked"><a href="#doubly-linked" class="headerlink" title="doubly-linked"></a>doubly-linked</h4><p>其实和前面那种差不多，区别就是前面的是单向箭头，现在变双向了，每一个node里面都有一个指向后一个node的prev和指向下一个node的next。</p><h4 id="circular"><a href="#circular" class="headerlink" title="circular"></a>circular</h4><p>虽然还是需要head提醒我们哪里是开头，但这次我们不要tail了，直接把最后一个连到第一个node上。</p><h4 id="sentinel-nodes"><a href="#sentinel-nodes" class="headerlink" title="sentinel nodes"></a>sentinel nodes</h4><p>circular的升级版，可以把这个sentinel node想象成项链上的那个搭扣，连接了第一个node和最后一个node。</p><p><img src="https://i.loli.net/2019/01/04/5c2eb80d92f81.png" alt="enter image description here"></p><p><a href="https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm" target="_blank" rel="external">https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm</a><br><a href="https://www.tutorialspoint.com/data_structures_algorithms/doubly_linked_list_algorithm.htm" target="_blank" rel="external">https://www.tutorialspoint.com/data_structures_algorithms/doubly_linked_list_algorithm.htm</a><br><a href="https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm" target="_blank" rel="external">https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The-List-Interface&quot;&gt;&lt;a href=&quot;#The-List-Interface&quot; class=&quot;headerlink&quot; title=&quot;The List Interface&quot;&gt;&lt;/a&gt;The List Interface&lt;/h1&gt;&lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;p&gt;顾名思义，就是一个表。&lt;br&gt;按照惯例，index从零开始，每一个元素都有一个相应的index。&lt;br&gt;至于可以执行的操作，可以看&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/List.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。比较基本的有添加、删除、查找等。&lt;br&gt;
    
    </summary>
    
      <category term="简单粗暴数据结构" scheme="http://sheronw.github.io/categories/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年度书单</title>
    <link href="http://sheronw.github.io/2018/12/31/2018booklist/"/>
    <id>http://sheronw.github.io/2018/12/31/2018booklist/</id>
    <published>2019-01-01T01:35:17.000Z</published>
    <updated>2019-01-05T02:00:43.676Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得我今年没怎么读书，准确来讲是没逼着自己读书，结果就是读了好多虚构类(其实就是小说……)<br><a id="more"></a></p><ol><li>《人月神话》 Frederick P. Brooks, Jr.</li><li>《China’s Urban Billion》 Tom Miller</li><li>《生命是什么》 薛定谔</li><li>《黑暗时代的她们》 杰奎琳 罗斯</li><li>《欢乐英雄》 古龙</li><li>《觅渡》 梁衡</li><li>《白》 原研哉</li><li>《激荡三十年 ：中国企业1978-2008》 吴晓波</li><li>《激荡十年，水大鱼大 2008-2018》 吴晓波</li><li>《呐喊》 鲁迅</li><li>《直到最后一句》 卢丽莉</li><li>《布鲁克林有棵树》贝蒂 史密斯</li><li>《人类简史》 尤瓦尔 赫拉利</li><li>《未来简史》 尤瓦尔 赫拉利</li><li>《爱上她的12种方法》 入间人间</li><li>《后羿》 叶兆言</li><li>《红玫瑰与白玫瑰》 张爱玲</li><li>《文心》夏沔尊 叶圣陶</li><li>《下流社会》三浦展</li></ol><p>八本虚构类文学里面，《后羿》和《直到最后一句》都是二刷，而且还是明明知道评价不怎么样但是因为各种各样的共鸣感还是去二刷了的那种，不评价。<br>梁衡的散文集真的是因为被写瞿秋白和项羽的那篇给惊艳到了(毕竟是喜欢了一整个中学时代的文章)才买的，之后发现文笔不错官腔太多，不太喜欢。<br>忘了在哪儿听说了红白玫瑰就去图书馆借了本张爱玲，对这种小布尔乔亚不太感兴趣，但这个两性关系的研究是真滴巧妙，虽然我我不知道为什么一看到男主内心戏里就觉得膝盖中枪，读完赶紧借了本同时代的鲁迅。<br>入间人间那本还是电波系，一个男的被另外一个男的和自己喜欢的妹子虐狗，没有之前660有意思。<br>布鲁克林里面人名太难记，不过毕竟是几十年前的美国鸡汤，平平淡淡读着挺舒服的。<br>《欢乐英雄》受众比较广也不烧脑，而且我就是喜欢古龙比金庸更多一些。</p><p>非虚构类，《人月神话》差不多算是软工专业书了，薛定谔的那本也烧脑，但努力get到他在说啥时候就会觉得卧槽这个人怎么这么聪明，看世界的角度都变得物理学家了起来。<br>《文心》更适合给初中生普及语文知识，学校的语文课真的很不到位。<br>黑暗时代的她们就是致敬类传记，在西方很政治正确的那种，几个妹子我都喜欢，翻译略差。<br>原研哉那本还是《设计中的设计》的核心思想，只不过挑出来一部分细讲了。<br>《中国十亿城民》(虽然我看的是英文版)和《下流社会》都不是太新鲜的书，但里面的问题都显然没解决，一个是发展中国家城市化的冲突，另一个是发达国家看不见的阶级固化，类似的书挺多的。<br>安利吴晓波的激荡系列，根正苗红是不假，问题是读起来真他妈有意思。<br>简史系列同理，明明是融合了多个学科观点的历史书，但不知道为什么就像看起点爽文一样顺。能写出这样的畅销书，两个作者我是真的服气。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得我今年没怎么读书，准确来讲是没逼着自己读书，结果就是读了好多虚构类(其实就是小说……)&lt;br&gt;
    
    </summary>
    
      <category term="reading" scheme="http://sheronw.github.io/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>Operating Systems Basics </title>
    <link href="http://sheronw.github.io/2018/11/17/OSB/"/>
    <id>http://sheronw.github.io/2018/11/17/OSB/</id>
    <published>2018-11-17T14:15:43.000Z</published>
    <updated>2018-11-17T14:17:50.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS-tasks"><a href="#OS-tasks" class="headerlink" title="OS tasks"></a>OS tasks</h2><ul><li>managing the resources of a computer (hardware network, etc.)</li><li>coordinate the running of all other programs</li><li>can be considered as a set of programs<ul><li>kernel: name given to the core OS program<h2 id="Getting-program-to-run"><a href="#Getting-program-to-run" class="headerlink" title="Getting program to run"></a>Getting program to run</h2></li></ul></li><li>POST - test program from specific location in BIOS</li><li>Boot loader - “bootstrap loader”<ul><li>small program that begins loading the OS<ul><li>computer cannot run without 1st loading software, but needs instructions on how to load software</li></ul></li><li>might have multi stages</li></ul></li><li>kernel is loaded into memory &amp; executed</li><li>kernel runs “init” process &amp; sets runlevel</li><li>initialization scripts</li></ul><a id="more"></a><h2 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h2><ul><li>set of functions to request access to resources of the machine</li><li>system call numbers</li><li>often referred to as an API (Application Programming Interface)</li><li>differ by platform &amp; standards</li><li>APP-Kernel-(CPU&amp;Memory&amp;Devices)</li><li>C standard lib contains wrappers around system calls</li><li><p>behavior on x86 is essentially</p><ul><li>set up parameters to pass to sc</li><li>put all num in register EAX</li><li>trigger HW interrupt</li><li><a href="http://www.linux.it/~rubini/docs/ksys/" target="_blank" rel="external">http://www.linux.it/~rubini/docs/ksys/</a><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3></li><li>replace current running program as another program</li><li>execve<h3 id="Process-IDs"><a href="#Process-IDs" class="headerlink" title="Process IDs"></a>Process IDs</h3></li><li>every unix process has a unique identifier (int)</li><li>pid_t getpid(void);</li><li>every process has a parent process</li><li>pid_t getppid(void);</li><li><p>processing tables: ps</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p> #include<unistd.h><br> #include<sys types.h=""><br> pid_t fork(void);</sys></unistd.h></p></li><li><p>creating an identical copy of the running program with one exception</p></li><li>return 0 to the child, PID to the parent</li><li>vfork(): fork&amp;exec</li><li>process exit status<ul><li>can wait until the child process ends</li><li>wait() can return the exit status of child</li><li><strong>WIFEXITED</strong> return true if normally</li><li><strong>WEXITSTATUS</strong> extract actual return/exit value</li></ul></li></ul></li></ul><h3 id="Memory-management-calls"><a href="#Memory-management-calls" class="headerlink" title="Memory management calls"></a>Memory management calls</h3><ul><li>mmap - allocate memory or map files/devices into memory</li><li>shmget</li><li>shmctl</li><li>mprotect</li><li>mlock, munlock<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><ul><li>time, gettimeofday/settimeofday</li><li>getitimer, setitimer</li><li>alarm</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OS-tasks&quot;&gt;&lt;a href=&quot;#OS-tasks&quot; class=&quot;headerlink&quot; title=&quot;OS tasks&quot;&gt;&lt;/a&gt;OS tasks&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;managing the resources of a computer (hardware network, etc.)&lt;/li&gt;
&lt;li&gt;coordinate the running of all other programs&lt;/li&gt;
&lt;li&gt;can be considered as a set of programs&lt;ul&gt;
&lt;li&gt;kernel: name given to the core OS program&lt;h2 id=&quot;Getting-program-to-run&quot;&gt;&lt;a href=&quot;#Getting-program-to-run&quot; class=&quot;headerlink&quot; title=&quot;Getting program to run&quot;&gt;&lt;/a&gt;Getting program to run&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;POST - test program from specific location in BIOS&lt;/li&gt;
&lt;li&gt;Boot loader - “bootstrap loader”&lt;ul&gt;
&lt;li&gt;small program that begins loading the OS&lt;ul&gt;
&lt;li&gt;computer cannot run without 1st loading software, but needs instructions on how to load software&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;might have multi stages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;kernel is loaded into memory &amp;amp; executed&lt;/li&gt;
&lt;li&gt;kernel runs “init” process &amp;amp; sets runlevel&lt;/li&gt;
&lt;li&gt;initialization scripts&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="notetaking" scheme="http://sheronw.github.io/categories/notetaking/"/>
    
    
  </entry>
  
  <entry>
    <title>Formatted I/O, Line Input, Scanf - C</title>
    <link href="http://sheronw.github.io/2018/11/06/Formatted-I-O-Line-Input-Scanf-C/"/>
    <id>http://sheronw.github.io/2018/11/06/Formatted-I-O-Line-Input-Scanf-C/</id>
    <published>2018-11-06T20:15:43.000Z</published>
    <updated>2018-11-06T20:18:28.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="read-a-file-from-stdin-and-put-it-to-both-stdout-amp-stderr"><a href="#read-a-file-from-stdin-and-put-it-to-both-stdout-amp-stderr" class="headerlink" title="read a file from stdin and put it to both stdout &amp; stderr"></a>read a file from stdin and put it to both stdout &amp; stderr</h2><pre><code>int main (int argc, char *argv[]){    char *fname = NULL;    if (argc&gt;1){        frame=argv[1];    }    else{        return 1;    }    FILE *file = fopen(fname, &quot;r&quot;);    int input;    while((input=fgetc(file))!= EOF){        fputc(input,stdout);        fputc(input,stderr);    }}</code></pre><a id="more"></a><p>end of file ^D<br>end program ^C<br>stderr line buffer<br>stdout file buffer(???)</p><h2 id="re-reading"><a href="#re-reading" class="headerlink" title="re-reading"></a>re-reading</h2><pre><code>void rewind(FILE *stream);</code></pre><p>changing location of a file to the beginning<br>fseek: move to some location</p><h2 id="getting-location"><a href="#getting-location" class="headerlink" title="getting location"></a>getting location</h2><pre><code>long ftell(FILE * stream);off_t ftello(FILE *stream);</code></pre><p>if is larger than a long in size, then:</p><pre><code>int fgetpos(FILE *restrict stream, fpos_t *restrict pos);int fsetpos(FILE *stream, const fpos_t *pos);</code></pre><p>need to check man page for different systems<br>df: space of hard drive<br>file: blocks of pointers point to a chunk of data blocks of actual disk</p><h2 id="Format-Printing"><a href="#Format-Printing" class="headerlink" title="Format Printing"></a>Format Printing</h2><h3 id="printing-to-a-string"><a href="#printing-to-a-string" class="headerlink" title="printing to a string"></a>printing to a string</h3><pre><code>int sprintf(char *str, const char *format, /* args */ );</code></pre><ul><li>return number of bytes that would have been written</li><li>writes at most size-1 bytes (leave space for null byte)</li></ul><h3 id="line-based-input"><a href="#line-based-input" class="headerlink" title="line based input"></a>line based input</h3><pre><code>char *fgets(char *str, int size, FILE *stream);</code></pre><ul><li>stores in str</li><li>stops at -n, EOF</li><li><strong>do not use gets</strong></li></ul><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><pre><code>scanf(&quot;%d&quot;,&amp;x);scanf(&quot;%s&quot;,str);</code></pre><ul><li>read line using fgets(), parses data using sscanf() from line</li><li>character ranges(check textbook)<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3>  void <em> realloc(void </em>ptr, size_t size);</li><li>change previous allocated block ptr be changed to size size(larger or smaller &amp; copy old data as needed)</li><li><p>app: connect strings</p><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>  ssize_t getline(char <em>* linep, size_t </em>linecapp, FILE * stream);<br>  free(linep);</p></li><li><p>dynamically allocated, but must free later</p></li><li>not part of c standard</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;read-a-file-from-stdin-and-put-it-to-both-stdout-amp-stderr&quot;&gt;&lt;a href=&quot;#read-a-file-from-stdin-and-put-it-to-both-stdout-amp-stderr&quot; class=&quot;headerlink&quot; title=&quot;read a file from stdin and put it to both stdout &amp;amp; stderr&quot;&gt;&lt;/a&gt;read a file from stdin and put it to both stdout &amp;amp; stderr&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int main (int argc, char *argv[]){
    char *fname = NULL;
    if (argc&amp;gt;1){
        frame=argv[1];
    }
    else{
        return 1;
    }
    FILE *file = fopen(fname, &amp;quot;r&amp;quot;);

    int input;
    while((input=fgetc(file))!= EOF){
        fputc(input,stdout);
        fputc(input,stderr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="notetaking" scheme="http://sheronw.github.io/categories/notetaking/"/>
    
    
  </entry>
  
  <entry>
    <title>KARASU</title>
    <link href="http://sheronw.github.io/2018/03/24/karasu/"/>
    <id>http://sheronw.github.io/2018/03/24/karasu/</id>
    <published>2018-03-24T14:00:00.000Z</published>
    <updated>2019-01-13T19:53:06.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不知道该起什么名，叫八沢之鸦太不知所云，叫暗翼之鸦太中二，直接叫鸦又土，还是直接用鸦的罗马音算了（起名废的纠结）。</p><p>初中毕业的那个暑假坐公交车的时候突然想到的脑洞，高一下学期写完了，一不小心就拖了这么久才录到电脑里，现在看来这真的是一个十分沙雕的小说，不过我也懒得改了。（可能还有错别字？）<br><a id="more"></a></p></blockquote><h1 id="KARASU-1st-Story-广末花火"><a href="#KARASU-1st-Story-广末花火" class="headerlink" title="KARASU 1st Story 广末花火"></a>KARASU 1st Story 广末花火</h1><h2 id="ACT-1"><a href="#ACT-1" class="headerlink" title="ACT-1"></a>ACT-1</h2><p>  沉默划破喧嚣。花火穿过藏青色制服的海洋，走进古老高楼间狭小的巷子。日暮西沉，跳动的光没入漆黑的瞳孔。自然垂在两侧的双手，影子的末端却幻化成了羽翼的形状。黑色的翅膀。</p><p>  和楼房一样古老的铁质逃生梯每走一步都会发出难听的涩响，城市中逐渐点亮的夜灯模糊跳动着，头顶却是楼间的夹缝中被烧红了的天。</p><p>  花火踉跄了一下，跪倒在楼梯上，铁锈粘在洁白的短袜上，留下难看的痕迹。她死命用手抓住赤红色的水兵服衣襟，半晌才挤出一句话。</p><p>  『鸦，别闹了，我们就要到家了。』</p><p>  怪异的话语被风送走，穿过飘动的发丝消失在城市上空。</p><h2 id="ACT-2"><a href="#ACT-2" class="headerlink" title="ACT-2"></a>ACT-2</h2><p>  『那只是先天性的心脏病。』</p><p>  花火坐在桌子的尽头，对面是白大褂的医生。藏青色与白色。</p><p>  『……那只是？』医生故作惊讶地挑眉。『从这些年追踪的校园体检结果来看……已经相当严重了呢。』</p><p>  『这是我自己的事情。』从刚走进这间屋子开始，花火就漫不经心地盯着医生胸前的铭牌。如果父亲还在世的话，应该比他要老一点吧……照片上的男子干练利落，露出一丝不苟的神情。名字是……北川慎之。姓北川的似乎很多，不过给孩子起名为『慎』，还真是恶趣味。</p><p>  『除掉『那个』的手术，放到当今已经不是医学难题了，如果不放心的话，我这里有一些成功案例和对应康复情况……』</p><p>  『够了。』花火冷冷打断医生的话。『这已经是第三次会谈论吧，你应该知道我不会变更心意了。』</p><p>  『可是，有一个怪物压迫着心脏，争夺体内的养料，想必也不会是什么愉快的事情吧，你有没有想过，如果有一天，变得像那些普通人一样……』北川医生装出放松的姿态向后仰，倒在椅背上陷入了沉默。</p><p>  『争夺？』花火缓缓地吐出这两个字。</p><p>  『鸦是我的孩子，我愿意为它付出一切。』</p><p>  屋里只剩下藏青与白的无尽荒漠，以及束缚在表盘内永不停息的秒针的躁动声。</p><h2 id="ACT-3"><a href="#ACT-3" class="headerlink" title="ACT-3"></a>ACT-3</h2><p>  花火蜷缩在走廊的阴影处。鸦的任何一个小动作都会让她感觉仿佛心脏被人捏碎，无力的疼痛感。</p><p>  她告诉自己这已经习以为常。</p><p>  透过对面的窗户可以看到火烧云。一大朵，一大朵，再熟悉不过的景色。</p><p>  『鸦……今天也是平平安安的呢。』花火挤出笑容。</p><p>  『所以，我们回去吧。』说着，花火艰难地准备起身。</p><p>  夕照的光线突然被阴影挡住，花火逆着光线，抬起头来看那挡住光的少年。</p><p>  『嗯……铃城同学？』</p><p>  少年的发丝被落日染成十分好看的金色，本来颜色就比较浅的眸子也像是闪着光点。</p><p>  『你没事吧？』</p><p>  ——花火听到他这样说。</p><p>  紧接着，她听到了一声浅浅的叹息。</p><p>  『心脏病又犯了吗？』</p><p>  有那么一瞬间，花火的脑海中闪过有些罪恶的想法——利用别人的同情来方便自己，又未尝不可呢？看那世上有多少戴着假面的人，贴上弱者的标签，只为等待被施舍。</p><p>  这念头在心里生出幼嫩的芽，仿佛要包裹住整个心脏，渐渐缩紧。</p><p>  又是一阵剧痛。</p><p>  趁着发呆的空档，少年已经毫不费劲地将她轻轻地从冰冷的地面上扶了起来。</p><p>  『焰君……谢谢。』花火眼眶中的泪水正在打转。</p><p>  就像是掩饰自己心中的嗤笑一般。</p><p>  ——结果你不是也装成了这副模样，去博得他人同情了么，这不就和你所厌恶的一样了么。</p><p>  可是，暖意还是不争气地占了上风。</p><p>  啊啊，为什么呢。花火无视了少年担心以及不解的眼神，视线一片模糊，有泪水正在急速下坠。</p><p>  为什么会被这种小事给感动得一塌糊涂呢。</p><p>  在这个世界上还是有很多善良的人吧，大概。花火的嘴角微微上扬。</p><p>  『好些了吗？』她听到焰在旁边这么问。</p><p>  『没事了。』花火摇摇头。</p><p>  ……如果鸦也能够成为如夕暮一样温暖的孩子就好了。花火如此想道。</p><h2 id="ACT-4"><a href="#ACT-4" class="headerlink" title="ACT-4"></a>ACT-4</h2><p>  『组织那边说，如果同意接受手术，会有一份可观的补贴。』</p><p>  花火不用抬头也知道那是北川医生的声音。天知道他怎么进的校门。</p><p>  八月的蝉在树上不停聒噪着，树枝与绿叶在两人的衣服上投下斑斑驳驳的影子。远处传来体育课上女生打排球的嬉闹声。</p><p>  『不需要。』花火一动不动地抱膝坐在树下，将下巴搁在膝盖上，目光飘向远方。『为什么要如此执着，我已经拒绝过了。』</p><p>  『那你应该知道你的父母是怎么死的吧。』北川站在树荫下点了一支烟。『所以，这是复仇哦，不是挺好的嘛。』</p><p>  花火深深地吸了一口气，陷入了沉默。半晌，才回答道：『那些都与这孩子没有关系。』</p><p>  ——因为，如果没有这孩子的话，就真的只剩我一人了。</p><p>  『嗯……如果那东西生出来的话，不仅你肯定会没命，而且还会祸害不知道多少人呢，比如，嘛……如果那个叫『铃城焰』的也被杀掉了的话……』北川像是自言自语地喃喃道。『那好吧，看样子你们要下课了，在下先告辞。』</p><p>  一阵夏风吹过，整个世界再次充满了蝉鸣与树叶的沙沙声。</p><p>  花火看着远处的同学们集合，然后解散。</p><p>  『怎么样，感觉好些了吧？』这一次是铃城焰，还是如往常一样关切的问候。</p><p>  『没有你想象得那么严重，我又不是一直胸口痛。』花火拍了拍裙子上的土。『这种情况下我自己也能够站起来。』</p><p>  『那还真是太好了。』焰站在树影外围，抱着足球挥手告别。『那么，我去换衣服了。』</p><p>  『再见。』花火看见一身白色运动服的焰在阳光下越来越远，自己却继续穿着藏青色的制服在树荫里站了一会儿。</p><p>  实在想不出，明亮的少年会和死亡扯上关系。</p><h2 id="ACT-5"><a href="#ACT-5" class="headerlink" title="ACT-5"></a>ACT-5</h2><p>  疼。</p><p>  其实也并没有那么疼，比起鸦平时的躁动，这点外伤完全算不上什么。</p><p>  只是还很冷。</p><p>  花火蜷缩在厕所的一角，身上被泼了不知道从哪里弄的凉水。</p><p>  阴惨惨的日光灯，冰凉的地板。</p><p>  对面是清冷的镜子，隐约反射出几个不同的女孩的身影，背对着镜子看不清脸，只能大约看出发型与身高。</p><p>  瞳孔渐渐失焦，花火阖上了眼。尖锐的女声此时倒像是从很远处传来的，模模糊糊逐渐扭曲。</p><p>  『去死吧贱人。』</p><p>  『装成病怏怏的样子就能去勾引男人了吗？』</p><p>  『……』</p><p>  然而花火什么也没听进去，意识逐渐沉入深深的黑暗中。</p><p>  ……对不起，鸦，我……很没用。</p><h2 id="ACT-6"><a href="#ACT-6" class="headerlink" title="ACT-6"></a>ACT-6</h2><p>  花火醒来的时候，日光灯已经关了，厕所里漆黑一片，只有水龙头向下滴水的声音在空间里回荡。</p><p>  滴，叮咚，滴，叮咚。</p><p>  衣服竟然已经差不多干了，头发也是。花火从地上爬起来，摸索着打开了灯。</p><p>  稍微瞄了瞄镜中的自己。花火庆幸她们没有泼脏水。洗了把脸，匆匆把杂乱的头发扎起来，然后就关上灯走了出去，仿佛什么都没有发生一样。</p><p>  夜晚时分的走廊，因为少了喧闹的学生，变得有些不一样。花火喜欢这种被寂静笼罩的感觉。</p><p>  转过一个楼梯口，花火默默数着台阶，却在不远处见到了一束光。她先是愣了一下，不过很快恢复了常态——不知道哪个家伙也在教学楼里，并且还早有准备地拿了手电筒。</p><p>  又走了几步，耀眼的光不小心打在了她的身上。花火用手挡住光线努力循着光源看去，是铃城焰。</p><p>  『这么晚了还没有回家……是发生了什么吗？』铃城焰问。</p><p>  花火迟钝地眨眨眼，回顾了自己的处境。就在前不久，她因为铃城焰所以被几个同级生羞辱，不，应该是欺凌了一番。她在脑海里选定了很多词，却不知道如何描述这件似乎在一些人眼中太过理所当然的事情。</p><p>  ——事实，说出来不就好了。</p><p>  花火知道如果自己一五一十地将所有细节描述一遍之后，会有什么结果。</p><p>  ——那种事情我当然知道啊，可是……</p><p>  ——不想让焰担心？</p><p>  ……不可能。</p><p>  心脏深处突然袭来一阵剧痛。花火抿抿嘴，鸦的胡闹还真不是时候。</p><p>  『到底怎么了？』铃城焰向下走了几步，将她扫视了一番。『衣服都湿透了，就这样放着不管会感冒的啊。』</p><p>  『我没事。』从刚才的疼痛中缓过来的花火喘了口气。</p><p>  『运动服有吗？』铃城焰对花火的辩解并没有在意。</p><p>  『在柜子里有。』</p><p>  『那到门口拿了换上吧。』铃城焰晃了晃手电。</p><p>  『那么，铃城同学为什么呆到这么晚？』花火像是想起了什么似的补了一句。</p><p>  『没什么，只不过处理一下学生会白天没有完成的任务，弄完了就这么晚了。』走在前面的铃城焰漫不经心地回答道。</p><h2 id="ACT-7"><a href="#ACT-7" class="headerlink" title="ACT-7"></a>ACT-7</h2><p>  从校门口出来之后，街道上已经没有了行人，只有聒噪的蝉还在不知疲倦地嘶喊。花火穿着几乎从来没有用过的运动服，上面还残留着一点化学纤维的刺鼻味道。</p><p>  寂静。两个人都一言不发，只是一路向前走着，鸦也很安静。</p><p>  『晚饭时间到了啊……』花火叹息一声，没想到打破沉默的是自己。</p><h2 id="ACT-8"><a href="#ACT-8" class="headerlink" title="ACT-8"></a>ACT-8</h2><p>  来到这间家庭餐厅，既在花火的预料之中，又让她有些意外。邻座都是些以家庭为单位的顾客，在一起有说有笑地聚餐，突显出这边的格外冷清。</p><p>  并且铃城焰选了靠窗的位置，花火朝外面瞥了一眼。儿童公园的秋千就好像是几十年来都没有变过，只是滑梯已经掉了层漆。现在是全家团聚的晚餐时刻，也不会有孩子在这里玩。花火顺便瞥了眼周围的公寓楼，灯亮了一片，远远近近一片璀璨的万家灯火。</p><p>  『我曾经想成为超人那样的英雄。』花火浅啜一口服务生端上来的大麦茶。『现在呢，还是有点想。』</p><p>  『那个时候大家都能看得出来啊，不过现在也是吗？』铃城焰只是笑。</p><p>  点完餐，又是一阵沉默。</p><p>  『其实把你叫到这里来，是想要说……关于十年之前的事情。』铃城焰有些拘谨地坐直，开口说道。</p><p>  『哦。』花火有些意外。『都已经过了这么久了，可能连我自己都不太清楚了吧。』</p><p>  『其实我只是最近才知道的，有些偶然的发现。其实，起因是……』</p><p>  语气听上去有些纠结。</p><p>  『铃城家的人做的，不，策划的吧。』花火立刻做出了回答，为了让自己一口气说完之后不至于手足无措，又啜了一口热茶。</p><p>  这不难判断。</p><p>  虽然想着『大人们的事情和自己一点关系都没有』，风声却还是会走漏。</p><p>  况且，最近北川说的话也让她有些在意。</p><p>  ——如果铃城焰也被杀掉的话。</p><p>  既然出自北川之口，那么和对抗鸦的同族的那个组织一定脱不了干系，而它的势力范围远比花火想象得要大。从他们的立场上看，『被杀掉』也只能是让那些怪物们动手。</p><p>  好像是被称为『暗翼』的生物……只是听上去的话，八成会被当作都市传说的。</p><p>  如果继续考虑的话，当年将广末家灭门的是『暗翼』，考虑到广末家与铃城家的一些不太清楚的竞争关系……那么『暗翼』和铃城家应该有所往来。不过，现在可能会除掉铃城焰的也是『暗翼』。但是铃城家和『暗翼』的关系即使出现了裂缝，也没有到『全家杀尽』的严重地步，如果仅仅是用继承人来要挟的话……</p><p>  问题还是出在铃城焰本人身上，可是花火对他的什么事情一无所知。</p><p>  『你……知道？』铃城焰有些讶异，但却努力掩饰着自己惊愕的神情。</p><p>  『是啊。』花火点头。</p><p>  如果这样的话……铃城焰现在十分危险，虽然只是没有由来的担心，在任何时候，他都有可能以任何形式死掉。</p><p>  花火皱了皱眉，目光掠过周遭。</p><p>  不知道他有没有察觉到呢？</p><p>  ……等等，他好像有说过……『其实我只是最近才知道的，有些偶然的发现。』</p><p>  『那好吧，最后一件事情。』焰的身子略微向前倾斜，将双臂搭在桌上。</p><p>  『广末同学的心脏病……真的只是心脏病吗？』</p><p>  花火心底传来一阵剧痛，眩晕感随之袭来。</p><p>  不，鸦的事情也被发现了吗？</p><p>  一抬眼，铃城焰的脸上带着悲伤的神情。</p><h2 id="ACT-9"><a href="#ACT-9" class="headerlink" title="ACT-9"></a>ACT-9</h2><p>  古时的神话中有能够吸食人血的怪胎。</p><p>  卵寄生于人，在人体内孵化，然后冲破骨骼与血肉降生。</p><p>  听上去有些恶心，花火停住了手中的筷子。</p><p>  十分钟前铃城焰提出的问题 ，花火仍然不知道如何作答。</p><p>  鸦对自己来说很重要，才不是什么寄生的怪物。</p><p>  在孑然一人的十年中，如果没有鸦作为精神上的支撑，花火也许早就放弃生命了。</p><p>  我知道的啊。</p><p>  会放出杀人放火的恶魔，而且即使到死也不曾看过它降生之后的模样。</p><p>  那又能说明什么呢？</p><p>  就像复仇或防止复仇的方法一样，暗翼这样繁衍后代。</p><p>  但花火的记忆似乎出现了断层，只记得鲜血和漫天灰黑的羽毛。</p><p>  就像是眨眼的空档，两个无瑕的肥皂泡互相撞击，在一瞬迸发出急速旋转的流光，旋即消失，只留下些许尘埃。</p><h2 id="ACT-10"><a href="#ACT-10" class="headerlink" title="ACT-10"></a>ACT-10</h2><p>  好静。</p><p>  花火跟在铃城焰的身后，有些谨慎的观察着周围。</p><p>  实在是太静了。明明是夏日的八点多钟，这条并不狭窄的街道却死一般地寂静，不详的征兆。</p><p>  但是，如果只有自己的力量，是什么都做不到的，不过是杯水车薪，螳臂当车罢了。</p><p>  正在考虑自己这么做的意义的时候，前方却闪过一线白光。</p><p>  就像是……锋利的刀刃突露，在路灯下反射出的那种尖锐的光线一样。</p><p>  『铃城同学！』</p><p>  站在前面的焰只能看见背影。左肩似乎中了一刀，制服被血浸染，在昏暗的光线下就像是被染黑了一样。</p><p>  这就是暗翼吗，速度快得让人完全看不清何时会下手。花火暗想着，目光焦急地四处扫视，却毫无所获。</p><p>  和人类相比，他们的确占了压倒性的体能优势，怪不得北川隶属的组织费劲千方百计想要除掉他们。</p><p>  四下里却恢复了寂静。</p><p>  在哪里，到底在哪里……花火的大脑飞速转动着，不安地四处张望，而铃城焰的伤口却仍然汩汩流出鲜血。</p><p>  『嘁，竟然失手了。』暗夜中传来低沉的声音，下一秒，人影从正前方浮现了出来。</p><p>  一身夜色的装束，只有赤色的双眸在黑夜里格外醒目。</p><p>  花火第一次见到真正的暗翼，倒也没有多惊讶——明明是人类的模样，只是……</p><p>  那双隐隐收起的灰黑色翅膀。</p><p>  如血般的双目如宝珠般在暗处闪烁，下一次的白光很快袭来。</p><p>  『唔……』</p><p>  等到花火反应过来之后，自己已经站到了铃城焰的前面，交叉着的双臂竟然奇迹般地挡住了一刀。一开始是没有痛感的，但真实的血液的的确确是喷溅到了脖颈上。</p><p>  『啊干脆两个一起干掉好了，反正也不能留目击者。』传来持刀者轻松的口气，刚开始凝固的伤口再次受到刀锋的蹂躏。</p><p>  『你在干什么啊，逃跑不就好了！』此时铃城焰的声音变得模糊起来。</p><p>  为什么要这么做呢——不，花火没时间去想这些，快要被撕裂的痛感逐渐席卷全身。</p><p>  咬紧牙关。</p><p>  再这样下去的话，一定会死。</p><p>  接连的血流顺着发丝一点一滴地沿着发丝流了下来。</p><p>  ——可是，我想保护焰。</p><p>  ——因为我想成为救助他人的英雄。</p><p>  『鸦……』</p><p>  最后像是想起了什么似的，轻轻低语。</p><p>  『对不起，全部都是我的错。』</p><h2 id="ACT-11"><a href="#ACT-11" class="headerlink" title="ACT-11"></a>ACT-11</h2><p>  『妈妈？』</p><p>  远处传来呼唤。</p><p>  花火从意识的黑暗中清醒过来。</p><p>  这里是现实吗？</p><p>  不，好像记不太清了。</p><p>  自己竟然会围上当年在厨房里见到的那件橙色格子的围裙，坐在餐厅的桌子旁，有温暖的阳光洒进窗户，窗外是一片澄澈的蓝天。</p><p>  是儿时记忆中家的模样。</p><p>  『妈妈？』</p><p>  花火将注意力转向桌子的另一边，在那里有少年单手托腮，一脸认真地凝望着她。银白色的发丝在阳光的照耀下仿佛新雪，金色的眸子像是要与阳光融为一体，浅色的肌肤又将他衬得仿佛幽灵。</p><p>  『鸦……？』</p><p>  渐渐地，秒针的摆动声从某处传来，除此之外，一点声音都听不到。</p><p>  『所以呢……妈妈在小的时候有梦想吗？』</p><p>  『我……』花火略作迟疑。『我想成为英雄哦，像超人那样的。』</p><p>  秒针继续咔嗒咔嗒地转动，鸦的眼睛眯成两条缝，嘴角上扬。『诶……我也想成为英雄，像妈妈那样的。』</p><p>  『可是，我没有做到。』花火瞥了一眼窗外的草坪。</p><p>  『为什么呢？我觉得你已经足够努力了啊。』</p><p>  『因为……』花火又顿了顿。『因为总是用道貌岸然的借口来掩饰懦弱。』</p><p>  时间仍在流逝。</p><p>  『即使是你说的那样，我也仍然相信，妈妈是我的英雄。』</p><p>  花火愣住了。</p><p>  两人之间沉默了半分钟之久。秒针的声音、厨房里苹果派的香气、桌布上细致的蕾丝图样……一切都美好得仿佛真实。</p><p>  本来是想强忍住眼眶中的泪水的，但是它们最后还是和笑容一起蹦了出来。</p><p>  『妈妈，你哭了哦？』</p><p>  花火用手拭掉眼泪。『虽然没有成为理想中的英雄，但至少在最后还是做了一件自己认为正确的事，这就足够了。』</p><p>  指针指向了十二点。</p><p>  时间仿佛被冻结，远处教堂的钟声哗啦哗啦地响了起来，淹没了一切。</p><p>  鸦从椅子上站了起来。『妈妈，我该走了。』</p><p>  花火没有问鸦要去那里，一如她从未怀疑过他们存在于这里一样。</p><p>  『不过……能见到你，我很高兴。』花火目送着鸦转过身去，渐行渐远，身后展开夜色的翅膀，却在光下熠熠生辉。</p><p>   正午的阳光太过温暖，像是要将花火包裹起来，融化掉。</p><p>  有些困了。</p><p>  那么，在这美好的光下，沉沉地做一个梦吧。</p><h1 id="KARASU-2nd-Story-铃城焰"><a href="#KARASU-2nd-Story-铃城焰" class="headerlink" title="KARASU 2nd Story 铃城焰"></a>KARASU 2nd Story 铃城焰</h1><blockquote><p>故事分为四个不同视角的叙述，本篇为2nd Story。</p></blockquote><h2 id="ACT-1-1"><a href="#ACT-1-1" class="headerlink" title="ACT-1"></a>ACT-1</h2><p>  『喂，不要哭啦！』</p><p>  被泪水模糊的视野里出现了一支波板糖。</p><p>  『咦？』</p><p>  焰抬起头，夕暮中与自己年纪相仿的女孩子，在橘色的夕照里露出元气满满的笑容。『送你了哦。』</p><p>  『这么晚了还不回家，父母会担心的呢。』那个女孩子坐到他对面的秋千上，不安分地晃着两条腿。</p><p>  『我……不想回家。』这样回答的。</p><p>  凶巴巴的父亲，而且……没有母亲。</p><p>  『嗯……是这样啊，那我陪着你等家人找过来好咯。』说罢拿出一块牛奶糖丢到嘴里。</p><p>  『……谢谢。』</p><p>  『是义务。我是以这个公园为据点，活跃在城市里惩恶扬善的hero啦。』</p><p>  『听上去很厉害诶……你不回家吗？』</p><p>  『hero什么的，当然是四海为家咯。』女孩子扬起了手臂，又随即放下。『不，说笑的，今晚父母都忙，自己一个人在家里好寂寞的说，只好溜出来执行任务咯，哈哈。』</p><h2 id="ACT-2-1"><a href="#ACT-2-1" class="headerlink" title="ACT-2"></a>ACT-2</h2><p>  现在想来，那就是与广末花火的第一次相遇。</p><p>  焰一动不动地躺在床上，呆呆地凝望输液管中的气泡。单人病房，安静，日光灯白得恐怖。</p><p>  然后，她已经死了。</p><p>  他摇摇头，试图将黑暗与血液一类的恐怖意象从脑海中驱散。</p><p>  开始相信意外对一个人的改变，是在高中入学的时候。从花名册上不经意瞥见『广末花火』几个字，却只在最后一排找到了沉默得让人毛骨悚然的少女。</p><p>  就像是彩色背景上贴了一张黑白照片，与这班级格格不入。</p><p>  如果没有发生那种事情，她也许会从活泼善良的女孩蜕变为活泼善良的少女，在父母与朋友的呵护下为了学业、恋爱或其他芝麻小事而烦恼不已，仅此而已。</p><p>  事实却是，十七岁的广末花火，在满世界中举目无亲，然后悄然离开了。</p><p>  但是……</p><p>  『想要成为英雄，这一点并没有变啊……』</p><p>  焰闭上眼，轻声呢喃道。</p><h2 id="ACT-3-1"><a href="#ACT-3-1" class="headerlink" title="ACT-3"></a>ACT-3</h2><p>  不知过了多久，铃城焰再度睁开双眼。</p><p>  醒来之后，无人探望。护士送三餐，打点滴，换药，也是一言不发，毫无关切的意思。</p><p>  『总要知道自己呆了多久，外面都发生了什么吧。』于是焰打开了电视。</p><p>  平时是不会看电视的。这个世上的某处随时都会发生令人愤怒或不安或悲伤的事。打开电视，只会让他知晓，有人已经死去，或正有人走向死亡。</p><p>  ——不，也许只是自己太懦弱罢了。</p><p>  果然。焰看到新闻报导之后眯起眼睛。在这个城市里，有做了坏事的什么商人，被人发现惨死于家中。播音员似乎已经习惯了突如其来的死亡，只是简单带过。『据警方推断是仇杀。』</p><p>  下一个死的又是某个官员。焰疑惑地皱皱眉。又是仇杀，这看上去就像是连环杀人案。</p><p>  随后是无聊的电视剧。屏幕上浓妆的女子哭得撕心裂肺。焰只是躺在床上一动不动，对于刚刚过去的情节却完全不记得了。</p><p>  中途有个娱乐性质的节目，先是说了什么明星的最近似真似假的恋情，突然却话锋一转，谈到最近人气日益升高的都市传说了。</p><p>  当几张模糊不清的照片出现在屏幕上时，焰抓住了手中的遥控器。那死尸似乎正是那天晚上出现的『暗翼』，不过并没有受伤了的自己的照片。</p><p>  铃城家估计也知道了这件事情，所以有好好封锁消息吧。</p><p>  现在只剩下一个问题。</p><p>  广末花火的尸体去了哪里。</p><p>  焰按下了遥控器的红色开关。</p><h2 id="ACT-4-1"><a href="#ACT-4-1" class="headerlink" title="ACT-4"></a>ACT-4</h2><p>  那天晚上发生的事情有点多，如果不是那几张照片唤醒了他的记忆，他是无法完整地理清所有事件的次序的。</p><p>  起源是黄昏时分，出校门到附近的咖啡馆买简餐的时候发现自己被跟踪了。家里的事情向来就不怎么在意，所以也无法猜测跟踪者的目的。</p><p>  再说了，这么多人，自己又是顾客，应该不会有问题吧。</p><p>  但是焰没有想到，对方直接坐到了自己座位对面的沙发上。</p><p>  『哎呀，果然很像呢。』开场白让自己吓了一跳。『可以让我在这里坐着看一会儿吗？』</p><p>  『请便……』焰嘴上说着，心里却十分纠结。对面的男人好像到了能被称作大叔的年纪，言谈举止轻浮得有点像不知哪个店里跑出来的牛郎，却偏偏披了件白大褂。『请问，我长得很像您认识的某个人吗？』</p><p>  『算是吧。』男人点点头。</p><p>  焰只好默不作声地被注视着吃下了晚餐。</p><p>  『这个是我送给你的，那么先告辞了。』正当焰准备买单时，那人却突然留下了一个信封便匆匆离开了。</p><p>  『奇怪的人。』焰摇摇头，拎起信封，里面被沉甸甸的纸张塞满了。</p><p>  看了一眼时钟，社团活动时间都差不多要结束了，不过自己很少参加自己所在的部社活动，主要把时间用在了学生会上。</p><p>  今天也有许多乱七八糟的事情要处理。铃城焰将信封胡乱塞进包里，不巧却掉落了一张便笺。</p><p>  『咦，这是什么？』</p><p>  焰将纸捡起来，潦草的字迹显示出一个人名。</p><p>  北川有栖。</p><h2 id="ACT-5-1"><a href="#ACT-5-1" class="headerlink" title="ACT-5"></a>ACT-5</h2><p>  处理完事务又把信封里有些凌乱的内容看完之后，焰将信封扔进了抽屉深处。虽然对他而言并没有什么门禁之类的规定，不过已经不早了，还是赶紧回去比较好。 </p><p>  只是，所有的文件里都没有出现北川有栖这个名字，也许只是一不小心混进去的吧。</p><p>  随后在楼梯口遇见了广末花火。就像是被什么人给欺负了一样，校服显然被泼了水，发型也有点凌乱。</p><p>  但还是那句倔强的话。</p><p>  『我没事。』</p><p>  花火其实知晓十年前的真相。焰是唯一一个毫不知情的人。</p><p>  直至那个医生打扮的人出现。</p><p>  奈何真相来得太晚，黑夜的路上，等待他的是赤目的暗翼。</p><p>  花火替他挡了一刀。这是事实。</p><p>  但接下来发生的事情让他不再相信自己的眼睛。</p><p>  从花火的尸体当中，生出了一个散发着苍银光芒的少年，展开的却是与暗翼一样的灰黑色翅膀。</p><p>  想要说话，却失去了声音。</p><p>  那少年果断地处理掉落另外一个暗翼，动作娴熟得让人毛骨悚然。</p><p>  月影之下的少年转过身来，纯白的衣衫却丝毫没有沾血。焰注视着眼前的景象。两具尸体，天使一样的恶魔。</p><p>  从来没有离死亡这样近过。</p><p>  虽然也不是没有考虑过这样的可能性，但是在真正的恐怖面前，他竟然比他想得还要无能为力。</p><p>  那少年看着他，他也只能一动不动地看着那少年。浅金色的双瞳，不知为何却透露出了几分天真的气息。</p><p>  然而，对峙不过几秒钟。</p><p>  很快，少年将广末花火的尸体抱起，不久消失在幽黑的街道尽头。</p><p>  而焰只是看着，甚至开始那是自己因为出血过多而产生的幻象。</p><h2 id="ACT-6-1"><a href="#ACT-6-1" class="headerlink" title="ACT-6"></a>ACT-6</h2><p>  护士送来了晚餐。食材虽然高级，却散发出医院一样冷冰冰的感觉。焰拿起叉子，将青豆挑到盘边。走廊上的灯是关着的，整层楼寂静得仿佛这间病房只是一座孤岛。</p><p>  房间里没有钟，而他更不想打开电视来确认时间。</p><p>  从房间里向窗户外面望去，天色已经变得醇黑，密密麻麻的、从远处高楼上传来的灯光倒是比星辰还闪亮。</p><p>  晚饭时间啊。会有多少家庭团团圆圆地一同就餐呢。</p><p>  在这密密麻麻的灯光下。</p><p>  在自己的记忆中，晚餐同样也是密密麻麻的灯光——头顶上方华丽的水晶吊灯，铺着白布的长得可怕的餐桌，和一些灯下玲珑剔透的水晶器皿。</p><p>  刀叉碰撞骨瓷的轻微的叮当声。</p><p>  房间里吹进来了夜风，焰将自己从追忆中拉了回来。</p><p>  窗户不知何时被打开，而扶住窗框坐在床边的，是一身白衣的少年。</p><p>  啊。焰微微张开了嘴，声带却没有动。</p><p>  那不是幻觉。</p><p>  风撩起白色的窗帘，以及那少年的发丝。二人如此僵持着。</p><p>  『花火呢？』焰打破这寂静。</p><p>  那少年不说话。他低下头，随即又轻轻地摇头。</p><p>  『她……不在了，是吗。』铃城焰知道这是废话。</p><p>  那少年又点点头，伸出手指画了一个长方形。</p><p>  『她已经下葬了？』</p><p>  少年有些疑惑地歪了歪头，像是不理解『下葬』本身的含义，然后又似懂非懂地点了点头。</p><p>  『……是吗，那就好。』焰显露出疲惫却释然的表情。『请允许我问一个问题，那些人……也都是你杀掉的吗？』</p><p>  焰没有明说，少年也并没有做出任何回答。屋子里忽地灌进了猛烈的寒风，餐盘也随之发出咔咔的声响。焰拨了拨被风吹乱的前发，却只看见少年松开紧握窗框的手，逆着风向后仰去，展开夜色的宽大翅膀。</p><h2 id="ACT-7-1"><a href="#ACT-7-1" class="headerlink" title="ACT-7"></a>ACT-7</h2><p>  半夜，暴雨说下就下，铃城焰被雨点敲打窗台的密集鼓点以及雷声所惊醒，才发现自己忘记了关窗。</p><p>  走廊里仍是一片漆黑，焰不明白为何整层楼都没有护士。他赤着脚下了床，才发现地上出奇地凉，可能是雨水落进了窗户，还有些发滑。</p><p>  到了窗边，便不免要向下望去。这时灯已经熄了大半，几点光线就像是狂风暴雨的海洋上浮沉的船只，在雨点间时隐时现。雷电交加，天边偶尔会出现几丝亮如白昼的闪电，然后消失。</p><p>  不知呆立了多久，焰才想起来关窗。伴随着窗框相撞的闷响，是立即出现在玻璃上的雨痕，世界很快模糊成一片。</p><p>  不论如何努力，都无法改变雨天，所以先睡吧，也许醒来就是晴天了。铃城焰这么想着，乖乖地掖好了被子。</p><h2 id="ACT-8-1"><a href="#ACT-8-1" class="headerlink" title="ACT-8"></a>ACT-8</h2><p>  天真的放晴了。</p><p>  早晨醒来后望向窗外，才发现晴空一片，整个城市仿佛被彻底清洗过一遍。</p><p>  接下来是早餐时间。没人告诉他要在这里住多久或者已经住了多久，他也并没有多想。</p><p>  毕竟，无聊也是一种幸福嘛。</p><p>  以前真的是太忙了。</p><p>  忙于……？</p><p>  铃城焰愣了一下——很忙，可是他到底在忙些什么呢？</p><p>  从某种程度上来说，本来对于铃城家背后的那些交易、那些黑暗面，他作为家中成员本来应该悉数知晓——不，即使做不到全部都了解，也应该多多少少了能够寻到冰山一角，然而，在那个奇怪的医生一样的人交给他那些资料之前，他一直在内心否认了所有可能性，对这些事情一无所知。</p><p>  直到走廊的尽头突然出现匆忙的脚步声，铃城焰才意识到也许又要回到过去了。</p><p>  父母还是没露面，铃城焰见到代理秘书竟然来了，倒也没有多意外。</p><p>  只是这次秘书的表情格外地凝重。</p><p>  寒暄与客套的话都是左耳进右耳出，真实的话语与心不在焉的幻象相交织。</p><p>  『你要知道，有些话是可以随便说的，有些话却不可以。』父亲少有的几句教诲，是坐在那张红木办公桌旁边看什么东西的时候说的。</p><p>  『是。』那时的铃城焰站在桌子前，头微微低下，也许还没有桌子高。</p><p>  『比如母亲和你说的话，就要学会隐藏。』</p><p>  啊，想起来了，她说的是『我不是你的妈妈，所以我也不会像母亲一样对待你，即便如此，你也该知道应该怎么做。』</p><p>  大人总是喜欢讲一些特别空泛的定义，比如『有些事』，比如『怎么做』。</p><p>  『可是我的妈妈呢？』铃城焰有些委屈地望向父亲那边，昏暗的台灯在文件上打出一层父亲的黑影。</p><p>  『已经不在这个世界上了，也就是，死掉了。』父亲还是一如既往的口气，印象中他并没有笑过。</p><p>  『那她是一个什么样的人？为什么不在这里？』铃城焰追问道。</p><p>  『关于她，你不需要知道什么，有些话是不该说的，知道现在应该做什么吗？』</p><p>  『不知道！』铃城焰赌气地喊道。</p><p>  『服从命令。剩下的全部不需要。』</p><p>  在铃城焰的印象中，谈话到此结束。后来他真的再也没有问过关于生母的一点信息，只是乖乖听话。一开始好像还会躲在被窝里独自哭泣，后来也渐渐地麻木了。</p><p>  所以，见到广末花火之后，才真切地体会到自己的懦弱。</p><p>  ——不敢叛逆，或者说是，连叛逆的念头都没有。</p><p>  但是和广末花火一起勇敢地尝试了许多自己不敢想象的冒险之后没多久，广末一家就从自己的世界中消失了。</p><p>  铃城焰再次成为了默默服从，什么都不会去想的那个铃城焰。</p><p>  『很抱歉，就在昨夜，老爷，夫人，被暗翼杀害了。』律师的声音将他拉回了现实。『所以，现在少爷的处境也十分危险，我们会加强防卫。』</p><p>  被杀害了。</p><p>  死掉了。</p><p>  不在这个世界上了。</p><p>  就像自己的亲生母亲一样。</p><p>  不知为听见养父母的死讯，却没有任何悲伤的情绪。他只是想笑，但又笑不出来。下达命令的人都不在了，自由的权利突然被丢到了他的手中，却又因为从未获得自由而惘然。就像是刚从脚镣中解放出来的囚犯，走起路来左右摇晃。</p><p>  ……你要知道，有些话是可以随便说的，有些话却不可以。</p><p>  焰故作冷静地问：『那么，既然危险成了这个样子，可是这几天病房附近都没有任何护卫吧？』</p><p>  『这……这是老爷的指示。』代理秘书回答道。</p><p>  焰摇摇头，继续问道。</p><p>  『那么有人看到凶手了吗？』</p><p>  『据称，是少见的白发，搜寻起来应该会很容易。』</p><p>  白发……那个少年。</p><p>  他这是为了广末花火而复仇吗？</p><p>  可是，就在同一天晚上，他造访了毫无警卫的医院，却没有对焰下手。</p><p>  除此之外，广末花火的尸体会去哪里呢？如果有一天那个少年真的被缉拿归案，又会怎样呢？</p><p>  强烈的愿望涌上心头——作为补偿，作为对于广末花火的补偿，他必须陷入这深不见底的漩涡中。</p><p>  四周一直是黑的，只是自己不愿睁开双眼罢了。</p><p>  ……到最后，自己还是再一次被广末花火拯救了啊。</p><p>  所以，他要独自一人面对这纠结不清的现实，勇敢地。</p><p>  在窗外的钢铁森林间，似乎有个灰白的影子，悄无声息地穿梭而过。</p><h1 id="KARASU-3rd-Story-北川慎之"><a href="#KARASU-3rd-Story-北川慎之" class="headerlink" title="KARASU 3rd Story 北川慎之"></a>KARASU 3rd Story 北川慎之</h1><h2 id="ACT-1-2"><a href="#ACT-1-2" class="headerlink" title="ACT-1"></a>ACT-1</h2><p>  『……那么，如果同意手术的话，请在这里签上字。』慎之将一支笔与一张已经填好了的表格推到桌子的另一边。</p><p>  对面的女孩子年龄不大，也就刚上国中的样子，很好说服。她抓起笔，有些郑重地签上了名字。</p><p>  『谢谢。』慎之露出标准范式的笑容。『你要知道不这么做的后果会很严重。』</p><p>  刚加入到这个组织的时候，部长因为『脸长得像某个明星』这个无聊的理由让他进行劝导方面的工作，所以他也永远失去了在第一战线与『暗翼』战斗的机会。</p><p>  啊呀呀，一开始可是梦想着进行复仇呢。慎之苦笑着摇头。</p><h2 id="ACT-2-2"><a href="#ACT-2-2" class="headerlink" title="ACT-2"></a>ACT-2</h2><p>  在很小很小的时候，似乎是有一段很幸福的时光的，不过慎之记不太清了。</p><p>  大约五六岁的时候，慎之和妹妹就为了抵债而被送到了歌舞町。战争虽然不在本土进行，却也把经济搅得一塌糊涂，连服务业都很难进行下去。</p><p>  那时候的慎之与七八个年龄相仿的男孩儿白天干各种杂活，晚上就回到一间只容得下床铺的地下室。营业时间才刚刚开始，从上方一排通气的窗户里向外看，隐隐地能望见投映在地上的灯光，以及站街的女人的脚。基本上是高跟鞋，种类纷繁，他说不上来。</p><p>  还有就是，很少见到自己的妹妹，北川有栖了。</p><h2 id="ACT-3-2"><a href="#ACT-3-2" class="headerlink" title="ACT-3"></a>ACT-3</h2><p>  慎之二十岁的时候，突然被要求到前台工作，这时他才知道妹妹的名字变成了『爱丽丝』，不过其实读音也没多大变化，『爱丽丝』和『有栖』相比只是洋气了些。</p><p>  战后十年，经济恢复得相当快，有钱人越来越多，前台忙不过来也是必然。</p><p>  不知道算是可悲还是可喜，这时慎之父母的债务差不多还清，他终于自由了。不过父母没有找过他，他也未曾找回去——一次也没有。在附近草草租了间公寓，慎之就开始了独居的生活。</p><p>  只是，与有栖的隔阂似乎与日俱增，她有着与他不全然相同的人生，而北川只能远远看着，无法改变什么。</p><p>  所以，连她怀了孩子的事情，也只是听了一个消息灵通的伙计说的。</p><p>  『真是顽固呢，说什么都不肯打掉。』那家伙一边记着酒水帐一边说道。『不过也挺聪明的，能骗出不少钱吧。』</p><p>  慎之倚在墙边听着他说这番话，不知道该怎么接话茬了。</p><p>  『对了，据说店里的女人都活不了太久。』见他良久无言，那伙计凑过来低声说道。</p><p>  『嗯，我听说过那种传言。』慎之点点头。『是因为暗翼吧。』</p><h2 id="ACT-4-2"><a href="#ACT-4-2" class="headerlink" title="ACT-4"></a>ACT-4</h2><p>  临产那一天，慎之还是被叫去了，毕竟父亲那方不可能会来人，只好让他去压阵。地下诊所的外廊又黑又深，在遥远的暗里有烟头发出的橘色光亮，时隐时现。</p><p>  就在慎之猜想着『会是男还是女』这个问题的时候，门里却传来凄厉的尖叫声。</p><p>  ——是有栖的声音。</p><p>  正当他迟疑着的时候，有什么东西从门里飞了出来。阴惨惨的白色灯光从破洞里照了出来。慎之放佛失去了视觉似的反射性地闭上了眼睛，但又立即站起身来，推开门，看见那病床边惊魂未定的护士，以及必死无疑的妹妹。</p><p>  这种荒唐的故事，明明已经在脑海中构思了一千次、一万次了，为什么在真正降临的时候，自己却束手无策？</p><p>  啊，这是为什么呢，命运。</p><p>  『孩子还活着吧？』慎之向病床边上看去，忽略那不想再见到的妹妹的尸体。</p><p>  『嗯……是个男孩。』护士应该也是第一次遇到这种骇人的状况，所以紧张得吞吞吐吐。</p><p>  『孩子交给我。』冷冷的女声从身后传来。慎之转过头去，打扮得体、面容清雅的一位贵妇似的人物，不知何时已经站在了门外。</p><p>  慎之将身子侧了侧。『您是……？』</p><p>  『母亲。这孩子的母亲。』女人示意下人将孩子带走，然后用看虫子一样的眼神瞥了眼有栖的尸体。『就是这个小姑娘？真是恶心。』</p><p>  慎之的心底升起一团怒火，却一动未动。</p><p>  我果然还是太懦弱了啊。</p><p>  就应该直接给她一拳的。</p><h2 id="ACT-5-2"><a href="#ACT-5-2" class="headerlink" title="ACT-5"></a>ACT-5</h2><p>  慎之回到办公室的时候，感觉气氛有些异样，大家都低着头各忙各的，没人和他打招呼。</p><p>  『北川。』身后有人叫住他。是部长。</p><p>  『是？』慎之转过身来，连不靠谱的部长都是这样？</p><p>  『因为广末花火那件事，上面连带着死了不少了。』</p><p>  『就是那只白发的？』</p><p>  慎之倏地想起广末花火淡漠的眼睛里少许的热忱，以及『鸦是我的孩子』那番话。他去的时候现场已经被清理干净了，好像铃城焰也被牵扯进去了，当然，他没有调查这些事的权限。</p><p>  『我也是无能为力了，上头也施加了压力，所以……』</p><p>  『我被革职了？』慎之推测着说道。</p><p>  他看到部长头上花白的头发和秃顶的部分，几十年不变的米色外套。</p><p>  『尝试着放下过去，做个普通人吧。』</p><h2 id="ACT-6-2"><a href="#ACT-6-2" class="headerlink" title="ACT-6"></a>ACT-6</h2><p>  虽说已是夏末，但黄昏时的燥热还是挥之不去。暖色的天空，边角渗出血腥的红色。</p><p>  就像是太阳的血。</p><p>  慎之从一辆搬家公司的轻型卡车边穿过。巷子很静，也很空旷，周围是连片的高层公寓楼，刷成青灰色，到哪里都一个样，很容易迷失方向。</p><p>  『哎呀呀，这还真是个不可多得的好地方，没想到这城市的中心也藏了一片净土呢。』慎之一边自言自语，一边远望巷子的尽头，一片开阔的平底，而那只白色的暗翼就站在那里，一言不发地看着他。</p><p>  『哦，你就是那个叫做鸦的孩子啊。』慎之换上职业微笑，慢慢走近。</p><p>  鸦仍然一言不发。</p><p>  『我已经被组织给开了，并没有要加害你的意思。』慎之在他的面前站定。『广末花火的死我也得负一部分责，所以我可是和你在一条战线上的哦？』</p><p>  听到花火的名字，鸦似乎有点，不，应该说是十分不悦，本来木然的表情染上了点怒色。</p><p>  『我跟你说你还真是傻啊，同时和人类与同族为敌，最后没有谁能够帮得了你，即使是小孩子玩游戏也不会如此不顾全局吧？』慎之不理会他，继续自顾自地说着。</p><p>  鸦抿了抿嘴，保持沉默。</p><p>  『所以，广末花火的尸体你藏到了哪里？』慎之微笑着质问。既然已经什么都不在意了，那么满足自己的好奇心就是唯一的目的了。</p><p>  啊，铃城焰也应该看到那些文件里吧，不知道接下来铃城家会变成什么样子呢。</p><p>  鸦转过头，向平地走去，夕阳的余辉洒在合拢的翅膀上，黯淡无光。</p><h2 id="ACT-7-2"><a href="#ACT-7-2" class="headerlink" title="ACT-7"></a>ACT-7</h2><p>  阶梯，鸟居，旧式建筑。</p><p>  是座神社。在这高楼林立间。</p><p>  慎之跟在鸦的身后走上台阶，穿过鸟居来到纳奉箱前，不过因为这里似乎没什么人来，所以箱子应该也是空的。四下里寂静得可怕，不远处的车水马龙似乎完全听不到。</p><p>  就像是被下了什么结界一样。</p><p>  供奉的真神是鸦天狗。哦，这么说来鸦天狗的形象从某种程度上来说像极了『暗翼』，不过漫长的年岁中连鸦天狗这个说法本身都经过了许多演化，已经没有人能够道出其原本面目了。</p><p>  慎之随着鸦绕过壁龛，发现这之后还有一间屋子。鸦推开门，在门口站定，并没有要进去的意思。</p><p>  好凉。慎之在这大夏天暗骂一句。</p><p>  屋子本身很陈旧，也没有修补过的痕迹，但中央放置的一大块冰正阴阴地散出冷气，让人不愿接近。</p><p>  正是广末花火。</p><p>  『你做的？』慎之转过身去问鸦。</p><p>  鸦点了点头。</p><p>  慎之凑近了些去看那块水晶棺似的冰。广末花火在里面睡得很安详，黑发好像随时都有可能飘起来。身上似乎有许多大大小小的伤痕，血液却早已干涸，留下平缓的印记。慎之还记得有栖的尸体，不似这般平和，让人无法与可怕或作呕的情节联系起来。</p><p>  这个小姑娘……慎之心里想着。和北川有栖相比，她到底是幸运还是不幸呢？</p><p>  慎之在那里立了一会儿，转过脸才发现鸦已经不知何时离开了。于是他只好踩着嘎嘎作响的地板，然后关上了老旧的门。</p><h2 id="ACT-8-2"><a href="#ACT-8-2" class="headerlink" title="ACT-8"></a>ACT-8</h2><p>  慎之从便利店买了饭团和大麦茶之后，摸着黑顺原路返回。神社里的灯火在高楼间显现，就像藏在林间的糖果屋——虽然是有些糟糕的比喻。</p><p>  『唉，不是说好了要做普通人么。』慎之一边嘟囔着一边走上长长的台阶。小时候就被卖了抵钱、在歌舞町工作、妹妹离奇的死、抵抗都市传说一样的生物的组织……这凄惨的经历可以写一篇像样的小说了，他想。</p><p>  『组织里都说了这么多年来，暗翼还和歌舞町有关联，这小子也太傻了，就他一个人谁也解决不了……』慎之继续叨叨着。『我竟然也会蠢到去找他，真是活腻了。』</p><p>  没错，活腻了。慎之骂骂咧咧地坐在最后一级台阶上，打开一瓶大麦茶，猛灌一口。『我也竟然会蠢到在秋天差不多到了的时候喝冷饮。』</p><p>  『……』慎之独自对着前方的一片灯火发了会儿呆。现在就走还来得及。</p><p>  从夜幕降临开始，鸦就飞到了屋顶上，双手抱在脑后一动不动地保持着那个姿势躺着。这家伙和他所知道的任何一种『暗翼』都截然不同。从外貌来看，白发的品种他没见过，更没听说过，而且他自始至终都没有开口说过一句话，最让人不解的是他身上明显缺了点『暗翼』所该有的残暴气息，文静得就像是他幼稚园时期认识的一个小组长。</p><p>  慎之嚼着饭团，有回头看了一眼，鸦仍然保持着那个姿势。走之前到个别？他想了想，站起身来，三口两口地把饭团吞下去，塑料膜丢进袋里，到神社去找梯子。幸亏他没飞到鸟居上。</p><p>  在里间转悠的时候，慎之才发现这神社空地方还不少。梯子也的确有，他打眼看了下高度，就把它拖了出来。</p><p>  木质的梯子踩上去十分令人害怕，有好几次慎之都以为自己会掉下去，但事实上并没有，他成功地到达了屋顶。连瓦片都是旧式的，更没想到的是有些地方用的还是十分讲究的材料，看来这神社的香火也繁盛过。</p><p>  鸦也没搭理他，不出意料。</p><p>  『你在做什么？』他先是很礼貌地问，当然也没有回答。</p><p>  鸦的眼瞳里只映出了夏夜的星空。</p><p>  慎之觉得再这样下去也不会问出什么结果。『我要走了。』</p><p>  鸦偏过脸来，有些不解地，就像是听不懂。</p><p>  『啧。』慎之有那么一瞬间以为自己旁边是个神经病。『也对，你不过是个还没长大的孩子呀。』</p><p>  一阵夜风吹过。远处的高楼闪着霓虹灯光，而这边群星正在闪耀。</p><p>  『你听人说过不，人死了都会化作一颗星星。』慎之自言自语道。用这种话骗女生还是挺管用的，但他的父母都活得好好的，他也不认为有栖已经化成了一颗星星正在盯着他看。</p><p>  这次鸦倒是点点头，将整个身体躺成『大』字，看着那星空，没眨眼。</p><p>  就在这里瞧着星空，一点一点消磨时间，似乎也不错。</p><p>  但是。</p><p>  『算啦算啦，哪儿用得着什么理性思考，你愿意呆在这儿就呆在这儿吧，我再下去买点啤酒。』慎之站起来，拍拍身上的灰尘。</p><h2 id="ACT-9-1"><a href="#ACT-9-1" class="headerlink" title="ACT-9"></a>ACT-9</h2><p>  慎之再次从便利店回来的时候，夜更深了，城市中的光芒也消减了一大半，越发凸显出星光的纯粹。屋顶上有片黑影，看样子是那家伙就这么打算过夜了。</p><p>  他走进神社，却迎面在细微的光线里撞到了一个人。他反射性地摸了一下兜里悄悄从组织里拿出来的枪。</p><p>  『是客人吧？那孩子的。』有些不急不徐，苍老却精神的声音。</p><p>  说罢，有煤油灯被点亮，散发出摇曳的昏黄光线。慎之盯着那灯看，少说也是战前的产物了。举灯的是个慈眉善目的老头，好像是神官一样的人物。</p><p>  『真是失礼了，我还以为这神社……已经被遗弃了。』慎之低头道歉。</p><p>  『这倒是说不准呢，信仰也好，神明也罢，被人丢弃的已经不在少数了吧。』神官摇摇头。『黄绿色的神明在这个时代倒是比什么都有吸引力，这里也渐渐地没落下去了。』</p><p>  『您……打算在这里呆多久？』</p><p>  『谁知道呢。』神官拎着煤油灯走进另外一间小屋，慎之留在门口。</p><p>  『那个孩子做的事您知道吗？』</p><p>  『多少知道一点吧。』</p><p>  『那您……为什么还要收留他呢，难道不怕受到牵连吗？』</p><p>  神官打开了里间的灯，是亮度和煤油灯差不了多少的电灯。他转过头来，仿佛遥望远方似的笑着。『那孩子是暂用了一个肉体的真神，谁知道什么时候就会被召回去了吧。』</p><p>  慎之站在门外琢磨了一会儿这句话，仍然不解其意，又瞥了一眼广末花火所在的漆黑无声的屋子，就打开了啤酒。</p><p>×黄绿色的神明指日本纸钞。</p><h2 id="ACT-10-1"><a href="#ACT-10-1" class="headerlink" title="ACT-10"></a>ACT-10</h2><p>  最后慎之还是留了下来。</p><p>  不知怎的，慎之也觉得这很有可能是最后为数不多的日子了，所以也随着那个老人过起了过于悠闲的生活。</p><p>  时间仿佛凝结了一般，慎之已经不记得自己来的日期了，只是日复一日地在夕暮时分抬起头，看秋雁从头顶成群经过。</p><p>  至于会来杀自己、或者说是杀那个孩子的会是组织还是『暗翼』，什么时候会来这种无聊的问题，在此之前早已反反复复地绞尽脑汁在梦里编排过了，所以他现在只把注意力集中在与老人对战的将棋上。</p><p>  『唔……我果然还是不怎么擅长这种事情啊。』慎之不由得抱怨道。</p><p>  『你已经放弃得足够多了吧，对于这个年纪的人来说，是一件十分罕见的事情了。』老人的注意力似乎并不在棋局上，倒是动不动就把视线挪到旁边的落叶堆上，十分轻松的样子。『我见过的大部分中年人，气血还旺，虽然精神不及年轻人，但还是想要拥有这个光怪陆离的世界。』</p><p>  『放弃啊……』北川挠挠头。『的确，周围的人从小都这么说，也许我就是这种性格也说不定。』</p><p>  『嘛，没有斗志也不是什么好事，就像现在，和我一起慢吞吞地下着棋，不就是什么都得不到吗？』</p><p>  慎之低头，才发现棋局已定，只好站起身来。『那我就去买点晚饭好了。您想吃什么？』</p><p>  『不劳费心了。这边还有些干粮，自己做的饭才能吃得心安理得。』</p><p>  『好，好……』慎之走出门去，直面见到朱红色的鸟居，以及染成橘红色的天。</p><p>  不过，再向下看去，台阶下有深红色的印记。</p><p>  ……血？</p><p>  慎之向下走了走，看见了倚在最后一级上的鸦。眸子无精打采地眯着，头发上能隐约看到血珠。</p><p>  相当严重的新伤。</p><p>  慎之所构思过的那些梦境似乎成为了现实。</p><p>  他张皇遥望四周，发现那红日之中，有一片密集的黑点。</p><p>  越来越近。</p><h2 id="ACT-11-1"><a href="#ACT-11-1" class="headerlink" title="ACT-11"></a>ACT-11</h2><p>  关于『最后的时刻』已经来到这个现实，慎之也没有像在那些梦境一样无助地四处躲藏，而是扶着鸦匆匆爬上了台阶。</p><p>  不过，不仅是天的那边，远处的巷子也有人正在接近。慎之吸了一口气。这可能是比死亡还糟糕的事情。</p><p>  太阳渐渐沉下去了，巷子里的人也接近了鸟居，步调一致地无声地爬着台阶。</p><p>  『部长。』慎之的声音不自觉地颤抖。</p><p>  部长似乎根本没想到他会出现在这里，脸上写满了惊愕。他示意其他人放下武器。『你怎么在这里？』</p><p>  『那孩子是无辜的，他只是遵从广末花火的意志罢了。』慎之不知道自己此时为何要为鸦做辩护。『求你们放过他。』</p><p>  『你……』部长想说什么，却又把话吞进了肚子里。『请你以一个普通人的身份立即离开，我不会追究。』</p><p>  『我会一直守在这里。』慎之将手伸进口袋里。起秋风了。</p><p>  『我不想说第二遍。』部长摇摇头，神色疲惫。『还是说，你和『暗翼』一直有勾结？』</p><p>  慎之抬起头来看了看，另一边的『暗翼』也快接近了。『部长，完成这个任务之后您是不是就隐退了？』</p><p>  『回答我的问题！』部长提高音量，大声质问。</p><p>  『我只是想让那孩子做正确的事而已。』那个瞬间，面无表情的花火仿佛从慎之的脑海中闪过。</p><p>  然后，从口袋里掏出了，手枪。</p><p>  开出了一片血色的花朵。</p><h2 id="ACT-12"><a href="#ACT-12" class="headerlink" title="ACT-12"></a>ACT-12</h2><p>  关于自己在做什么这件事情，慎之说不上来。从第一枪起，他就已经没有停下来的权利了——就像是一不小心将一生积累的怒气引爆一样。</p><p>  哈，我果然是一个放弃一切的人。不知道明天在晨报上读到我的名字的父母会有什么反应呢。不，应该没有把。我明明只是陌生人而已。</p><p>  趁着剩下的人还没有进入神社内部，他用仅存的理智跌跌撞撞地找到了老人，告诉他快去避难。</p><p>  『要来地下的密室躲一下吗？』老者平静地邀请，并没有理会慎之身上的血迹。</p><p>  『不……不了。』慎之脑海一片混乱，从最最初开始悉数后悔的事情，甚至连为什么当初没送隔壁小女孩礼物就被迫离开这种多少年都不会去想的事情都冒了出来。</p><p>  一边这么胡乱地回忆着，一边掂着枪，慎之找到了倚在神龛边上的鸦。</p><p>  『我留下来了。』</p><p>  鸦仍然不开口说话。他站起身，摇晃着走到花火的房间，推开门，去了她的棺前，低下头去。</p><p>  慎之站在门口，没有打扰他。</p><p>  突然地，他感觉身后的院落突然暗了下来。慎之转过身去，看到黑压压的墨色的羽毛，红色的眼瞳，利刃的寒光。</p><p>  『如果要留遗言的话，就说如果我再活一次，一定要用自己的双手去救别人的性命。』慎之大声喊着，然后冲了出去。</p><h2 id="ACT-13"><a href="#ACT-13" class="headerlink" title="ACT-13"></a>ACT-13</h2><p>  老人从密室里出来的时候还是清晨，四下里一片寂静。空气中混合着些许腥气，黑色的羽毛与血痕铺在院落里。</p><p>  他没有说话，只是绕着院子走了一圈，最后停在那间房前。</p><p>  门是开着的，无风。慎之倚在一边，像是有些疲倦的样子一动不动。包裹花火的坚冰化了，地上淌着即将干涸的淡红色的水。</p><p>  鸦不在这里。老人再仔细看，花火的身上洒满了白色的羽毛，有的沾了血水，宛若樱花。</p><p>  晨曦从地平线上溢了出来，老人转过身去看了一眼刚染上暖色的天空，然后念了一声佛。</p><h1 id="KARASU-4th-Story-鸦"><a href="#KARASU-4th-Story-鸦" class="headerlink" title="KARASU 4th Story 鸦"></a>KARASU 4th Story 鸦</h1><h2 id="ACT-0"><a href="#ACT-0" class="headerlink" title="ACT-0"></a>ACT-0</h2><p>  暮光，高楼林立，神社。</p><p>  小女孩穿着私立小学的制服，蹦蹦跳跳地爬着台阶。这里与平时去的公园很不一样，所以她十分好奇。</p><p>  『小心摔倒哦。』她的身后，像是父亲的男人不急不徐地跟着。</p><p>  小女孩爬上了台阶。啊，有个老爷爷。</p><p>  她没有出声，只是睁大黑色的眼睛，等待老爷爷拜完神像后转过身来。</p><p>  老爷爷虽然出现在这里很合适，但他并没有穿又宽又松的长袍子呀，现在住在神社里的人也要和爸爸一样穿西装吗？</p><p>  『那个呢，爷爷，住在这里的是什么神仙大人呢？』一等老爷爷参拜结束，小女孩就迫不及待地凑上去问道。</p><p>  『是鸦天狗。』老爷爷停下离去的步伐，笑吟吟地回答道。</p><p>  『您是这个神社里的人吗？』</p><p>  『不，仅仅是养成了每天这个时候来参拜的习惯。买了这片地却一直没有开发。唔……留一片乐园在市中心，如今也很难得吧。』</p><p>  『嗯……』小女孩嘟着嘴，不是很理解的样子。『那您就是社长咯？』</p><p>  『算是吧，上班的地方就在附近呢，每天来这里都很方便呀。』老爷爷点点头。</p><p>  『能扛过经济泡沫的风波，您的公司相比也不简单了。』女孩的父亲终于有机会插了一句奉承话。</p><p>  『哪里哪里，只是底子厚运气好罢了。』老爷爷摇摇头。『啊……您的照片我倒是有在报纸上见到过，是那个有名的心脏外科手术专家吧，救了不少人的性命，久仰久仰。』</p><p>  『报纸总是夸大事实而已，我只是做了本职工作。』</p><p>  『在我年轻的时候，有个很像你的医生也拯救过我。』老爷爷喃喃道。</p><p>  『是很严重的病吗？』</p><p>  『是心病。』</p><p>  男人愣了一下，不知道老人所说的『心病』的含义。</p><p>  『你的名字是什么啊？』老爷爷蹲下身，平视小女孩。</p><p>  『出生在七月末，所以叫花火。』小女孩似乎很喜欢这个自我介绍，说话的时候骄傲地抬起了头。</p><p>  『花火……么，是个好名字。』老爷爷站起来，自言自语道。</p><p>  林中突然传来翅膀扑棱的声音。花火看过去，有个白发白翼的少年也在看着她。花火的脸上出现了欣喜的表情，刚想告诉大人们，少年就比了一个『嘘』的动作，然后消失了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不知道该起什么名，叫八沢之鸦太不知所云，叫暗翼之鸦太中二，直接叫鸦又土，还是直接用鸦的罗马音算了（起名废的纠结）。&lt;/p&gt;
&lt;p&gt;初中毕业的那个暑假坐公交车的时候突然想到的脑洞，高一下学期写完了，一不小心就拖了这么久才录到电脑里，现在看来这真的是一个十分沙雕的小说，不过我也懒得改了。（可能还有错别字？）&lt;br&gt;
    
    </summary>
    
      <category term="recording" scheme="http://sheronw.github.io/categories/recording/"/>
    
    
  </entry>
  
  <entry>
    <title>2017年度书单</title>
    <link href="http://sheronw.github.io/2018/01/12/2017booklist/"/>
    <id>http://sheronw.github.io/2018/01/12/2017booklist/</id>
    <published>2018-01-13T01:35:17.000Z</published>
    <updated>2018-11-17T18:32:00.489Z</updated>
    
    <content type="html"><![CDATA[<p>  拖了很久才动笔写，一口气全写完感觉快要吐了。今年按理来说真的不算特别忙，但所有的品类加在一起也就读了二十本左右（不过小说类比往年低了很多……真的是一年比一年小说看得少），而且回顾思考也远远不到位，希望2018能够养成抽空读书的好习惯。</p><h2 id="1-《仲夏之死》by-三岛由纪夫"><a href="#1-《仲夏之死》by-三岛由纪夫" class="headerlink" title="1. 《仲夏之死》by 三岛由纪夫"></a>1. 《仲夏之死》by 三岛由纪夫</h2><p>  不是很懂文学，不太好评判。比起彻底厌世的太宰，三岛的文笔有一种昭和味道的纤细，还带点贵族气息。一边是繁华的市井，一边是放弃人生的人，平凡人的幻灭其实也没什么可说的，但加上了不知道该说时冗杂还是细腻的心里描写，这些破碎的故事反而别有一番风味。</p><h2 id="2-《人间草木》by-汪曾祺"><a href="#2-《人间草木》by-汪曾祺" class="headerlink" title="2. 《人间草木》by 汪曾祺"></a>2. 《人间草木》by 汪曾祺</h2><p>  一直觉得散文很无聊，冲着『夏天』中关于栀子花的描写买了这本书，然后才发现汪曾祺老爷子还真可爱，字里行间总有股朴实劲儿，从来找不出什么空话套话，也从来不讲什么大道理，简简单单像个孩子，还有很多幽默的字眼，读着特顺溜。除了各种有趣的日常观察之外，关于西南联大的各种你不知道的事情也蛮有意思的，强烈推荐。<br><a id="more"></a></p><h2 id="3-《圣经中文和合本》"><a href="#3-《圣经中文和合本》" class="headerlink" title="3. 《圣经中文和合本》"></a>3. 《圣经中文和合本》</h2><p>  花了好几个月，扫完了全文（是的……没有认真读），对于这么一本全球性的典籍来说，不知道为啥感觉翻译成中文之后文学性大打折扣（想想一下诗经什么的翻译成英文……）。即使将神迹显现的部分去掉，一切也仍然成立，换句话说，这不是一个神的故事，这是一部人的历史。</p><h2 id="4-《万万没想到：用理工科思维理解世界》by-同人于野"><a href="#4-《万万没想到：用理工科思维理解世界》by-同人于野" class="headerlink" title="4. 《万万没想到：用理工科思维理解世界》by 同人于野"></a>4. 《万万没想到：用理工科思维理解世界》by 同人于野</h2><p>题目有噱头，感觉应该是畅销书。作者的功力和学识我自然是认可的，但因为是博客的摘选，比较碎片化，和十万加本质上没什么区别。虽然不过作者科普做得很到位，和由人组成的社会结合起来谈科学的内容也有新意，但只能当作消遣读物在地铁公交车上打开看看，别指望能够瞬间读出什么干货就是了。仍然推荐。</p><h2 id="5-《群体性孤独》by-雪莉·特克尔"><a href="#5-《群体性孤独》by-雪莉·特克尔" class="headerlink" title="5. 《群体性孤独》by 雪莉·特克尔"></a>5. 《群体性孤独》by 雪莉·特克尔</h2><p>  可能是比较早的探讨科技给人精神层面带来的困境的书……？作者是社科出身的，行文比较感性一点，也没有什么特别强有力的观点，第一部分探讨人工智能和机器人的可能性，第二部分是社交媒体和IM，都和现在日常生活中感受到的孤独有关（因为时代原因，现在看来这些问题和其它问题相比都没那么严重了），读起来稍微有点无聊。</p><h2 id="6-《二手时间》by-S-A-阿列克谢耶维奇"><a href="#6-《二手时间》by-S-A-阿列克谢耶维奇" class="headerlink" title="6. 《二手时间》by S.A.阿列克谢耶维奇"></a>6. 《二手时间》by S.A.阿列克谢耶维奇</h2><p>  这是一本真实的访谈录。不愧是诺奖得主，关于人性的探讨和历史的厚重感根本不是我能够详细阐述的。选题叫『二手时间』，题材的跨度以及写作时间都很长，从备受争议的斯大林时代到苏联解体，甚至俄罗斯建国后的一些历史遗留问题还有恐袭都有所涉及。在历史课本上被一带而过的从十月革命到苏联解体的这段时间里，无数俄罗斯人民的血与泪都挥洒在了这片土地上。</p><p>  从各种意义上来说，俄罗斯这个民族都很特殊——在高寒冻土的艰苦条件下生活的太久了，以至于面对死亡和战争时都平静得可怕，仿佛他们正为此而生。当然，这也是一个文豪辈出的国度，在那个计划经济的年代，书籍才是人们的食粮，每个人都在阅读和谈论文学，他们相信哲学，相信爱，甚至可以为了理想而疯狂。上天赋予了俄罗斯人复杂的天性，也赋予了他们多舛的命运。『俄罗斯的生活就应该是不幸的，贫寒的，那样灵魂才能高尚。它的意义就在与它不属于这个世界，越是肮脏和血腥，灵魂越能得到自由……』</p><p>  阿列克谢耶维奇一贯采用纪实文学性质的复调写作，自始至终都没有为任何谈话添加自己的主观意愿，因此我们可以在同一本书、甚至同一章节中见到两种针锋相对的观点，这也预示着不同的人在不同的立场上发声，没有人是『政治正确』的。受访者多为普通民众，却十分具有代表性，因为『这是属于一个时代而不是某一个人的故事』，在大的时代背景下，小人物的牺牲往往是被忽略的，因此同样的故事反反复复地发生。</p><p>  当然，被议论得最多的就是『苏联』存在过的意义了。一方人憎恨计划经济，憎恨斯大林以及那个时代的种种荒谬却又骇人听闻的行为（初中的时候还买过古拉格的书，但我没读完……）以及给人们带来的巨大伤痛。然而另一方人，多是那些老年的、为苏联奉献一生的人，却无比怀念那个光荣的时代：苏联在艰苦的条件下造出了原子弹、击败了希特勒、水坝和各种公共设施从无到有……他们为共产主义的不战而败而惋惜，同时也因为理想时代和拜金主义切换得如此之迅速而无比困惑。『商店里满是香肠，但人们没有幸福。我再也看不到人们炽热的目光了。』</p><p>  因为我们也经历过如斯大林时代一般的『狂热』，也曾为姓『资』还是姓『社』而争论不休，因此这本书，以及曾经红色帝国的历史，对我国也许会有特别的借鉴意义，如果能够耐心看得完厚厚一本的话，强烈推荐。</p><h2 id="7-《少女不十分》by-西尾维新"><a href="#7-《少女不十分》by-西尾维新" class="headerlink" title="7. 《少女不十分》by 西尾维新"></a>7. 《少女不十分》by 西尾维新</h2><p>  其实这是我看的第一本西尾维新的轻小说……说实话感觉挺一般的，可能是因为自己看过一些他原作担当的动画而且喜欢的轻小说作者入间人间是他的脑残粉所以要求有点高。当然这个差不多是伪自传的文章也不需要开太多脑洞，所以还没看完我就猜到结局了（喂）。</p><p>  虽然是这样，西尾的文笔倒是真的有那种轻小说的风范，特点就是废话多，一点剧情配十万句吐槽，物语系列还是新房改得好，特点都保留了（来来来让我看到你们的暂停键），当然这是跑题了。……所以阿宅们比较有带入感，然后再弄点家里蹲的人生危机就能大卖了，换句话说西尾算不上是小说家，应该说是输出某一种特定价值观的OTAKU人生导师吧……？</p><p>  具体有多废话呢，前20页根本没情节，而全篇也差不多是这种步调吧，一个短篇小说的情节量凑了一本书，终于知道为什么刀语一卷改一集动画了，当年追忆飞行员好像是一本就是一个剧场版……？虽然可能是这方面的东西（西尾价值观）接触太多了，所以我其实还是很喜欢西尾这种风格的，看来我的思想已经严重西化了hhh</p><h2 id="8-《天空的另一半》by-尼可拉斯·D-克里斯多夫-amp-雪莉·邓恩"><a href="#8-《天空的另一半》by-尼可拉斯·D-克里斯多夫-amp-雪莉·邓恩" class="headerlink" title="8. 《天空的另一半》by 尼可拉斯·D.克里斯多夫&amp;雪莉·邓恩"></a>8. 《天空的另一半》by 尼可拉斯·D.克里斯多夫&amp;雪莉·邓恩</h2><p>  可能我就是那种利己主义者，看完全书之后内心毫无波动。为自己争取权利，同时为自己所在的群体争取权利，这点觉悟我还是有的，然而自己这儿还有一摊乱事还去帮别人，对不起我做不到。虽然从这个角度上看作者的出发点并没有什么不妥，文章都一度在纽约时报上登载了，愿意干好事的有钱人也会看到的，只要一百个人里面有一个人看到了也会大不一样。可能这就是西方媒体的一种责任吧。</p><h2 id="9-《国富论（罗卫东选译本）》by-亚当·斯密"><a href="#9-《国富论（罗卫东选译本）》by-亚当·斯密" class="headerlink" title="9. 《国富论（罗卫东选译本）》by 亚当·斯密"></a>9. 《国富论（罗卫东选译本）》by 亚当·斯密</h2><p>  我不知道该怎么说这本书，一是因为这只是选译本，无法窥其全貌，二是因为这种到处都是精华的书没法写一个概括出来。如果你是一个没上高中的初中生的话，强烈建议稍微瞧几眼选译本，比高中政治课本经济生活部分不知道高到哪里去了。</p><h2 id="10-《贝尔实验室与美国革新大时代》by-乔恩·格特纳"><a href="#10-《贝尔实验室与美国革新大时代》by-乔恩·格特纳" class="headerlink" title="10. 《贝尔实验室与美国革新大时代》by 乔恩·格特纳"></a>10. 《贝尔实验室与美国革新大时代》by 乔恩·格特纳</h2><p>  这本书讲的是贝尔实验室从建立到重组直至衰落的历史，中间提到的科学家很多，不少重要科研成果的研发过程也很有意思，包括但不限于我们现在司空见惯的晶体管、太阳能电池、光导纤维、激光、通讯卫星、蜂窝移动数据还有现代通讯技术的基本概念，而且贝尔实验室兴起的时代正是美国赶超欧洲的那个年代，听上去还真是热血沸腾。尽管上文提到的每一个发明都巨牛逼，但作为『创新』成果来讲贝尔实验室留给后人的遗产反而是一种培养并管理创新人才的系统，即使在今天都值得借鉴。不管怎么说，贝尔实验室的成就代表了那个辉煌的年代，正是它孕育出了当时的未来，也就是我们如今习以为常的现在。</p><h2 id="11-《单身社会》by-克里南伯格"><a href="#11-《单身社会》by-克里南伯格" class="headerlink" title="11. 《单身社会》by 克里南伯格"></a>11. 《单身社会》by 克里南伯格</h2><p>本来以为是和什么年轻人不婚有关的书（这样就可以理直气壮地保持单身了），但好像也没有给出什么特别新的观点，主要是一些访谈什么的，而且很大一部分内容都给了老年人独居的问题，可以参考《无缘社会》。</p><h2 id="12-《斯通纳》-by-约翰·威廉斯"><a href="#12-《斯通纳》-by-约翰·威廉斯" class="headerlink" title="12. 《斯通纳》 by 约翰·威廉斯"></a>12. 《斯通纳》 by 约翰·威廉斯</h2><p>这书我一开始就是在国家图书馆书架上随便找的，结果没想到看了几页不知为何有些哽咽，回去入了kindle版。喜欢这种行文叙事的感觉，克制又不失张力。一个平淡无奇的人，平淡无奇地出生，平淡无奇地活着，平淡无奇地死去，而人生好像其实就是这样。推荐。</p><h2 id="13-《大国大城》by-陆铭"><a href="#13-《大国大城》by-陆铭" class="headerlink" title="13. 《大国大城》by 陆铭"></a>13. 《大国大城》by 陆铭</h2><p>讲中国城市（尤其是一线城市）的规划问题，写了一些现有政策（尤其是户籍制度）的不合理性并提出了建议，打算二刷。陆铭教授绝壁是中国学界一股令人心疼的泥石流，整本书清晰易懂又有理有据，然而书都出了好几年了到目前为止政策并没有什么变化。强烈推荐。</p><h2 id="14-《Weapons-of-Math-Destruction》by-Cathy-O’Neil"><a href="#14-《Weapons-of-Math-Destruction》by-Cathy-O’Neil" class="headerlink" title="14. 《Weapons of Math Destruction》by Cathy O’Neil"></a>14. 《Weapons of Math Destruction》by Cathy O’Neil</h2><p>一个数据学家以自己亲历的职业经验为起点，搜集了各种导致阶级固化恶性循环的数据处理筛选系统并命名为WMD（Weapons of Math Destruction），看了之后各种细思恐极。虽然好像在美国这种现象更加严重，但在中国也能够感同身受。我不认为这是陈词滥调，毕竟原本人们可以规避这一切，算是为目前正火的什么big data敲响了警钟。</p><h2 id="15-《One-Child-The-Past-and-Future-of-China’s-Most-Radical-Experiment》by-Mei-Fong"><a href="#15-《One-Child-The-Past-and-Future-of-China’s-Most-Radical-Experiment》by-Mei-Fong" class="headerlink" title="15. 《One Child: The Past and Future of China’s Most Radical Experiment》by Mei Fong"></a>15. 《One Child: The Past and Future of China’s Most Radical Experiment》by Mei Fong</h2><p>马来西亚华裔作为纽约时报记者，以一个旁观者的角度写的书。出人意料地包括了关于独生子女政策许多方面，比如对于重男轻女、超生、独生子女的娇惯现象以及失独家庭。整本书并不长，作者官网有中文版下载（但应该被墙了吧）。</p><h2 id="16-《A-Christmas-Carol》-by-Charles-Dickens"><a href="#16-《A-Christmas-Carol》-by-Charles-Dickens" class="headerlink" title="16. 《A Christmas Carol》 by Charles Dickens"></a>16. 《A Christmas Carol》 by Charles Dickens</h2><p>在那个年代肯定算是不错的人文关怀类小说，可惜现在看来有点套路（虽然双城记也有点套路但没它这么套路），可能是我之前看过类似的故事吧，直接猜到结局了QvQ</p><h2 id="17-《All-I-Really-Need-to-Know-I-Learned-in-Kindergarten》by-Robert-Fulghum"><a href="#17-《All-I-Really-Need-to-Know-I-Learned-in-Kindergarten》by-Robert-Fulghum" class="headerlink" title="17. 《All I Really Need to Know I Learned in Kindergarten》by Robert Fulghum"></a>17. 《All I Really Need to Know I Learned in Kindergarten》by Robert Fulghum</h2><p>也是一本散文集，虽然这是我读的第一本全英文的散文集，但这作者和汪曾祺老爷爷的风格有点像，还是走日常诙谐路线的（可能是美式休闲风吧），所以读起来并不难，有空的时候就读一篇小短文也不累。不过成书在上个世纪八十年代，有的时候发现了关于美国那个时代的一些小细节（比如冷战什么的）还觉得挺有意思的。这本书里的序言被人教版高中语文课本收录了，起了个名字叫《教条》，当初就印象深刻……</p><h2 id="18-《复眼人》by-吴明益"><a href="#18-《复眼人》by-吴明益" class="headerlink" title="18. 《复眼人》by 吴明益"></a>18. 《复眼人》by 吴明益</h2><p>虽然只看过吴明益的《天桥上的魔术师》，但一直觉得他是那种typical的台湾小说家hhh之前那本『天桥上的魔术师』主要是讲台北，而这本『复眼人』讲台湾土著的一些价值观和古老传承更多一点（一本是城市，一本是自然），而且关于女主儿子的那段我觉得逻辑上稍微有点站不住脚，可能这种文艺的人更适合写一个留下很多空白的人物（比如天桥上的那个魔术师）而不是进行世界观搭建吧。虽然我真的更喜欢『天桥上的魔术师』多一点，但这本『复眼人』也还算不错。如果有机会的话可以读一下。</p><h2 id="19-《From-the-Soil-The-Foundation-of-Chinese-Society》by-费孝通"><a href="#19-《From-the-Soil-The-Foundation-of-Chinese-Society》by-费孝通" class="headerlink" title="19. 《From the Soil: The Foundation of Chinese Society》by 费孝通"></a>19. 《From the Soil: The Foundation of Chinese Society》by 费孝通</h2><p>挺有年头的书了，现在中国农村的情况已经大不一样了，但有很多传统的思想还是没有改变的。整本书不太厚，有机会应该会认真重读吧。</p><h2 id="20-《Willful-Blindness》by-Margaret-Heffernan"><a href="#20-《Willful-Blindness》by-Margaret-Heffernan" class="headerlink" title="20. 《Willful Blindness》by Margaret Heffernan"></a>20. 《Willful Blindness》by Margaret Heffernan</h2><p>研讨课上要求的课本，讲人的潜意识在日常生活中的一些表现，运用了大量的例子引证，不过大多数例子都和美国人的日常生活密切相关（或者是他们亲身经历过的），所以中国人读起来可能没有那种熟悉的感觉。差不多是自己（不得不）正经八百地读的第一本英文作品。之前很少接触这种体裁的文学，留学之后才发现还是挺多的。</p><h2 id="21-《The-Hidden-Brain》by-Shankar-Vedantam"><a href="#21-《The-Hidden-Brain》by-Shankar-Vedantam" class="headerlink" title="21. 《The Hidden Brain》by Shankar Vedantam"></a>21. 《The Hidden Brain》by Shankar Vedantam</h2><p>也是研讨课上要求的课本，但感觉比上一本写的要好一点，例子举得没那么碎了还图文并茂，而且这个作者好像挺擅长使用比喻和通感这两种修辞手法的（喂）。总之看了这两本书之后对人类的潜力感到深深地绝望。本来以为自己会变得更好，结果科学研究发现『你不行的』『你做不到的』『这是基因所决定的』『这就是人类极限了』。本来以为人活着要被社会和其他各种东西所束缚所以不可能自由，结果其实连自己都不受自己控制hhhh</p><h2 id="22-《黄昏色的咏使》by-细音启"><a href="#22-《黄昏色的咏使》by-细音启" class="headerlink" title="22. 《黄昏色的咏使》by 细音启"></a>22. 《黄昏色的咏使》by 细音启</h2><p>人生中读完的第一个轻小说系列，初中的时候看着个觉得写的真好，后来就下了电子书重温了一遍，现在看来好像没有当时看的时候觉得那么好了，但仍然是目前心中轻小说NO.1，之后细音启写的东西一本不如一本，只有这本还没完全被商业气息给沾染，还是最初的少年少女的故事。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  拖了很久才动笔写，一口气全写完感觉快要吐了。今年按理来说真的不算特别忙，但所有的品类加在一起也就读了二十本左右（不过小说类比往年低了很多……真的是一年比一年小说看得少），而且回顾思考也远远不到位，希望2018能够养成抽空读书的好习惯。&lt;/p&gt;
&lt;h2 id=&quot;1-《仲夏之死》by-三岛由纪夫&quot;&gt;&lt;a href=&quot;#1-《仲夏之死》by-三岛由纪夫&quot; class=&quot;headerlink&quot; title=&quot;1. 《仲夏之死》by 三岛由纪夫&quot;&gt;&lt;/a&gt;1. 《仲夏之死》by 三岛由纪夫&lt;/h2&gt;&lt;p&gt;  不是很懂文学，不太好评判。比起彻底厌世的太宰，三岛的文笔有一种昭和味道的纤细，还带点贵族气息。一边是繁华的市井，一边是放弃人生的人，平凡人的幻灭其实也没什么可说的，但加上了不知道该说时冗杂还是细腻的心里描写，这些破碎的故事反而别有一番风味。&lt;/p&gt;
&lt;h2 id=&quot;2-《人间草木》by-汪曾祺&quot;&gt;&lt;a href=&quot;#2-《人间草木》by-汪曾祺&quot; class=&quot;headerlink&quot; title=&quot;2. 《人间草木》by 汪曾祺&quot;&gt;&lt;/a&gt;2. 《人间草木》by 汪曾祺&lt;/h2&gt;&lt;p&gt;  一直觉得散文很无聊，冲着『夏天』中关于栀子花的描写买了这本书，然后才发现汪曾祺老爷子还真可爱，字里行间总有股朴实劲儿，从来找不出什么空话套话，也从来不讲什么大道理，简简单单像个孩子，还有很多幽默的字眼，读着特顺溜。除了各种有趣的日常观察之外，关于西南联大的各种你不知道的事情也蛮有意思的，强烈推荐。&lt;br&gt;
    
    </summary>
    
      <category term="reading" scheme="http://sheronw.github.io/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>Introduction to Git for Data Science笔记</title>
    <link href="http://sheronw.github.io/2018/01/09/IntroToGit/"/>
    <id>http://sheronw.github.io/2018/01/09/IntroToGit/</id>
    <published>2018-01-10T03:54:46.000Z</published>
    <updated>2018-01-10T04:16:56.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刷Ins的时候看到的<a href="https://www.datacamp.com/courses/introduction-to-git-for-data-science" target="_blank" rel="external">广告</a>hhh反正课时不长就点开了</p></blockquote><h2 id="Basic-Workflow"><a href="#Basic-Workflow" class="headerlink" title="Basic Workflow"></a>Basic Workflow</h2><ol><li><p>version control system</p><ul><li>保存不同版本</li><li>项目合作</li><li>防止重复工作</li></ul></li><li><p>repository</p><ul><li>文件</li><li>直接编辑的路径</li><li>其他信息（根目录中的.git）<br><em>all of the information about a repository is stored under its root directory（和文件夹同一层级）</em></li></ul></li><li><p><strong>git status</strong> #上次更改时保存的文件列表</p></li><li><p><strong>git diff (filename/depository)</strong> #compare the file as it currently is to what you last saved<br><strong>git diff -r HEAD filename</strong> #和上次更新对比</p></li><li><p><strong>git add filename</strong> #add a file to staging area</p></li><li><p><strong>git commit -m “Messeage”</strong></p></li><li><p><strong>git log (path)</strong> #view the log of the project’s history<br>Press the space bar to go down a page or the ‘q’ key to quit</p></li></ol><a id="more"></a><h2 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h2><ol><li><strong>git show hash</strong> #显示某次commit的信息</li><li>标签<strong>HEAD</strong>表示最近的一次commit，标签<strong>HEAD~1</strong>表示最近一次之前的commit，以此类推</li><li><strong>git annotate file</strong> #shows who made the last change to each line of a file and when</li><li><strong>git diff ID1..ID2</strong></li><li>忽略特定文件：在根目录新建 <strong>.gitignore</strong></li><li><strong>git clean -n</strong> #显示路径中没被追踪的文件<br><strong>git clean -f</strong> #删除这些文件</li><li><strong>git config –list</strong><br>- -system: settings for every user on this computer.<br>- -global: settings for every one of your projects.<br>- -local: settings for one specific project.</li></ol><h2 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h2><ol><li><strong>git checkout – filename</strong> #discard the changes that have not yet been staged</li><li><strong>git reset HEAD filename</strong> #undo changes that have been staged, to the state you last staged</li><li><strong>git checkout 某次commit的hash 文件名</strong> #将某个文件恢复到某次commit的状态</li><li>the act of restoring the file is saved as another commit</li><li><strong>git reset HEAD (path)</strong></li><li><strong>git checkout – (path)</strong></li><li>路径.代表所有该路径以及以下的文件</li></ol><h2 id="Working-with-branches"><a href="#Working-with-branches" class="headerlink" title="Working with branches"></a>Working with branches</h2><ol><li><strong>git branch</strong> #list all of the branches in a repository</li><li><strong>git diff branch-1..branch-2</strong> #shows the difference between two branches</li><li><strong>git checkout branch-name</strong> #switch to another branch(要commit所有的change)</li><li><strong>git rm file</strong> #delete file</li><li><strong>git checkout -b branch-name</strong> #create a new branch</li><li><strong>git merge source destination</strong> #merge to branch(incorporates the changes made to the source branch into the destination branch)</li><li>如果merge时出现了conflict，那么使用<strong>git status</strong>查找出问题的文件然后修改（<strong>nano filename</strong>）</li></ol><h2 id="Collaborating"><a href="#Collaborating" class="headerlink" title="Collaborating"></a>Collaborating</h2><ol><li><strong>git init project-name</strong> #create a new repository</li><li>尽量不要在repository里新建repository</li><li>在路径中<strong>git init</strong>或<strong>git init 路径</strong>将现有的project转化为repository</li><li><strong>git clone URL or file:///existing/project newRepository</strong> #clone a repository</li><li><strong>git remote</strong> #list the names of repository’s remotes</li><li><strong>git remote -v</strong> #shows the remote’s URLs</li><li><strong>git remote add remote-name URL</strong> #add more remote</li><li><strong>git remote rm remote-name</strong> #remove remote</li><li><strong>git pull remote branch</strong> #gets everything in branch in the remote repository identified by remote and merges it into the current branch of your local repository</li><li><strong>git push remote-name branch-name</strong> #pushes the contents of your branch branch-name into a branch with the same name in the remote repository associated with remote-name</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;刷Ins的时候看到的&lt;a href=&quot;https://www.datacamp.com/courses/introduction-to-git-for-data-science&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;广告&lt;/a&gt;hhh反正课时不长就点开了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Basic-Workflow&quot;&gt;&lt;a href=&quot;#Basic-Workflow&quot; class=&quot;headerlink&quot; title=&quot;Basic Workflow&quot;&gt;&lt;/a&gt;Basic Workflow&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;version control system&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存不同版本&lt;/li&gt;
&lt;li&gt;项目合作&lt;/li&gt;
&lt;li&gt;防止重复工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;repository&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;直接编辑的路径&lt;/li&gt;
&lt;li&gt;其他信息（根目录中的.git）&lt;br&gt;&lt;em&gt;all of the information about a repository is stored under its root directory（和文件夹同一层级）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git status&lt;/strong&gt; #上次更改时保存的文件列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git diff (filename/depository)&lt;/strong&gt; #compare the file as it currently is to what you last saved&lt;br&gt;&lt;strong&gt;git diff -r HEAD filename&lt;/strong&gt; #和上次更新对比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git add filename&lt;/strong&gt; #add a file to staging area&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git commit -m “Messeage”&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git log (path)&lt;/strong&gt; #view the log of the project’s history&lt;br&gt;Press the space bar to go down a page or the ‘q’ key to quit&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="notetaking" scheme="http://sheronw.github.io/categories/notetaking/"/>
    
    
  </entry>
  
  <entry>
    <title>不知道应该起什么标题的纽约纪行</title>
    <link href="http://sheronw.github.io/2018/01/05/Christmas2017InNYC/"/>
    <id>http://sheronw.github.io/2018/01/05/Christmas2017InNYC/</id>
    <published>2018-01-05T20:35:12.000Z</published>
    <updated>2018-01-10T19:09:44.629Z</updated>
    
    <content type="html"><![CDATA[<p>今年圣诞假也就两个周，和过年的时间也对不上，所以自认为并没有回国的需要（最主要的是今年入了Pixel 2，还有各种在墙外用习惯了的服务，不想回国再折腾），于是和几个中国留学生合计了一下，发现去趟纽约的来回路费+Airbnb多人拼房的费用比来回机票要便宜点儿，就在距离出发一两周前十分敷衍地把所有东西订完了（其实早点定的话会更便宜……）。</p><p>不过，写点什么好呢，只好翻翻自己没写几个字的流水账本和（第一个周）同行的女生在微博发的Vlog（因为本人在里面有正脸……所以就不发URL了hhhh），Vlog什么的似乎最近很流行的样子，看起来感觉也很好，但我连照片都懒得拍，拍视频什么的太难为我了QvQ</p><a id="more"></a><p>然后才发现……因为我们这一行人都懒散没规划，回过头来看看这两个周的假期并！没！有！逛！多！少！地！方！也就吃得还挺好（和我们学校typical American food相比），日常就是睡到中午，下午逛一会儿，晚上回去各自抱着各自的电脑熬到下半夜，再加上我们都是几个没什么仪式感的人，所以圣诞节和元旦也就跟没过差不多，甚至比平时都敷衍。</p><p>其实之前一直觉得美国不美（和世界上绝大多数国家or地区比，真的），尤其是非自然景观，因为这是一个老牌的现代化国家，所以一切都是看起来旧旧的新东西，历史感不浓厚。目前唯一能够感受到历史厚重感的地方应该就是东部的没落工业地区吧，就和<em>迷河</em>或<em>Sally Face</em>里的场景，还有我在路上看到的大多数没有什么烟火气的小镇一样，充满着颓圮的气息，楼要不高不低，砖要红，周围要有杂草，天要阴——这是一种不太积极向上的美感，但也是我目前为止唯一觉得美国“漂亮”的地方（至于一些高大上的东西，摩天大楼还有高科技什么玩意儿的，放在哪个国家都一样，所以忽略不计）。</p><p>纽约也是这样，虽然不能算是没落，但你可以深切地体会到这里的 <strong>脏 乱 差</strong> ，莫名其妙杂乱无章的城市规划，无处不在的垃圾和污水，大冬天睡在路边的无家可归者，总是有股尿骚味的地铁站里跟你搭讪的流浪汉。虽然说是这么说，我还是觉得纽约是散发着独特的魅力的，但又说不出来到底为什么——也许她的居民可以随意布置自己的房子不用担心天际线和穿墙打洞，也许不论什么人都能来这儿呆着找机会不必担心自己是低端人口，即使是连英语都不会说的人。Big Apple的绰号的确不为过，这是一个纷繁复杂的万花筒。</p><p>不过说是纽约纪行，但主要的活动范围其实也就在曼哈顿，尤其是比较靠南的那一块儿，就是SOHO和东村附近。最开始的几天好像都在陪着他们逛街（之后的几天好像也在陪他们逛街），大概就是SOHO周遭的各种小店铺大店铺，然而其实我最大的花销就是为了晚上大家一起看电影而在APPLE Store买的mini porter to HDMI adpter……接近四十刀的价格感觉肉疼极了。其实可能是之前我在国内也没买过那些牌子，反正看了看价格也都不便宜，在H&amp;M买了个白色卫衣就三十多刀，我之前的卫衣明明是漫踪打折的时候花了软妹币七八十捞的hhh</p><p>然后好像我们一直都在逛街，去了世贸中心附近但完全没去911纪念馆一直在逛街，第五大道洛克菲勒广场之类的当然更是逛街，本来打算去西边的高线公园但其实也没去成也是在附近逛街……可是因为去的时候只带了个书包连箱子都没带，回来的时候也只带了个书包，也就买了件卫衣买了条裤子，回来的时候都穿身上了，也没有什么购物体验可以分享（这次旅行之后我发现我之前真的对男孩子们的购买力和逛街力有很大的误会……可以说是纠正了刻板印象了）hhh</p><p>公园的话，好像去了bryant park的那个冬天的集市，但仅仅是路过所以根本没逛，再就是大名鼎鼎的central park，正好去的那天下了挺大的雪，虽然人不多但真的是白茫茫一片啥都没有如果是夏天草木繁盛的时候去应该会很热闹吧，但冬天真的没什么可看的。</p><p>纽约本来有无数值得去的博物馆艺术馆啊之类的，可是我们也就去了三个，大都会（MET），现代艺术（MoMA）还有自然历史博物馆（其实就是最著名的那三个）。</p><p>MET真的很棒，之前初中毕业旅行的时候就去过一次，而这次旅行有四分之一的时间都贡献给了它，尽管如此去了这么多次常规展览也可能看了不到四分之一QvQ说到逛博物馆，我一直都特别讨厌那种去最知名的几个展品前面拍好照绕了一圈就算是去过了的那种游览方式，可是如果要仔细观察每一个展品，把所有的说明都看完，听一遍官方解说再把各种历史背景了解完的话，估计一天一个展厅都看不完吧hhh这次正好同行的都是文科生，听他们一边解释一边讨论希腊罗马古埃及历史还有各种兵器的演变感觉还是挺有意思的。</p><p>在某些展厅可以看到外面中央公园的方尖碑，再加上在埃及展馆神庙前面有当初碑下放着的螃蟹，于是出于好奇就冒着严寒去看了一下。这个方尖碑和华盛顿特区那个美国人仿造的不一样，倒是埃及人公元前15世纪造的真货，换了好几个王朝挪了好几个地方，到托勒密王朝的时候有了个名字叫克娄巴特拉之针，反正辗转之后被送到了美国。一直都是这样，政府了一个古老又辉煌的文明之后就把那边的宝贝搬回家，和当年圆明园似的。估计古埃及那帮人也没想到过自己出于某种愿望建造的方尖碑会被挪好几个地方，从一个帝国到另一个帝国，知道几千年后远渡重洋，来到一个年轻又野心勃勃的国家，被刻上他们的文字和他们的愿望，放在公园里面供来自全世界的人瞻仰。他们可能更没想到在几千年后，新世界的人们又仿照方尖碑的式样又造了个方尖碑，然后给予了什么别的愿望。</p><p>自然历史博物馆的话，我也就逛了半天，门口有老罗斯福的雕像，卖票的地方还有老罗的语录，看样子应该是和（喜欢自然历史的）老罗有点关系了。虽然进去之后发现基本上全是标本………………可能在之前的时代里看标本是一件挺有意思的事情，但现在各式各样的资源这么多，看标本就有点无聊了。不过人类学方面的一些展馆都挺有意思，我看了大洋洲和亚洲的部分，之前一直不知道人类学都是学啥的，看完了之后大概有了一点印象hhh</p><p>虽然MoMA有很多著名的展品，但恕我直言，这个品牌营销做的十分不错，首先MoMA这四个单词就已经是一种符号一样的品牌形象了，还有那么多周边产品和Store（是的，感觉这栋楼已经被周边店给充满了，而除了楼马路对面还有一家），最主要的是楼下的那家餐馆还是米其林（当然我没去）……所以门票也是这几个里面最贵的，因为另外两个博物馆都是捐赠制每次不要脸地交一美刀就进去了hhh我去的那一天MoMA挤满了人，完全没有看下去的兴致。其他的展品倒是名气不大，但我至少硬着头皮看不懂装懂地看完了，可是五楼的那些画，本来值得好好看看，但看着一堆人排队在前面合影我就……嘛，所以梵高的星空我连看都没看，毕加索马蒂斯夏加尔的一些之前在画册上见到的我还是远远观望了一下。有意思的是MoMA的门票可以兑换一张楼下MoMA电影院的票，我看的是<em>Smithereens</em>，1982年的片子，很嬉皮士歌很好听，虽然和展品一样看不懂。</p><p>其实这次旅行花销最多的就是吃，主要是吃一些在我们村里吃不到的东西，比如中餐和日料，我们也没有去找什么推荐都是在路边随便找的店铺，最主要的是我……也感受不出来好吃不好吃，应该算是好吃吧，但就是贵极了，基本上都是把美元当人民币花的节奏。吃过一次法餐，还是从MET出来在上东区走投无路吃的（虽然我觉得还蛮好吃的）。结果就是最后几天我们都吃土了，天天吃burger king和subway……</p><p>说下纽约的地铁，其实感觉没有网上说的那么乱，uptown往北走downtown往南走，分清楚local和express这两种车，再就是仔细听广播还有多注意观察各种指示牌，反正我倒是没有遇到什么大问题。治安的话，即使是午夜地铁里也挤满了人……虽然还是有各种奇奇怪怪的人。卖艺的倒是挺多，虽然可以说是噪音污染但大部分时间都感觉很有feel，一想到北京地铁的卖艺人就觉得有点扎心。</p><p>最后秀一下单纯充值信仰订的Google Photo Book，九块九（美元）包邮的平装版，因为精装版十九块九……没怎么拍照所以把一些乱七八糟被发在别人微信群里的合照也加上了才凑够了最低要求二十张。印刷的话好像都是比屏幕上的颜色要深一些，以及pixel原生的图片印出来的效果都挺好，别人的手机（iphone）因为通过微信传输的原因（有的是发原图有的不是）会糊一点，内页的话……自己摄影水平垃圾就不放了。</p><p><img src="http://images2.imagebam.com/4c/3b/0d/d1db95714051993.jpg" alt="photo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年圣诞假也就两个周，和过年的时间也对不上，所以自认为并没有回国的需要（最主要的是今年入了Pixel 2，还有各种在墙外用习惯了的服务，不想回国再折腾），于是和几个中国留学生合计了一下，发现去趟纽约的来回路费+Airbnb多人拼房的费用比来回机票要便宜点儿，就在距离出发一两周前十分敷衍地把所有东西订完了（其实早点定的话会更便宜……）。&lt;/p&gt;
&lt;p&gt;不过，写点什么好呢，只好翻翻自己没写几个字的流水账本和（第一个周）同行的女生在微博发的Vlog（因为本人在里面有正脸……所以就不发URL了hhhh），Vlog什么的似乎最近很流行的样子，看起来感觉也很好，但我连照片都懒得拍，拍视频什么的太难为我了QvQ&lt;/p&gt;
    
    </summary>
    
      <category term="recording" scheme="http://sheronw.github.io/categories/recording/"/>
    
    
  </entry>
  
</feed>
