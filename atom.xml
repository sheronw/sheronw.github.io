<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SheronW</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sheronw.xyz/"/>
  <updated>2019-10-22T19:40:51.650Z</updated>
  <id>https://blog.sheronw.xyz/</id>
  
  <author>
    <name>SheronW</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二进制中1的个数问题</title>
    <link href="https://blog.sheronw.xyz/2019/10/22/count_bits/"/>
    <id>https://blog.sheronw.xyz/2019/10/22/count_bits/</id>
    <published>2019-10-22T19:24:02.000Z</published>
    <updated>2019-10-22T19:40:51.650Z</updated>
    
    <content type="html"><![CDATA[<p>之前在computer architecture的课上用assembly language实现了一遍，当初的实现方法大概这样：<br>每次使用位运算符往右挪一下然后再往左挪一下，因为系统默认会用0来填充，所以如果最右位为零，那么变换前后值相等，否则最右位为1.结束判断后，再向右移以消除该位……直到整个数字归零。<br>然后前几天刷题的时候看到了类似的题目，然后就开心地直接上手这么写了，然后负数部分的test全部没通过。<br><a id="more"></a><br>后来找到了问题所在：在大部分高级语言中，当一个数为负数时，向右挪的话，最左位时会用1而不是0来填充的，这就导致了负数不管shift多少次都没法变成零，然后就runtime error了。<br>我还专门查了一下，至少JavaScript里面是有zero-fill right shift操作符（&gt;&gt;&gt;）的，但是既然都用Python写了这么多了……<br>最后只好单独处理负数。如果一个数字为负，那么使用位运算符～将其翻转，然后我们数出来的1的个数其实是它0的个数，最后用总数32位减去0的个数就可以得到1的个数了。</p><p>代码如下：</p><pre><code>def countOnes(self, num):    # write your code here    count = 0    negative = False    if num&lt;0:        num = ~num        negative = True    while num!=0:        num2 = num &gt;&gt; 1        num2 = num2 &lt;&lt; 1        if num2!=num:            count+=1        num = num &gt;&gt; 1    if negative:        count = 32-count    return count</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在computer architecture的课上用assembly language实现了一遍，当初的实现方法大概这样：&lt;br&gt;每次使用位运算符往右挪一下然后再往左挪一下，因为系统默认会用0来填充，所以如果最右位为零，那么变换前后值相等，否则最右位为1.结束判断后，再向右移以消除该位……直到整个数字归零。&lt;br&gt;然后前几天刷题的时候看到了类似的题目，然后就开心地直接上手这么写了，然后负数部分的test全部没通过。&lt;br&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://blog.sheronw.xyz/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>折腾VPS的记录</title>
    <link href="https://blog.sheronw.xyz/2019/07/12/basic_vps/"/>
    <id>https://blog.sheronw.xyz/2019/07/12/basic_vps/</id>
    <published>2019-07-12T18:40:50.000Z</published>
    <updated>2019-08-17T21:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-VPS-setup-log"><a href="#new-VPS-setup-log" class="headerlink" title="new VPS setup log"></a>new VPS setup log</h1><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><pre><code>useradd -m 用户名passwd 用户名</code></pre><h2 id="将该用户赋予root权限-利用sudo命令，需要输入密码"><a href="#将该用户赋予root权限-利用sudo命令，需要输入密码" class="headerlink" title="将该用户赋予root权限(利用sudo命令，需要输入密码)"></a>将该用户赋予root权限(利用sudo命令，需要输入密码)</h2><p>赋予文件读写权限：</p><pre><code>chmod u+w /etc/sudoers</code></pre><p>打开文件找到</p><pre><code>root ALL = (ALL:ALL) ALL</code></pre><p>下面添加</p><pre><code>用户名 ALL = (ALL:ALL) ALL</code></pre><p>取消读写权限：</p><pre><code>chmod u-w /etc/sudoers</code></pre><a id="more"></a><h2 id="ssh-configuration"><a href="#ssh-configuration" class="headerlink" title="ssh configuration"></a>ssh configuration</h2><p>create rsa key</p><pre><code>ssh-keygen -t rsa</code></pre><p>import public key</p><pre><code>cd .sshcat id_rsa.pub &gt;&gt; authorized_keyschmod 600 authorized_keyschmod 700 ~/.sshsudo chmod u+w /etc/ssh/sshd_configsudo vim /etc/ssh/sshd_config</code></pre><p>find these lines and change to:</p><pre><code>PermitRootLogin noRSAAuthentication yesPubkeyAuthentication yessudo chomod u-w /etc/ssh/sshd_config</code></pre><p>use WINSCP to get <code>id_rsa</code>, open PuTTYGen, load file, add necessary information, then save private key<br>open PuTTY, <code>Connection -&gt; SSH -&gt; Auth</code>, find Private key file for authentication and load it<br>you could go back to <code>/etc/ssh/sshd_config</code> and add this line to deny password authentication, if you like:</p><pre><code>PasswordAuthentication no</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;new-VPS-setup-log&quot;&gt;&lt;a href=&quot;#new-VPS-setup-log&quot; class=&quot;headerlink&quot; title=&quot;new VPS setup log&quot;&gt;&lt;/a&gt;new VPS setup log&lt;/h1&gt;&lt;h2 id=&quot;新建用户&quot;&gt;&lt;a href=&quot;#新建用户&quot; class=&quot;headerlink&quot; title=&quot;新建用户&quot;&gt;&lt;/a&gt;新建用户&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;useradd -m 用户名
passwd 用户名
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;将该用户赋予root权限-利用sudo命令，需要输入密码&quot;&gt;&lt;a href=&quot;#将该用户赋予root权限-利用sudo命令，需要输入密码&quot; class=&quot;headerlink&quot; title=&quot;将该用户赋予root权限(利用sudo命令，需要输入密码)&quot;&gt;&lt;/a&gt;将该用户赋予root权限(利用sudo命令，需要输入密码)&lt;/h2&gt;&lt;p&gt;赋予文件读写权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod u+w /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开文件找到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root ALL = (ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户名 ALL = (ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取消读写权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod u-w /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.sheronw.xyz/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Non-parametric Tests笔记</title>
    <link href="https://blog.sheronw.xyz/2019/06/25/Non-parametric%20Tests/"/>
    <id>https://blog.sheronw.xyz/2019/06/25/Non-parametric Tests/</id>
    <published>2019-06-25T16:43:35.000Z</published>
    <updated>2019-10-06T18:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>ranking: make lowest value to be rank 1, seond lowest value to be rank 2… and then analysis</p><p>procedure: </p><ol><li>carry out the analysis in R</li><li>how to interpret</li><li>how to report the results</li></ol><a id="more"></a><h2 id="the-Wilcoxon-rank-sum-test-Mann-Whitney-test"><a href="#the-Wilcoxon-rank-sum-test-Mann-Whitney-test" class="headerlink" title="the Wilcoxon rank-sum test(Mann-Whitney test)"></a>the Wilcoxon rank-sum test(Mann-Whitney test)</h2><p><strong>comparing two independent conditions</strong></p><p>compares two conditions when different participants take part in each condition and the resulting data violate any assumption of the independent t-test</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将两组数据标上标签，然后放在一起排序。最小值为rank 1，第二小的为rank 2，然后以此类推……</p><p>注意，如果有多个值相同（tied scores），那他们的rank统一为potential rank的平均值。potential rank就是假设他们不同的话应该是什么rank。</p><p>然后再把相同组内的所有值的rank求和。</p><p>为了校正，各减去mean rank of the group，公式为N(N+1)/2。</p><p>（N为每个组的人数，其实这个就是等差数列1…N的和最后除以N）</p><p>以上的计算结果为test statistic，取较小的那个值（？存疑）</p><p>然后计算associated p-value，其实可以用monte carlo method，就是从整个样本里随机抽取出来一个组，然后再次计算，看看是否符合我们的结果（其实不应该，因为这种情况下null hypothesis is true）——不过这个要反反复复取样本计算，对大的数据来说很不友好。</p><p>另外一种方法是normal approximation。</p><p>该方法并不强求数据本身是成正态分布的，而是认为我们一次一次取样本计算的上述结果应该是成正态分布的。</p><p>我们可以算出标准差，然后算z，然后算p-value。</p><p>当然对R来说，如果你用这个方法算，它默认会加上一个continuity correction，因为正态分布本身是平滑曲线，但我们的数据分成了rank所以不是平滑的，因此校正之后会把你的p-value稍微拉高一点。</p><h3 id="calculating-effect-size"><a href="#calculating-effect-size" class="headerlink" title="calculating effect size"></a>calculating effect size</h3><p>r=z/sqrt(N)</p><p>在R中计算z-score的方法：qnorm(xxmodel$p.value/2)</p><p>if p-value&lt;0.05, then the two groups are significantly different</p><h2 id="the-Wilcoxon-signed-rank-test"><a href="#the-Wilcoxon-signed-rank-test" class="headerlink" title="the Wilcoxon signed-rank test"></a>the Wilcoxon signed-rank test</h2><p><strong>comparing two related conditions</strong></p><p>two set of scores, from the <strong>same</strong> participants, and the resulting data violate an assumption of the dependent t-test</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>对所有的数据：state 2 - state 1（如果差为0，那么直接筛掉该数据）</p><p>然后根据结果的绝对值的大小对数据进行rank分配，处理tied scores的方法相同</p><p>然后把数据分为差大于零和差小于零两种，求sum of positive ranks和sum of negative ranks</p><p>最终的test statistic为这两个结果里比较小的那个</p><p>然后计算significance of the test statistic（公式见课本p668下面），注意样本总数不算差为零的那几个</p><p>mean和standard error的计算方法见p670</p><p>计算effect size见p673</p><p>if p-value&lt;0.05, then the two groups are significantly different</p><h2 id="Kruskal-Wallis-test"><a href="#Kruskal-Wallis-test" class="headerlink" title="Kruskal-Wallis test"></a>Kruskal-Wallis test</h2><p><strong>comparing several conditions when different participants take part in each condition and the resulting data violate an assumption of one-way independent ANOVA</strong></p><p>和wilcoxon rank-sum类似，一开始先把各组数据放在一起排rank，然和把各组的rank求和。</p><p>各组的test statistic H有一个很复杂的公式，见p767最下面15.1</p><h4 id="post-hoc-test"><a href="#post-hoc-test" class="headerlink" title="post hoc test"></a>post hoc test</h4><p>对于所有可能的两两比较，都进行一次wilcoxon rank-sum test，公式见p681的15.2</p><p>R中的方法见p683</p><p>if p-value&lt;0.05, then the two groups are significantly different</p><h4 id="the-Jonckheere-Terpstra-test"><a href="#the-Jonckheere-Terpstra-test" class="headerlink" title="the Jonckheere-Terpstra test"></a>the Jonckheere-Terpstra test</h4><p>和Kruskal-Wallis test类似，只是包括了the order of the groups是否有意义的信息。</p><p>R中的方法见p685</p><h2 id="Friedman’s-test"><a href="#Friedman’s-test" class="headerlink" title="Friedman’s test"></a>Friedman’s test</h2><p><strong>differences between conditions when there are more than two conditions and the same participants have been used in all conditions(each case contributes several scores to the data)+violated an assumption of one-way repeated-measures ANOVA</strong></p><p>Friedman’s ANOVA</p><p>首先把不同的情况下的数据放在不同的列中，然后对<strong>每一行</strong>（也就是说每一个participants）中的列排rank（比如condition 2最小，那么它的rank是1，第二小的是condition 1，那么它的rank就是2……以此类推）</p><p>最后，将不同condition（也就是说每一列）的rank相加。test statistics F_r 的公式还是很复杂，见p689最上方</p><p>post hoc test的方法见p691的15.7.6.</p><p>if p-value&lt;0.05, then the two groups are significantly different</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ranking: make lowest value to be rank 1, seond lowest value to be rank 2… and then analysis&lt;/p&gt;
&lt;p&gt;procedure: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;carry out the analysis in R&lt;/li&gt;
&lt;li&gt;how to interpret&lt;/li&gt;
&lt;li&gt;how to report the results&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="研究相关" scheme="https://blog.sheronw.xyz/categories/%E7%A0%94%E7%A9%B6%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.sheronw.xyz/2019/06/23/hello-world/"/>
    <id>https://blog.sheronw.xyz/2019/06/23/hello-world/</id>
    <published>2019-06-23T17:47:20.000Z</published>
    <updated>2019-06-23T17:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my little new world.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to my little new world.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Privacy &amp; Human Behavior in the Age of Information笔记</title>
    <link href="https://blog.sheronw.xyz/2019/06/11/Privacy%20&amp;%20Human%20Behavior%20in%20the%20Age%20of%20Information/"/>
    <id>https://blog.sheronw.xyz/2019/06/11/Privacy &amp; Human Behavior in the Age of Information/</id>
    <published>2019-06-11T19:45:10.000Z</published>
    <updated>2019-08-17T13:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>论文原文出自SCIENCE VOL 347，以下为阅读笔记。</p><p>main content: empirical research on privacy behavior</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>背景：原本只是限于小圈子的、不可保留的内容如今都有迹可循，个人信息的收集与处理变得普遍。</p><p>一方面，不论是对公司还是对个人，信息的收集与处理都会带来许多方便，比如用医疗相关的大数据来研发更有效的药物；另一方面，个人信息的滥用可能会带来不可估量的影响，比如信息歧视、舆论操纵与监视等。</p><p>关于人们保护信息的能力与相关公共政策的讨论，如今有两种针锋相对的观点：第一种人认为人们能够根据自己的决策来保护好自己的信息隐私，过多的公共政策反而会干扰信息产业对人类带来的有益影响；另一种人认为，在日益复杂的信息世界中，人们很难权衡利弊、自行管理好自己的信息隐私，现有的一些工具已经不够用了，这个时候适当的公共政策与机构应该介入其中，从而抗衡商业团体和政府部门对于信息的收集与操纵。</p><p>本文试图探讨一些影响人们作出信息隐私决策的因素，以及这些决策是如何导致保护或者违反信息隐私安全的行为的。</p><a id="more"></a>  <p>探讨的因素主要有三个：</p><ul><li>人们在各种隐私权衡面前的不确定性，以及人们的偏好</li><li>由情境决定的隐私偏好——在不同的情况下，人们会做出不同的信息安全决策</li><li>信息隐私的偏好会受很多因素影响，因此具有一定的可塑性</li></ul><p>当然，这三个因素互相影响，就因为对隐私问题不够确定，所以人们倾向于从情境中寻找线索来作出决策，因此隐私偏好是由情境决定的；如果因此对情境加以干涉，那么人们的信息偏好也会受到影响，因此具有可塑性。</p><h3 id="Uncertainty"><a href="#Uncertainty" class="headerlink" title="Uncertainty"></a>Uncertainty</h3><p>人们会通过种种手段划定隐私与公开的界限，并且这种手段是自然发生的。不过，物理意义上的界限容易划分，但信息安全相关的边界具有模糊性，人们无法知道自己的信息安全是否、什么时候、被谁、在哪种程度上侵犯。</p><h4 id="信息不对称与不完整"><a href="#信息不对称与不完整" class="headerlink" title="信息不对称与不完整"></a>信息不对称与不完整</h4><p>造成这种不确定性的第一个因素是信息不对称与不完整。现代科技使信息的收集、处理变得用户不可见，人们对自己的信息被其他机构利用了多少这件事情毫无概念。</p><p>另外，人们想要判定自己的某种信息隐私相关的行为到底会造成哪些后果也很难。首先，一些信息安全隐患是无形的，比如人们可能不知道自己信息泄漏会给自己带来多少财产上的损失。其次，隐私是一把双刃剑，在损失它的同时，也会得到一些好处，例子就不提了。</p><p>如果将某种信息安全行为可能带来的损失与好处透明化（并且容易理解）的话，能够影响人们信息相关的决策。</p><h4 id="偏好"><a href="#偏好" class="headerlink" title="偏好"></a>偏好</h4><p>第二个因素是人们对于自己的偏好也有着不确定性。即使人们知道了自己的某种决策会对信息安全造成影响，他们也并不确定自己到底要不要这么做、或者这样好不好。相关研究发现其实人们对自己喜不喜欢某种商品或者服务、甚至人都没有一个明确的概念，更何况自己的隐私决策了。</p><p>首先，<strong>人们的态度与行为之间经常有着不确定性</strong>，即使人们有着对隐私警惕的态度，事实上也未必会做出相应的行为。</p><p>一种可能的解释方法是：广义上的「对隐私的态度」与狭义上的「相关的意图与行为」并不一定成正相关，人们可能这么想，但考虑到特定的情境并不会采取相应行为。但这个假说有一定问题——它无法解释一些态度与行为呈正相关的其他情况，并且没有考虑到错误估算利弊的情况。</p><p>其次，<strong>人们对于「用金钱来量化隐私」这件事也并不确定</strong>。当然了，在日常生活中，推断各种隐私行为的「估值」会受到各种各样的因素影响，尤其现在的情况是，信息分享相关的科技产品（比如各种社交媒体）发展比隐私保护的科技产品要发展得更好，以至于人们容易低估隐私相关的因素。</p><p>事实上，人们对隐私的估计可以具有诱导性，因此也未必可信。根据研究，人们只有得到隐私了之后才会珍惜，但要是没有这个东西就基本上也不会注意它了（。一些不法商家可能会这么诱导用户一开始就交出隐私，并且不再去考虑它</p><p>最后，其他的社会需求，比方说与别人分享、暴露自己的一些信息等，是会和隐私保护相矛盾的，而它们也同样重要。一方面适当的隐私让人安心，另一方面适当的暴露也让人安心，人类真是不好伺候（。</p><h3 id="Context-dependence"><a href="#Context-dependence" class="headerlink" title="Context-dependence"></a>Context-dependence</h3><p>正如前文所提到的那样，当人们不确定自己的偏好的时候，就会倾向于从情境中寻找线索，所以不同的情况下，人们对于隐私可能有着不同的考虑。并且，我们在很多情况下，对于「公共」和「隐私」的界限也并不明确——虽然大部分时间只会把秘密告诉自己关系最近的人，但有的时候却只和陌生人说。</p><h4 id="Sensible-Behavior"><a href="#Sensible-Behavior" class="headerlink" title="Sensible Behavior"></a>Sensible Behavior</h4><p>人们对于隐私的判断有时是「合情合理」的，比如当政府出台了相应法规之后，人们会更加容易信任各种收集信息的机构。不过，这种线索也会有坏处，有些时候人们在某种特定环境下可能会无意识地交出自己的隐私。</p><h4 id="Culture-and-Behavior-of-Other-People"><a href="#Culture-and-Behavior-of-Other-People" class="headerlink" title="Culture and Behavior of Other People"></a>Culture and Behavior of Other People</h4><p>两种方式：descriptive norms or via reciprocity</p><p>当周围的人都暴露自己的信息的时候，人们会更倾向于随大流也这么做；当对方暴露了一些信息的时候，人们也会随之暴露相应的信息（尽管对方可能只是个AI）。这也是网络上为什么那么多人公开自己信息的原因。</p><p>另外，他人对于信息的态度也会影响到自己的隐私，因为一旦你将某种信息告诉别人，他/她就会和你共同拥有该信息，这就更加模糊了隐私和公开的边界。</p><p>同样地，对于隐私的考虑也会与经验有关，比如看到监控摄像头就会本能地感到警惕。但同时它也是有适应性的——要是监控摄像头天天都放在那里，那人们也会逐渐放松警惕。因此人们可能会逐渐习惯信息时代带来的隐私侵犯。</p><p> 因为信息时代隐私的界限逐渐模糊，所以区分线上线下、满足每一个人对自己的预期越来越困难，我们不再能够精确地控制住自己发布的信息的目标群众，这也会带来一些关于当代信息科技的一些担忧。</p><h3 id="Malleability-and-Influence"><a href="#Malleability-and-Influence" class="headerlink" title="Malleability and Influence"></a>Malleability and Influence</h3><p>就因为大部分人并没有意识到自己的隐私抉择与情境相关，但很多机构和组织注意到了，所以信息收集与利用成了一个巨大的产业（。他们会利用人们隐私倾向的可塑性来（诱导）交出数据。</p><h4 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h4><p>人们一般都不会改自己的默认设置，而且倾向于认为默认设置是系统推荐的最优解。因此如果社交媒体默认公开信息，那人们也会更有可能公开自己的信息。</p><h4 id="诱导用户公开信息"><a href="#诱导用户公开信息" class="headerlink" title="诱导用户公开信息"></a>诱导用户公开信息</h4><p>比如有诱导性的用户界面。或者在收集信息的时候并不会发出警告，即使发出警告了也会顺便搞点光顾什么的让人们对警告本身印象不太好。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>有的时候，只需要一点点干预赢得用户的信任，他们就会对信息安全的警惕性放松，比如公布一个消费者并不会仔细看的隐私保护政策，用户就会「放心地」将数据交给第三方。</p><h4 id="可控性"><a href="#可控性" class="headerlink" title="可控性"></a>可控性</h4><p>基本上所有的相关产品都会让用户可以控制自己信息的公开范围，而且一般认为这是一个保护用户隐私的必备措施。然而将决定权交给用户有时会产生反作用。研究发现当用户在信息公开范围中有更多的选择时，他们反而会倾向于公开更多的信息。</p><h4 id="信息透明化"><a href="#信息透明化" class="headerlink" title="信息透明化"></a>信息透明化</h4><p>和可控性类似，它一般也被认为对保护用户的隐私有利，但事实上却成了鸡肋。毕竟没有几个用户会真的阅读条款，并且弄明白那些网站和服务是如何收集并且利用自己的数据的。更何况即使想要读，也很难弄懂，反而是浪费时间。</p><p>不过，之前用「诱导」这个词好像算贬义，但不是所有的可塑性与可操作性都是负面的。然而如果使用得当，可塑性可以对社会有着积极的影响，比如让用户感知到被监视能够让用户无意识地做出更有利于社会的行为。相同地，网络带来的去人格化也能够用来收集准确性更高的公共数据（比如人们在实名状态下不太愿意透露的数据）。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>在不同的文化中，关于隐私的共识和行为是不同的；然而，不论在哪种文化中，如何控制隐私与公开的界限是每一个人都需要注意的，而这个问题在信息时代更加重要（控制这个的能力已经超出了我们的生理极限）。</p><p>论公共政策能够起到什么作用？</p><p>根据研究发现，单纯地「通知」或者「赋予」用户隐私相关的权力，已经不能提供足够的保护了。尤其是「控制」和「不透明度」，事实上效果并没有那么好，甚至还有反作用。</p><p>如果想要最大程度上保护用户的隐私，很遗憾地，就要让用户做尽可能少的理性决定，也就是说需要一套保护相关的基本准则，来协助用户在当前的信息环境下做出抉择，力图实现用户、公民与公司、信息持有者之间的权力对等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文原文出自SCIENCE VOL 347，以下为阅读笔记。&lt;/p&gt;
&lt;p&gt;main content: empirical research on privacy behavior&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;背景：原本只是限于小圈子的、不可保留的内容如今都有迹可循，个人信息的收集与处理变得普遍。&lt;/p&gt;
&lt;p&gt;一方面，不论是对公司还是对个人，信息的收集与处理都会带来许多方便，比如用医疗相关的大数据来研发更有效的药物；另一方面，个人信息的滥用可能会带来不可估量的影响，比如信息歧视、舆论操纵与监视等。&lt;/p&gt;
&lt;p&gt;关于人们保护信息的能力与相关公共政策的讨论，如今有两种针锋相对的观点：第一种人认为人们能够根据自己的决策来保护好自己的信息隐私，过多的公共政策反而会干扰信息产业对人类带来的有益影响；另一种人认为，在日益复杂的信息世界中，人们很难权衡利弊、自行管理好自己的信息隐私，现有的一些工具已经不够用了，这个时候适当的公共政策与机构应该介入其中，从而抗衡商业团体和政府部门对于信息的收集与操纵。&lt;/p&gt;
&lt;p&gt;本文试图探讨一些影响人们作出信息隐私决策的因素，以及这些决策是如何导致保护或者违反信息隐私安全的行为的。&lt;/p&gt;
    
    </summary>
    
      <category term="研究笔记" scheme="https://blog.sheronw.xyz/categories/%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 7 User-Centered Design</title>
    <link href="https://blog.sheronw.xyz/2019/06/09/7%20User-Centered%20Design/"/>
    <id>https://blog.sheronw.xyz/2019/06/09/7 User-Centered Design/</id>
    <published>2019-06-09T14:25:17.000Z</published>
    <updated>2019-08-17T22:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章节总结全书观点。以用户为中心的设计，也是作者一直在提倡的。</p><p>好的设计应该：</p><ul><li>让用户能够确定可以执行哪些操作</li><li>让所有的东西（概念模型与反馈etc.）可见</li><li>让状态易于评估</li><li>使用自然映射（意图与行为之间、动作与结果之间、可见信息与状态的解释之间……）</li></ul><p>太长不看版：让用户知道可以做什么、然后做这个行为之后发生了什么。</p><p>应该利用好那些自然特性和限制，让人易于学习并理解。</p><a id="more"></a><h2 id="七个化繁为简的准则"><a href="#七个化繁为简的准则" class="headerlink" title="七个化繁为简的准则"></a>七个化繁为简的准则</h2><h3 id="1-同时利用世界中的知识与头脑中的知识"><a href="#1-同时利用世界中的知识与头脑中的知识" class="headerlink" title="1. 同时利用世界中的知识与头脑中的知识"></a>1. 同时利用世界中的知识与头脑中的知识</h3><p>当外部世界又足够的提示信息时，有利于用户更好地使用产品。这些外部信息是需要与头脑中的知识相对应，并形成自然映射的。</p><p>但是有一点需要注意：一些人对于某些产品拥有更多头脑中的知识，因此不能让过多的外部信息干扰了他们的使用。</p><p>三种概念模型：用户模型、设计者模型、系统映像</p><h4 id="用户手册的作用"><a href="#用户手册的作用" class="headerlink" title="用户手册的作用"></a>用户手册的作用</h4><p>系统映像：instruction manuals + documentation + interface</p><p>现实中，手册都是设计者设计完成、拼死累活之后随便写的，时间也不够。</p><p>但在理想状态下，应该先开始写用户手册，再一边设计一边修改用户手册，并不断找人模拟测试。当然，大多数人都很懒，即使用户手册再好也未必会看，所以还是把重点放在交互界面上吧。</p><h3 id="2-简化任务结构"><a href="#2-简化任务结构" class="headerlink" title="2.简化任务结构"></a>2.简化任务结构</h3><p>从心理学的角度来讲，人类的限制：</p><p>短期记忆（STM）：人的短期记忆很弱（顶多五件东西），所以如有必要，应添加一些可以辅助记忆的外部功能。</p><p>长期记忆（LTM）：为了让人记得更牢固，知识最好是有联系、能够用逻辑来解释的。还有就是人类的长期记忆可能并不准确，这个时候外部世界存在的信息就十分有必要了。</p><p>关于技术给任务结构带来的简化，作者的建议如下：</p><h4 id="1）不改变任务流程本身，只提供心智上的辅助"><a href="#1）不改变任务流程本身，只提供心智上的辅助" class="headerlink" title="1）不改变任务流程本身，只提供心智上的辅助"></a>1）不改变任务流程本身，只提供心智上的辅助</h4><p>从某种程度上来说，许多手机内置的app都算，比如闹钟日历记事本提醒事项……</p><h4 id="2）利用科技进行可视化，进而更好地得到反馈、加强控制"><a href="#2）利用科技进行可视化，进而更好地得到反馈、加强控制" class="headerlink" title="2）利用科技进行可视化，进而更好地得到反馈、加强控制"></a>2）利用科技进行可视化，进而更好地得到反馈、加强控制</h4><p>举个例子吧，显示器。还有近几年很是火热的数据可视化，无数个软件的所谓dashboard（听说阿里云把这个翻译成大盘，想想各种什么大阳线3K线也是这种应用吧hhh）</p><p>以上两种建议都没有改变任务本身，只是在执行层和评估层添加了辅助。虽然有人认为过多的辅助会让人失去相应能力，但作者认为可以把时间用来做更高层的创意工作。</p><h4 id="3）保持任务本身不变，但自动化"><a href="#3）保持任务本身不变，但自动化" class="headerlink" title="3）保持任务本身不变，但自动化"></a>3）保持任务本身不变，但自动化</h4><p>自动化本身有争议：一方面，它能够将人们从繁琐的细节中解放出来，减少精神负担；另一方面，自动化让人在某些方面失去了对产品本身的控制。</p><p>平衡好这两方面很困难。最好的解决方案是让用户自行抉择（类似于上一章讲到的两个不同的系统）。</p><h4 id="4）改变任务的本质"><a href="#4）改变任务的本质" class="headerlink" title="4）改变任务的本质"></a>4）改变任务的本质</h4><p>from deep wide structure to shallow narrow structure</p><p>比如电子表，该变了原本圆盘与指针的基本结构，直接显示用数字表示的时间。</p><h4 id="5）不要过度自动化而造成“失控”"><a href="#5）不要过度自动化而造成“失控”" class="headerlink" title="5）不要过度自动化而造成“失控”"></a>5）不要过度自动化而造成“失控”</h4><p>过度自动化的坏处：</p><ol><li>让人缺少相关的能力，一旦自动化失灵，用户就会不知所措，这在一些情况下是致命的，比如飞机自动驾驶</li><li>有的时候默认的自动化配置并不是用户所需的，而他们也无能为力</li><li>人类沦为机器的奴隶，无法控制全局</li></ol><p>控制分为比较低层的控制（事无巨细的那种，比如用笔画画、手作家具）与较高层的控制（电脑命令行），各有不同的用途。</p><h3 id="3-让事情可视化，从而弥补执行与评估之间的陷阱"><a href="#3-让事情可视化，从而弥补执行与评估之间的陷阱" class="headerlink" title="3. 让事情可视化，从而弥补执行与评估之间的陷阱"></a>3. 让事情可视化，从而弥补执行与评估之间的陷阱</h3><p>符合意图：让人知道该做什么</p><p>符合预期：让人知道有什么效果</p><h3 id="4-正确的映射"><a href="#4-正确的映射" class="headerlink" title="4. 正确的映射"></a>4. 正确的映射</h3><ul><li>意图与行为之间</li><li>行为与效果之间</li><li>系统的真实状态与交互界面（视觉听觉触觉等）之间</li><li>实际状态与用户意图之间</li></ul><p>控制的顺序、位置或者动作的方向，与操作之间有着可以类比的自然关系。</p><p>行为的反馈与用户的预期之间也有这类似的联系，让反馈易于理解，进而促进用户的评估。</p><p>比如图表（还是可视化）。</p><h3 id="5-利用（自然与人工）限制的力量"><a href="#5-利用（自然与人工）限制的力量" class="headerlink" title="5. 利用（自然与人工）限制的力量"></a>5. 利用（自然与人工）限制的力量</h3><p>从而减少可能的操作数量</p><h3 id="6-关注易错性的设计"><a href="#6-关注易错性的设计" class="headerlink" title="6. 关注易错性的设计"></a>6. 关注易错性的设计</h3><ul><li>考虑到可能会发生的错误</li><li>将错误当作「朝向正确操作的尝试」并试图补救</li><li>加入能够撤销的机制</li><li>可探索系统</li><li>利用好forcing fuctions</li></ul><h3 id="7-要是别的都不行，就标准化"><a href="#7-要是别的都不行，就标准化" class="headerlink" title="7. 要是别的都不行，就标准化"></a>7. 要是别的都不行，就标准化</h3><p>将行为、结果、布局、显示统统标准化，最好是搞一个国际标准，比如国际标准时间、国际标准历法、键盘etc.</p><p>标准化的时机很重要：太早，技术不成熟，之后会造成很多麻烦；太晚，不同的系统还要相互兼并，到底把哪一个作为统一标准的母板也很难有定论。</p><p>科技与标准往往是相互需要的（比如汽车 电脑）</p><p>标准渐渐地会成为文化限制的一部分</p><h2 id="刻意将任务变难"><a href="#刻意将任务变难" class="headerlink" title="刻意将任务变难"></a>刻意将任务变难</h2><p>不是所有的产品都一定要讲究易用性，有些产品就是要设定一定的门槛。</p><p>比如危险器械、暗门、儿童会误触的东西等。</p><p>当然，任务说是要变难，但也没必要把每一个环节都变难。只需要把刚好想要隔绝的人群挡住就好。</p><p>具体如何操作，可以从逆向角度使用之前总结的「提高产品易用性」的要点：</p><ul><li>让东西不可见</li><li>使用不自然的映射</li><li>让动作对于某一类群体难以做到</li><li>需要精确的时间把控和操作</li><li>不提供反馈</li><li>在评估环节提供不自然的映射</li></ul><p>不过有时，这些设计也会带来副作用。比如防止儿童跑出门去玩的门，可能在火灾的时候就成为了障碍——正确的方法也许是，提供一个可以开门的按钮，但开的时候会引发警报。</p><p>设计游戏也需要将任务变难，但要平衡好以下几个要素：挑战（challenge）、享受（enjoyment）、崩溃（frustration）、好奇（curiosity）。</p><p>还有一个有趣的现象是，「看起来简单的产品用起来不一定简单」。这很容易理解，和<strong>可控部分的数量</strong>与<strong>可执行的操作数量</strong>有关。</p><p>一个产品要是看起来简单，那么操作在很大程度上都要交给用户，因此需要长久的学习。</p><p>（一个引战的话题：钢琴可以弹的键很多，小提琴就四根弦，但入门的话，小提琴要更难一点？）</p><p>在可执行操作的总数相同的情况下，当控制越少，单个控制就要承载越多的功能——一个控制对应一个可执行操作是最易于用户理解的。</p><p>可是按钮太多了该怎么办？</p><p>要么分组，让用户更好地理解；要么将平时不用的控制隐藏，有需要的话再调用（比如在不常用的按键上方安置一个挡板）。</p><h2 id="设计与社会"><a href="#设计与社会" class="headerlink" title="设计与社会"></a>设计与社会</h2><p>日常的几乎所有物件，都会对我们的生活有着深切的影响，并且这个影响是很难在一开始就预测到的。</p><p>题外话：科技的快速发展是否与外部记忆设备的扩展有关？这样人们可以将更少的时间用来记忆（尤其是抽象化、原本无法在外部世界留下信息的内容），因为有需要就去找就行了。</p><p>设计与政治有关。至少在西方资本主义社会，一个设计的好坏与市场需求有着紧密联系。生产者需要创造人们想要买的需求。因此易用性有时反而并不是排在第一位的。</p><p>有的时候，产品难用并非因为这个东西本身就很难，只是他们的逻辑、映射等毫无规律可言，或者对操作精度的要求过高——这些问题都可以通过恰当的设计来解决。</p><p>设计者还应该建立正确的防范错误的机制，减少错误操作，或者让它们可被弥补，并且有错误反馈。（利用好各种限制、forcing functions、可视化）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节总结全书观点。以用户为中心的设计，也是作者一直在提倡的。&lt;/p&gt;
&lt;p&gt;好的设计应该：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让用户能够确定可以执行哪些操作&lt;/li&gt;
&lt;li&gt;让所有的东西（概念模型与反馈etc.）可见&lt;/li&gt;
&lt;li&gt;让状态易于评估&lt;/li&gt;
&lt;li&gt;使用自然映射（意图与行为之间、动作与结果之间、可见信息与状态的解释之间……）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;太长不看版：让用户知道可以做什么、然后做这个行为之后发生了什么。&lt;/p&gt;
&lt;p&gt;应该利用好那些自然特性和限制，让人易于学习并理解。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 6 The Design Challenge</title>
    <link href="https://blog.sheronw.xyz/2019/06/06/6%20The%20Design%20Challenge/"/>
    <id>https://blog.sheronw.xyz/2019/06/06/6 The Design Challenge/</id>
    <published>2019-06-07T00:31:47.000Z</published>
    <updated>2019-08-17T22:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计的自然演进"><a href="#设计的自然演进" class="headerlink" title="设计的自然演进"></a>设计的自然演进</h2><p>工匠在每一次制造物品时，都会添加一些用来测试的新功能，再去掉一些用户认为不好的功能。日常的物件就在这种一代一代的缓慢演化中，变成了美感与功能兼具的产品。（hilling-climbing）</p><h3 id="演进式设计的反作用力"><a href="#演进式设计的反作用力" class="headerlink" title="演进式设计的反作用力"></a>演进式设计的反作用力</h3><p>虽然道理是这样没错，但正如你所见，自然演化的速度是十分缓慢的。</p><p>现代的市场环境已经不允许这种工匠式的缓慢改进了，更何况现代的产品组成也十分复杂。</p><p>其中一个反作用力是产品演进速度的加快——各大厂商的手机、电脑每年都会至少出一个新型号，软件更是动不动就更新。而用户的反馈也没有那么易于收集（旧时的工匠与顾客都是面交，而现在光经销商就隔了好几层）。更早搞得是，很多公司在某个型号还没有进入市场的时候，就开始准备设计更新的（加入了一些炫酷功能的）型号了，连新的用户反馈都没有。</p><a id="more"></a><p>另一个尴尬的反作用力是，在市场竞争条件下，每个不同的产品都要追求「独特性」。但「独特性」要从哪里体现呢？假定在理想状况下有一个完美的产品，属于某个公司。其他的公司要是也效仿，就失去了所谓的「独特性」，要是增添或删改一些功能，可能产品会变得更糟。</p><p>发现了一个有趣的矛盾：有的时候，垄断的企业反而更有利于保持产品的水准。一来所有的该产业的高端人才都会聚集到这个公司来，而来产品可以有一个类似于自然演化的理想过程。（吹爆贝尔电话公司hhh）</p><p>当然这也可能是苹果只出一款iphone手机从而从一众厂商中间脱颖而出的原因？但这个真的很难预料，至少在我小的时候，我觉得男生和女生应该用不同的手机，不同年纪的人也应该用不同的手机……</p><h4 id="关于键盘"><a href="#关于键盘" class="headerlink" title="关于键盘"></a>关于键盘</h4><p>虽然之后也有更加高效的方案，但考虑到几百万人的学习成本，以及几百万台亟待更新的设备，任何所谓更新更好的方案都不了了之了。</p><p>所以，不要妄图挑战任何已经十分成熟了的解决方案，除非切换成本与学习成本都很低（比如从刷个信用卡变成刷个手机二维码）。</p><p>或者说，很难在创始人着一代就达到与其他自然演进了很多代的产品相抗衡，可能这就是成功者脚下的铺路石吧，俗称奠基人。</p><h2 id="设计者为什么走了弯路"><a href="#设计者为什么走了弯路" class="headerlink" title="设计者为什么走了弯路"></a>设计者为什么走了弯路</h2><h3 id="颜值即正义"><a href="#颜值即正义" class="headerlink" title="颜值即正义"></a>颜值即正义</h3><p>过于追求美学上的高度，往往会损失产品的易用性，参考各种号称是极简主义但让人一头雾水的东西。</p><p>作者的举例：两个FAA的办公楼，西雅图的由员工自己设计，洛杉矶的由建筑师设计。洛杉矶的得了奖，而真正让员工的效率和满意度提升的反而是西雅图的办公楼。</p><p>当然，在一些极端情况下，降低易用性也是设计者的目的，比如快餐店的桌椅。</p><p>一些公共教育设施（比如科技馆）的重点应该是让大众理解展品，并能够学到东西，而不是单纯摆在那里好看。</p><h3 id="设计者并非主流用户"><a href="#设计者并非主流用户" class="headerlink" title="设计者并非主流用户"></a>设计者并非主流用户</h3><p>想起之前忘了在哪里看到的文章：「一个好的产品经理能够一分钟之内变成任何用户。」</p><p>再就是一类叫做小众软件的东西，虽然好用，但使用门槛极高。比如文档转换软件pandoc连个GUI都没有，纯命令行简直劝退。</p><p>还有个更贴切的例子出自日剧「RMPW」，栗子给社保设计登录界面，初稿是个十分炫酷十分GEEK的罗盘，结果十元妹子不会用。栗子起初觉得十元太笨了，但我忘了后来发生了啥总之有了十元也会用的第二版，好像是个图片密码登录并且选项很直观的那种。毕竟社保帐号人人都有，门槛不能太高嘛。</p><p>还有个可以说的是国民app微信和淘宝。</p><p>回到正题。首先，「设计出一个产品」的设计者与「熟练使用产品」的用户，所需要的知识是不一样的——设计者要对内部结构了如指掌，而用户得知道如何使用交互界面。这本应该是设计师的基本常识，然而现在更多的产品是由工程师、程序员或者经理所设计的，他们对于内部结构了如指掌，但往往在为用户考虑时，十分努力地去优化内部结构，而不是去让用户能够看到的交互界面更加易用。</p><p>还有一个问题是，设计者在设计的过程中对产品过于了解，许多基本操作都已经成为潜意识的一部分了，很难从头像用户一样去考虑产品的易用性。（论各种测试的重要性）</p><h3 id="设计者的客户未必是用户"><a href="#设计者的客户未必是用户" class="headerlink" title="设计者的客户未必是用户"></a>设计者的客户未必是用户</h3><p>家具的预装修由开发商处理，大学的各项器材和文具也有专门的采购部门……对于客户来说，易用性并不是放在第一位的，价格和维护成本才是。因为有这样的市场需求，所以低价但易用性差的产品大行其道。</p><p>更糟的是，正因为与设计师们打交道的是客户而不是用户，用户的反馈无法传达给设计师，进而造成了恶性循环；哪怕退一万步，能够传达到，设计师应该听客户的还是听用户的？</p><h2 id="设计流程的复杂性"><a href="#设计流程的复杂性" class="headerlink" title="设计流程的复杂性"></a>设计流程的复杂性</h2><p>我不是在说工匠精神，但很多日常的小物件都并不简单。比如我现在正在用的钢笔，笔杆要不粗不细让大多数人都用着顺手，虽然没有笔帽夹，但在笔帽的边缘的某个棱角处有一个小的突起——我的猜测是，能够让人单手就打开笔盖……诸如此类的细节，总要由那么一个人考虑到，然后想办法证明其意义，再添加到生产线上。</p><h3 id="为特殊人群考虑的设计"><a href="#为特殊人群考虑的设计" class="headerlink" title="为特殊人群考虑的设计"></a>为特殊人群考虑的设计</h3><p>Physical Anthropometry</p><p>一般来说，许多产品都是为「一般人」而设计的，比如桌椅的尺寸，屏幕的大小等等。可是即使这样，还有一部分人无法使用。首先，可调节的设备可以解决一部分问题，比如座椅的高度和椅背的角度。其次，为了让尽可能多的人使用，我们可以找到统计学意义上的平均值作为默认的参考模型。</p><p>可是对于某些人群，比如左撇子，盲人来说，「平均」与「可调节」都不足以解决问题，他们需要特别的产品。</p><p>还有一个不可忽视的群体是老年人，一个人在二十多岁的时候身体就开始走下坡路了，而我们都会不可避免地走向衰老。不仅如此，随着人类寿命的延长，一个人可能会有三四十年的所谓「老年期」，而许多产品都没有考虑到这一数量庞大的群体。</p><h3 id="Selective-Attention"><a href="#Selective-Attention" class="headerlink" title="Selective Attention"></a>Selective Attention</h3><p>人在做某些事情，尤其是在紧急情况下的时候，注意力往往是有限的，甚至无法顾及到许多「显而易见」的错误或隐患。设计者应该考虑到这些情况，并且用上一章提到的规避错误的方法来预防这些错误。</p><h2 id="设计者的两种错误尝试"><a href="#设计者的两种错误尝试" class="headerlink" title="设计者的两种错误尝试"></a>设计者的两种错误尝试</h2><h3 id="creeping-featurism"><a href="#creeping-featurism" class="headerlink" title="creeping featurism"></a>creeping featurism</h3><p>指将各种各样能加入的功能都加到产品中。加入的功能越多，就越难以满足之前说过的好的设计的特性，而使用时的复杂程度也会随之倍增。</p><p>第一种解决方案类似于奥卡姆的剃刀，不必要的功能就不添加，但的确也会损失一些用户可能的确会用到的功能。</p><p>第二种解决方案是模块化，将不同的功能分组，每组都有其功能与限制。</p><h3 id="the-worshipping-of-false-images"><a href="#the-worshipping-of-false-images" class="headerlink" title="the worshipping of false images"></a>the worshipping of false images</h3><p>许多律师事务所的门口都会放一台最新型号的、功能最多的打印机，但不一定用，只是用来装逼，展现给客户一种高端人才掌握核心科技的节奏。</p><p>人家装逼，我当然是没意见了，只是要是所有人都把「复杂就是高端」奉为圭臬的话，就会忽视产品在易用性方面可能的提升，放任很多乱七八糟的功能拼凑在一起冒充「高端」。</p><h2 id="电脑操作系统的缺点"><a href="#电脑操作系统的缺点" class="headerlink" title="电脑操作系统的缺点"></a>电脑操作系统的缺点</h2><p>至少在那个年代，电脑为什么难用：</p><p>电脑是个新鲜事物，设计师并没有介入该领域，而程序员和工程师又缺少为用户设计的经验。</p><p>电脑作为一个纯人造的产品，高度抽象，缺少自然情况下的反馈。</p><p>操作系统为什么饱受诟病：</p><ul><li>不可见：执行和评估环节中许多陷阱</li><li>任意性：许多操作都是人为规定，缺少映射的</li><li>不一致性：不同的地方执行相同的操作反而需要不同的指令</li><li>不智能性：让人摸不着头脑的缩写和报错之类的</li><li>不友善：动不动就是冷冰冰的警告</li><li>操作危险：一个小错误就可能造成重大损失</li></ul><p>当然，在作者的年代，想要制造一台符合所有设计理念的设备，在技术层面也达不到，成本也很高，而且学校里也缺乏相关的课程。</p><h2 id="操作系统的灵活性"><a href="#操作系统的灵活性" class="headerlink" title="操作系统的灵活性"></a>操作系统的灵活性</h2><p>不同于以往提到过的所有物件，操作系统是没有形体的，作者提供了几个能够提升其易用性的建议：</p><h3 id="可探索系统"><a href="#可探索系统" class="headerlink" title="可探索系统"></a>可探索系统</h3><p>类似于打开新的app或者网页甚至游戏时出现的「向导」与「帮助」功能。作者人为操作系统应该像日常的物件那样通过探索来学习。</p><p>首先，所有的可执行操作应该是可见的；其次，操作后应该又相应的反馈，并且易于理解，还要正确地反映系统映像；而且，（对于电脑来说尤其重要，）试错的成本应该尽可能地低，至少错误的操作是可撤销的。</p><h3 id="两种不同的系统"><a href="#两种不同的系统" class="headerlink" title="两种不同的系统"></a>两种不同的系统</h3><p>我们现在用的电脑有两种系统，一种是门槛极高的命令行（command mode），另一种是图形界面（direct mannipulation mode）。它们各有其使用场景。</p><p>command mode难以学习，不直观，但可以批量工作，执行一些我自己不想做的枯燥工作。</p><p>而direct manipulation虽然好操作，能够忘记「电脑」这一中介而进行一些创造性工作，但能做的事情因人而异——毕竟给我一个数位板我也画不出本子来啊。</p><h3 id="操作的无形化"><a href="#操作的无形化" class="headerlink" title="操作的无形化"></a>操作的无形化</h3><p>物联网、谷歌语音助手etc.</p><p>作者真的是神预言</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计的自然演进&quot;&gt;&lt;a href=&quot;#设计的自然演进&quot; class=&quot;headerlink&quot; title=&quot;设计的自然演进&quot;&gt;&lt;/a&gt;设计的自然演进&lt;/h2&gt;&lt;p&gt;工匠在每一次制造物品时，都会添加一些用来测试的新功能，再去掉一些用户认为不好的功能。日常的物件就在这种一代一代的缓慢演化中，变成了美感与功能兼具的产品。（hilling-climbing）&lt;/p&gt;
&lt;h3 id=&quot;演进式设计的反作用力&quot;&gt;&lt;a href=&quot;#演进式设计的反作用力&quot; class=&quot;headerlink&quot; title=&quot;演进式设计的反作用力&quot;&gt;&lt;/a&gt;演进式设计的反作用力&lt;/h3&gt;&lt;p&gt;虽然道理是这样没错，但正如你所见，自然演化的速度是十分缓慢的。&lt;/p&gt;
&lt;p&gt;现代的市场环境已经不允许这种工匠式的缓慢改进了，更何况现代的产品组成也十分复杂。&lt;/p&gt;
&lt;p&gt;其中一个反作用力是产品演进速度的加快——各大厂商的手机、电脑每年都会至少出一个新型号，软件更是动不动就更新。而用户的反馈也没有那么易于收集（旧时的工匠与顾客都是面交，而现在光经销商就隔了好几层）。更早搞得是，很多公司在某个型号还没有进入市场的时候，就开始准备设计更新的（加入了一些炫酷功能的）型号了，连新的用户反馈都没有。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 5 To Err Is Human</title>
    <link href="https://blog.sheronw.xyz/2019/06/03/5%20To%20Err%20Is%20Human/"/>
    <id>https://blog.sheronw.xyz/2019/06/03/5 To Err Is Human/</id>
    <published>2019-06-04T00:31:47.000Z</published>
    <updated>2019-08-17T22:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Error分为两种，一种是无意识行为的slips，还有一种是有意识行为的mistakes</p><h2 id="任务的结构"><a href="#任务的结构" class="headerlink" title="任务的结构"></a>任务的结构</h2><p>从两个维度来看：横向与纵向</p><h3 id="深度与广度兼具的结构"><a href="#深度与广度兼具的结构" class="headerlink" title="深度与广度兼具的结构"></a>深度与广度兼具的结构</h3><p>比如棋类游戏，每一步都有很多可能，而且要走很多步，基本上决策树要画到累死的那种。</p><p>对于大多数人来说，这种任务十分艰难（还是交给人工智能好了），至少日常生活中不怎么会用到。</p><a id="more"></a><h3 id="浅层结构"><a href="#浅层结构" class="headerlink" title="浅层结构"></a>浅层结构</h3><p>一般是指有很多选择，但并不需要做出很多个决策的那种任务。</p><p>比如从一堆冰淇淋里面选出自己想要的三个球。</p><p>我们只需要在每一个决策中将不同的选项区分开来，大部分人都不会觉得很困难。</p><h3 id="狭窄结构"><a href="#狭窄结构" class="headerlink" title="狭窄结构"></a>狭窄结构</h3><p>正好反过来，有很多个需要做的子任务，但每一个子任务都很简单。</p><p>（这不就是二叉树嘛）</p><p>比如菜谱，做一道菜有很多个步骤，但每一个步骤都并不是特别复杂（一般来讲）。</p><p>（浅层结构和狭窄结构可以互相转换，比如遍历一边浅层结构的所有选项然后选择要还是不要hhh）</p><p>一个应用是高速公路上的路标设计，为了让司机不晕头转向，一般相关的信息会一点一点出现在出口之前（比如1km提醒一次，500m再提醒一次），并且不会一下子把所有的出口信息都列在一起。</p><p>（虽然现在可能用导航软件的比看路标的人多，但导航软件的语音提示也应该是遵循这种规则吧）</p><h3 id="日常任务的本质"><a href="#日常任务的本质" class="headerlink" title="日常任务的本质"></a>日常任务的本质</h3><p>日常生活中要做的事情一般都是浅层结构或者是狭窄结构，毕竟大家都希望把自己的精力用来做一些非日常的复杂任务上嘛。</p><h2 id="有意识与无意识的行为"><a href="#有意识与无意识的行为" class="headerlink" title="有意识与无意识的行为"></a>有意识与无意识的行为</h2><p>（这本书成书比较早，现在肯定有许多关于意识的更深层次的研究）</p><p>关于无意识：很多都是从过去的经验中得来的，不需要仔细思考就能够做的事情。但坏处是可能会有偏见（因为所有的行为都是基于之前得到的信息或者经验）</p><p>相对应的是有意识的行为，特点是又慢又累。不管是比较、类比、解释还是逻辑、数学、决策论，都是用来进行有意识行为的工具。</p><p>（感觉之前那本畅销书「思考，快与慢」里面说的系统1系统2就是指的这俩）</p><p>当然，这两种行为对人类来说都很重要，并不是无意识行为比有意识的low。在很多情况下，它们是互相促进的。</p><p>一般来说，人类需要短期记忆来帮助自己做有意识的行为，但人的短期记忆储存量很小，一般也就是五六样东西吧。但是如果找出它们之间的联系，通过类比、推理等将它们梳理成一个结构，就可以记住了。因此理解和解释可以超越人类的记忆极限，让我们记住海量的内容，所以对我们的各种行为非常重要。</p><p>所以我们可以找出mistake的产生原因：错配；将当今发生的情况错误地与过去的连系在一起。</p><p>大部分人都是事后诸葛亮：当事故发生+知道结果之后，人们很容易会作出合理的解释；但事故发生+不知道结果时，人们作出的解释虽然自洽但经常是错误的。这也是为什么重大事故发生的时候总是错误连着错误，而操作人员总是意识不到；而事故发生之后，调查人员总会对于错误的显而易见而迷惑。</p><p>另外就是，社会压力也会造成一些错误。人们总是会在社会压力之下作出一些无可奈何的决策：比如天气不好的时候，要是取消航班，不仅公司损失钱，乘客也不高兴；要是不取消的话，其实大多数情况下还是不会有什么事的，但一万里面要是出了个万一，那就真的出事了。</p><h2 id="关注容错性的设计"><a href="#关注容错性的设计" class="headerlink" title="关注容错性的设计"></a>关注容错性的设计</h2><p>再熟练的人也会犯错误。为此，我们要针对可能发生的错误行为作出相应的设计。</p><p>有几个观点可以参考：</p><ol><li>尽可能将错误行为的损失降到最小</li><li>让错误的行为可撤销</li><li>让任何错误行为的后果容易发现，从而尽可能地进行补救</li><li>转换态度，不是所有的错误行为都是无可救药的，可以将它看作「不够完美的近似性尝试」</li></ol><p>另外，有的时候人们犯错误，仅仅是因为产品的设计还不够好，外部信息还不够明确，或者有误导性。</p><p>作者提出了一个叫做forcing function的概念，用来减少人们犯错的可能性。</p><p>forcing function的运行机理是这样的：在行为的很多步骤中，其中一个步骤的上一步是执行下一步的必要条件，如果人们想要执行错误的操作，那么这个错误的操作就会导致上一步无法执行，因此人们也无法执行下一步的操作。</p><p>一个很简单的例子是，人们需要车钥匙来运行汽车发动机的引擎。</p><p>然而，虽然一些forcing fuction可以防止错误的发生，但也会给用户带来不便——比如发动机开着的时候如果开车门就会有警报，但要是我只想坐在在车里听歌然后开门吹风，就会被警报声吵得受不了。</p><p>我们需要权衡这两者，更何况，<strong>迫使用户做不想做的事情，大多没什么好结果</strong>。理想状态下，forcing fuction肯定会对用户的操作造成影响，但只有一点点。</p><h3 id="Safety-Engineering中的容错性设计"><a href="#Safety-Engineering中的容错性设计" class="headerlink" title="Safety Engineering中的容错性设计"></a>Safety Engineering中的容错性设计</h3><p>（其实不管是app的系统设计还是游戏设计……还是单纯的某些轮子，都是同理的呀）</p><h4 id="Interlock"><a href="#Interlock" class="headerlink" title="Interlock"></a>Interlock</h4><p>和forcing function类似，当用户执行了某种操作之后，就会中断某个进程，两个操作无法同时进行，从而阻断了不正当使用方式。</p><p>比如在加热过程中开启微波炉的门，就会自动停止加热。</p><h4 id="Lockin"><a href="#Lockin" class="headerlink" title="Lockin"></a>Lockin</h4><p>指某种一直在运行、无法被干预的进程。</p><p>比如云文档中的自动保存功能，不管用户是否想要保存，它都会自动存到云端。</p><h4 id="Lockout"><a href="#Lockout" class="headerlink" title="Lockout"></a>Lockout</h4><p>字面意思，把用户挡在外面，无法接触到这个东西。</p><p>作者举的例子我在国内没见过，但的确在美国有看到：在一楼和地下室的楼梯之间总会有一个挡板，你需要把它拨开才能下去，稍微有点麻烦。搞这个东西的原因是火灾的时候，所有人都特别慌张，都光顾着往下跑没心思考虑跑到几楼。如果没有一个提醒的东西在，可能很多人都会一直往下冲最后全被堵在地下室了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Error分为两种，一种是无意识行为的slips，还有一种是有意识行为的mistakes&lt;/p&gt;
&lt;h2 id=&quot;任务的结构&quot;&gt;&lt;a href=&quot;#任务的结构&quot; class=&quot;headerlink&quot; title=&quot;任务的结构&quot;&gt;&lt;/a&gt;任务的结构&lt;/h2&gt;&lt;p&gt;从两个维度来看：横向与纵向&lt;/p&gt;
&lt;h3 id=&quot;深度与广度兼具的结构&quot;&gt;&lt;a href=&quot;#深度与广度兼具的结构&quot; class=&quot;headerlink&quot; title=&quot;深度与广度兼具的结构&quot;&gt;&lt;/a&gt;深度与广度兼具的结构&lt;/h3&gt;&lt;p&gt;比如棋类游戏，每一步都有很多可能，而且要走很多步，基本上决策树要画到累死的那种。&lt;/p&gt;
&lt;p&gt;对于大多数人来说，这种任务十分艰难（还是交给人工智能好了），至少日常生活中不怎么会用到。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 4 Knowing What to Do</title>
    <link href="https://blog.sheronw.xyz/2019/06/01/4%20Knowing%20What%20to%20Do/"/>
    <id>https://blog.sheronw.xyz/2019/06/01/4 Knowing What to Do/</id>
    <published>2019-06-01T18:21:47.000Z</published>
    <updated>2019-08-17T22:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日常限制-Constraint-的分类"><a href="#日常限制-Constraint-的分类" class="headerlink" title="日常限制(Constraint)的分类"></a>日常限制(Constraint)的分类</h2><h3 id="物理限制Physical-Constraints"><a href="#物理限制Physical-Constraints" class="headerlink" title="物理限制Physical Constraints"></a>物理限制Physical Constraints</h3><p>就是事物的物理形态上的限制，比如地铁闸机的一次性卡只能四平八稳地插到那条缝里。这些限制应该是显而易见的，要是那条缝太隐蔽可能都没人能找得着。</p><p>而且最好要能够减少操作的可能性，比如新旧Type C接口——之前的接口正面反面只有一个是对的，而现在可以正插也可以反插。</p><h3 id="语义限制Semantic-Constraints"><a href="#语义限制Semantic-Constraints" class="headerlink" title="语义限制Semantic Constraints"></a>语义限制Semantic Constraints</h3><p>有些行为是要根据当时的情况和我们现有的知识来决定的。比如装乐高小玩具的时候，骑车的人要脸朝前，否则不符合常理。</p><a id="more"></a><h3 id="文化限制Cultural-Constraints"><a href="#文化限制Cultural-Constraints" class="headerlink" title="文化限制Cultural Constraints"></a>文化限制Cultural Constraints</h3><p>指那些我们需要习得的文化常识和社会常规——它们有些是陈述性的，有些是一系列的动作，比如遇到红灯应该停车，比如进入快餐店就排队点餐，然后在旁边等餐，拿着餐盘找地方坐。</p><h3 id="逻辑限制Logical-Constraints"><a href="#逻辑限制Logical-Constraints" class="headerlink" title="逻辑限制Logical Constraints"></a>逻辑限制Logical Constraints</h3><p>一系列逻辑性推断的结果，比如拼拼图拼到最后只剩下一个空缺，那么就会想当然地将最后一块拼图放上去。</p><p>而且，我们之前提到过的自然映射也是逻辑限制的结果。</p><h2 id="限制和功能可见性-Affordance-在日常中的应用"><a href="#限制和功能可见性-Affordance-在日常中的应用" class="headerlink" title="限制和功能可见性(Affordance)在日常中的应用"></a>限制和功能可见性(Affordance)在日常中的应用</h2><h3 id="门的设计"><a href="#门的设计" class="headerlink" title="门的设计"></a>门的设计</h3><p>不同的门有不同的功能可见性，比如平板一般就是用来推的，门把手一般就是用来拉的，旋钮（奇怪的是，感觉中文语境下这个也叫门把手）一般就是用来扭的。但是在现实生活中设计者并不会这么讲究，经常混着用，就给用户带来了困扰。</p><h3 id="开关的设计"><a href="#开关的设计" class="headerlink" title="开关的设计"></a>开关的设计</h3><p>开关的设计（尤其是需要很多开关的情况）会遇到两个问题：一个是分组问题，怎样把不同的开关和不同的功能联系起来；另外一个是映射问题——一排开关摆在那里，如何排列才能更好地区分哪个开关对应哪个功能。</p><h4 id="如何区分不同的开关？"><a href="#如何区分不同的开关？" class="headerlink" title="如何区分不同的开关？"></a>如何区分不同的开关？</h4><p>不知道是由于成本还是美学上的考虑，很多仪器的开关都整齐划一地排一排，用的时候很让人崩溃，而且对于某些重要点的，比如飞机、核电站之类的，如果因此弄错就会造成巨大损失。</p><p>基本上有两种可行的方法：第一种是把功能相近的开关摆在一起，并且与其他功能区分开；另一种是将不同功能的开关做成不同的样子。（两者综合使用效果更佳）</p><h4 id="如何排列开关？"><a href="#如何排列开关？" class="headerlink" title="如何排列开关？"></a>如何排列开关？</h4><p>作者的举例是一个房间中所有灯的那些开关。在大部分的房间（至少我去过的），灯的开关都是排成一排的——好像没毛病。</p><p>然而房间是三维的，灯的位置可能在三维空间中的任何地方（虽然大部分灯都在天花板上所以是二维的），你要怎么知道灯的开关是对应哪一个灯呢？</p><p>和灶台的情况一样，没有人care它，因为负责家装每一个环节的人，要么不是实际使用者，要么认为这根本不是自己的职责。</p><p>作者的解决方案在美学上看很不优雅——他搞了一个从墙面中突出来的水平放置的室内平面图，灯所在的位置上打孔放开关。</p><p>其实我个人觉得现在的智能家具就很容易解决这种问题，到时候可以想想怎么搞。</p><h2 id="可见性-Visibility-和反馈-Feedback"><a href="#可见性-Visibility-和反馈-Feedback" class="headerlink" title="可见性(Visibility)和反馈(Feedback)"></a>可见性(Visibility)和反馈(Feedback)</h2><p>之前我们说了限制和映射，除此之外，可见性（和功能可见性不一样，我也不知道affordance为啥翻译成功能可见性）和反馈也会影响用户的使用。</p><p>可见性，「视觉」肯定是一方面，比如为各种设备添加屏幕（至少我们现在算是实现了）；而「听觉」却是经常被忽略的。</p><p>自然生成的听觉很重要——我们可以通过它来得到反馈，比如水烧开之后咕嘟咕嘟的声音、门关上之后喀哒一下的声音……</p><p>人工物件的提示音在使用的时候需谨慎。提示音的好处在于，即使眼睛没有看着这个物件也能得到提示，而且可以反馈一些外观上看不到的内容。但同样也有缺点，可能会干扰到其他的人，并且自己的使用过程可能会被人知道（想起来小时候看电视上讲的电话诈骗，就是根据电话按键的数字不同音调不同来窃取密码）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日常限制-Constraint-的分类&quot;&gt;&lt;a href=&quot;#日常限制-Constraint-的分类&quot; class=&quot;headerlink&quot; title=&quot;日常限制(Constraint)的分类&quot;&gt;&lt;/a&gt;日常限制(Constraint)的分类&lt;/h2&gt;&lt;h3 id=&quot;物理限制Physical-Constraints&quot;&gt;&lt;a href=&quot;#物理限制Physical-Constraints&quot; class=&quot;headerlink&quot; title=&quot;物理限制Physical Constraints&quot;&gt;&lt;/a&gt;物理限制Physical Constraints&lt;/h3&gt;&lt;p&gt;就是事物的物理形态上的限制，比如地铁闸机的一次性卡只能四平八稳地插到那条缝里。这些限制应该是显而易见的，要是那条缝太隐蔽可能都没人能找得着。&lt;/p&gt;
&lt;p&gt;而且最好要能够减少操作的可能性，比如新旧Type C接口——之前的接口正面反面只有一个是对的，而现在可以正插也可以反插。&lt;/p&gt;
&lt;h3 id=&quot;语义限制Semantic-Constraints&quot;&gt;&lt;a href=&quot;#语义限制Semantic-Constraints&quot; class=&quot;headerlink&quot; title=&quot;语义限制Semantic Constraints&quot;&gt;&lt;/a&gt;语义限制Semantic Constraints&lt;/h3&gt;&lt;p&gt;有些行为是要根据当时的情况和我们现有的知识来决定的。比如装乐高小玩具的时候，骑车的人要脸朝前，否则不符合常理。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 3 Knowledge in the Head and in the World</title>
    <link href="https://blog.sheronw.xyz/2019/05/29/3%20Knowledge%20in%20the%20Head%20and%20in%20the%20World/"/>
    <id>https://blog.sheronw.xyz/2019/05/29/3 Knowledge in the Head and in the World/</id>
    <published>2019-05-29T14:41:47.000Z</published>
    <updated>2019-08-17T22:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="只需要不完整的知识就可以执行完整动作的原因"><a href="#只需要不完整的知识就可以执行完整动作的原因" class="headerlink" title="只需要不完整的知识就可以执行完整动作的原因"></a>只需要不完整的知识就可以执行完整动作的原因</h2><ol><li>信息存在于客观世界。许多线索在现实生活中一直存在（比如键盘上的字母），我们只需要将闹钟的信息和生活中的线索结合起来。</li><li>执行动作不需要精确。有时执行正确的动作不需要知道所有相关知识，只需要足够的知识把正确和错误的选项区分开。</li><li>存在着一定的自然限制。其实一个人能够做的行为是有限的——比如不同事物的物理性质决定了人只能对它们执行有限种类内的操作：移动、捡起、旋转、悬挂……</li><li>存在着一定的文化限制。包括各种社会常规和一些约定俗成的规律，它们需要被后天学习，但是可以广泛应用到不同的事物上。</li></ol><p>其中，自然限制和文化限制都很大程度上地缩小了可执行操作的范围。而动作主要由这两种限制、外部存在的信息与内部的知识决定。人类都是很懒的嘛，所以它们只会记忆除了这两种限制和外部一直存在的信息以外的知识。</p><a id="more"></a><h3 id="客观世界中存在的信息"><a href="#客观世界中存在的信息" class="headerlink" title="客观世界中存在的信息"></a>客观世界中存在的信息</h3><p>一般来讲，只要外部信息足够，人们只需要记忆刚刚好的信息就可以完成任务了。</p><p>一般来讲，人们执行动作时需要两种信息：</p><ul><li>of知识，学名declarative knowledge，一般指客观事实和规则，比较好传授。</li><li>how知识，学名procedural knowledge，就是执行各种一系列行为所需要的知识，很难完整地表述出来也很难传授（只可意会不可言传？），因此需要大量的示范以及练习。</li></ul><p>其实生活中到处都是提示我们的信息，不管是键盘上的字母还是指示灯，包括我们自己也会使用相同的策略，比如到处贴便利贴来提醒自己，把优先级最高的事物放在书桌上最显眼的位置之类的。</p><h3 id="执行动作不需要精确"><a href="#执行动作不需要精确" class="headerlink" title="执行动作不需要精确"></a>执行动作不需要精确</h3><p>在很多情况下，只要能够把错误和正确的选项区分开就可以了，所以人们并不会记忆更多的精确信息。</p><p>比如当今通行的人民币硬币，我只要记得一块钱最大，五毛钱是古铜色的，一毛钱要小一点，就足够区分了，至于硬币上印了啥，我也不太记得了（虽然隐约记得一块钱是菊花，五毛是荷花一样的东西，一毛是不知道什么草？但不知道也能用）</p><h3 id="限制的力量"><a href="#限制的力量" class="headerlink" title="限制的力量"></a>限制的力量</h3><p>之前有说过，限制分为自然限制和文化限制，他们俩可以极大地缩小可执行的动作的范围。</p><p>先说自然限制，就是各种物理条件，比如见洞就插（我在说乐高啦！）。</p><p>然后在说文化限制，可能见洞就插是一种社会上的常规，大家从小就被教导见洞就插。</p><p>好吧说个正经的文化限制的例子，在很久很久之前，纸张还不普及的时候，哪些吟游诗人是怎么背下来那些长诗的呢？</p><p>首先，长诗的剧情已经是众所周知的了。其次，诗歌要讲究韵律吧（我不是歪果仁，不太清楚具体怎么操作的）。</p><p>然后，找到一个既要符合剧情又要讲究韵律的词，就变得很简单了，至少比背诵随机单词要简单很多。</p><h2 id="记忆：脑内的信息"><a href="#记忆：脑内的信息" class="headerlink" title="记忆：脑内的信息"></a>记忆：脑内的信息</h2><ul><li>短期记忆</li><li>长期记忆</li></ul><p>长期记忆的难点不是储存的能力，而是如何调用以及如何分类。</p><p>如下是三种主要的分类，由浅入深：</p><ol><li>for arbitrary things</li><li>for meaningful relationships（把1中的东西组织起来）</li><li>through explanation（可以应对一些突发情况，但慢）</li></ol><p>这就是为什么设计者应该通过物理界面提供一个正确的模型——否则用户会自己编出来一个自圆其说的模型，从而造成理解误差。</p><h2 id="记忆：世界中的信息"><a href="#记忆：世界中的信息" class="headerlink" title="记忆：世界中的信息"></a>记忆：世界中的信息</h2><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>一般情况下，提醒有两种：一种是信号，另外一种是信息。信号是提醒我们有什么事情要做，信息是提醒我们要做什么。</p><p>在作者那个年代好像还没有两者兼备的设备，但现在我觉得很多待办事项都有这两个功能：到点就会有铃声和弹窗提示，然后信息也有——不论是我们自己留的（包括可自动化的地点、网站等），还是谷歌助手自己给你通过邮件加进去的（比如机票和订房）。</p><h3 id="自然映射"><a href="#自然映射" class="headerlink" title="自然映射"></a>自然映射</h3><p>作者举了一个灶台的例子。我在国内的家里只有两个灶台，一左一右，而美国这边基本上都是四个灶台。我观察了一下，同样是上下左右排成长方形四个顶点的灶台，有的开关就是一排，扭之前就要看旁边的提示才能知道是哪一个；有的开关也是四个顶点这样排着的，就会方便很多。</p><h2 id="脑内与世界信息之间的权衡"><a href="#脑内与世界信息之间的权衡" class="headerlink" title="脑内与世界信息之间的权衡"></a>脑内与世界信息之间的权衡</h2><p>到底脑子里面需要记多少知识，在现实世界中留多少线索，才能又快又好地完成某个行为呢？毕竟外界的线索越多，脑子里需要记的知识就越少，学习成本也低。但要是脑子里多记一点，就不需要在外界寻找可能的线索了，使用起来也更「得心应手」，而且一些外界条件改变了也能继续用。</p><p>「备忘」其实就是一种恰到好处的权衡——我们在脑内记住了「我们要定期查看备忘」这件事情，然后把所有的其他重要信息交付给外界的某种备忘。比如「写完的作业放在右边，没写完的放左边，定期往左瞅瞅自己还有多少作业没有写」。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;只需要不完整的知识就可以执行完整动作的原因&quot;&gt;&lt;a href=&quot;#只需要不完整的知识就可以执行完整动作的原因&quot; class=&quot;headerlink&quot; title=&quot;只需要不完整的知识就可以执行完整动作的原因&quot;&gt;&lt;/a&gt;只需要不完整的知识就可以执行完整动作的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;信息存在于客观世界。许多线索在现实生活中一直存在（比如键盘上的字母），我们只需要将闹钟的信息和生活中的线索结合起来。&lt;/li&gt;
&lt;li&gt;执行动作不需要精确。有时执行正确的动作不需要知道所有相关知识，只需要足够的知识把正确和错误的选项区分开。&lt;/li&gt;
&lt;li&gt;存在着一定的自然限制。其实一个人能够做的行为是有限的——比如不同事物的物理性质决定了人只能对它们执行有限种类内的操作：移动、捡起、旋转、悬挂……&lt;/li&gt;
&lt;li&gt;存在着一定的文化限制。包括各种社会常规和一些约定俗成的规律，它们需要被后天学习，但是可以广泛应用到不同的事物上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，自然限制和文化限制都很大程度上地缩小了可执行操作的范围。而动作主要由这两种限制、外部存在的信息与内部的知识决定。人类都是很懒的嘛，所以它们只会记忆除了这两种限制和外部一直存在的信息以外的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 2 The Psychology of Everyday Actions</title>
    <link href="https://blog.sheronw.xyz/2019/05/27/2%20The%20Psychology%20of%20Everyday%20Actions/"/>
    <id>https://blog.sheronw.xyz/2019/05/27/2 The Psychology of Everyday Actions/</id>
    <published>2019-05-27T17:21:57.000Z</published>
    <updated>2019-08-17T22:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误地怪罪自身"><a href="#错误地怪罪自身" class="headerlink" title="错误地怪罪自身"></a>错误地怪罪自身</h2><p>在很多情况下，人们发现自己失误的时候不会归罪到设计上，而是觉得自己不行。而且因为这些失误往往过于傻逼，还不好意思告诉别人。就因为缺少反馈，一些设计者根本没有察觉到自己的设计给人们带来了很多不便。</p><p>好的设计应该考虑到所有可能出现的失误，让它们被人易于察觉，并且争取将这些失误的损失最小化。</p><a id="more"></a><h2 id="日常生活中的误解"><a href="#日常生活中的误解" class="headerlink" title="日常生活中的误解"></a>日常生活中的误解</h2><p>人脑结构决定了我们很容易在日常生活中根据肤浅的观察作出简单的猜测（并且往往能够自圆其说），然而现实远远比我们想得要复杂，这就导致了很多有趣的误解。</p><p>比如可以调节的暖气，比较流行的误解有两种：第一个是档位越高暖气开得越久，第二个是档位越高火力越强，但事实上是，档位的大小决定了暖气在达到哪一个温度之后停下。因此把暖气开到最大并不能让整个屋子暖和得更快。</p><h3 id="错误地归因"><a href="#错误地归因" class="headerlink" title="错误地归因"></a>错误地归因</h3><p>人类归纳因果关系的机理至今是个谜。</p><p>一个比较常见的错误归因是，如果结果R发生之前我做了事件A，那么我就倾向于将结果R归结为事件A，就像我小学刚接触电脑的时候以为不断右键刷新屏幕电脑运行速度就会变快一样。</p><p>于此之外，还有「自我感觉良好」类错误归因，比如自己遇到啥好事就觉得是自己牛逼，别人遇到啥好事就觉得是别人运气好。</p><h4 id="习得性无助"><a href="#习得性无助" class="headerlink" title="习得性无助"></a>习得性无助</h4><p>好像在哪本关于学习的书里面看到过这个呀。</p><p>人们有的时候会因为一些意外失败的尝试，而断言自己不擅长或者不适合做某些事情。</p><p>这种效应在使用电子产品时尤其十分常见。</p><h4 id="传授性无助"><a href="#传授性无助" class="headerlink" title="传授性无助"></a>传授性无助</h4><p>乍一看和习得性无助很像。</p><p>作者认为，人们认为自己不适合使用某种产品，并不是「真的不擅长」，而是产品设计有问题，所以让人觉得很难用从而望而却步罢了。</p><p>还有一个是常见的「数学恐惧症」效应。和人文社科类不同，数学的课程之间往往有着紧密的联系，每一个课程都需要上一节课的理论基础，因此只要一步跟不上，就步步跟不上，从而让人觉得自己越来越不适合数学。</p><h2 id="人类思考与解释的本质"><a href="#人类思考与解释的本质" class="headerlink" title="人类思考与解释的本质"></a>人类思考与解释的本质</h2><p>俗话说「事后诸葛亮」，当人们在事件发生之后再去探查的时候，事故的原因往往是显而易见的。然而放在当时的情况下，却可能会对某个结果的原因产生误判，这也是一些事故发生的原因。</p><p>我指的是，在事件发生之后，人们意识到了「哇，还有可能发生这种事情呀」，所以对于当初对于这个错误的忽视感到惊讶。</p><p>然而在那个情况下，人们并没有这方面的经验，也不会往这里去想。</p><p>比如在三里岛的事故中，指示灯显示的是发送到阀门的信号是否正确，而不是阀门是否正确关闭。操作人员在那个情况下并没有考虑到「信号正确但阀门未正确关闭」这种意外情况（也可以说操作人员的用户模型和设计者的设计模型出现了偏差）。</p><h2 id="人类行动的七个步骤"><a href="#人类行动的七个步骤" class="headerlink" title="人类行动的七个步骤"></a>人类行动的七个步骤</h2><ol><li>首先，你需要有一个行动的目标（Goal）来说任何事情。</li><li>但是这个目标往往是模糊的，比如说我想喝水。所以我们需要一个更确切的意图（intention），比如我要拿起旁边的杯子来喝水。</li><li>有了目标，就要有一个具体行动的计划，比如我要动用我的手臂肌肉，碰到杯子，然后拿起来放到嘴边。</li><li>然后我们需要执行这个具体的行动。</li><li>之后，我们要确认这个行动是否成功完成。首先我们要知道在现实世界中发生了什么——我喝到了水。</li><li>然后我们解释这个事件，比如因为我拿起了杯子所以我喝到了水。</li><li>最后一步我们要将这个结果进行评估，比如很好，我达到了喝水的目的。</li></ol><p>其中，1与<strong>目标</strong>有关，2-4与具体的<strong>执行</strong>有关，5-7与<strong>评估</strong>有关。</p><p>作者的语言更加简洁，这里仅供参考：</p><ol><li>Forming the goal</li><li>Forming the intention</li><li>Specifying an action</li><li>Executing the action</li><li>Perceiving the state of the world</li><li>Interpreting the state of the world</li><li>Evaluating the outcome</li></ol><p>当然，也不是所有行动都要经过以上的步骤，很有可能中途停掉，或者跳过一些步骤。一些情况下，目标和意图是随机出现的。</p><h2 id="执行与评估中的陷阱"><a href="#执行与评估中的陷阱" class="headerlink" title="执行与评估中的陷阱"></a>执行与评估中的陷阱</h2><p>生活中很多产品比较难用的原因，并不是因为这个产品过于复杂，而是人们的意图、解释、行为和物体的状态之间出现了偏差，以至于人们的思维与现实之间出现了断层。</p><h3 id="执行中的陷阱"><a href="#执行中的陷阱" class="headerlink" title="执行中的陷阱"></a>执行中的陷阱</h3><p>指人们的意图和产品可执行的行为之间的不一致。</p><p>比如我只是想执行一个很简单的操作，但说明书上面叫我做一堆乱七八糟意义不明的步骤——这一系列的操作完全可以让机器来做。</p><h3 id="评估中的陷阱"><a href="#评估中的陷阱" class="headerlink" title="评估中的陷阱"></a>评估中的陷阱</h3><p>指人们需要花多少力气来得到并理解产品的反馈，并且将它与自己的目标、执行动作之间联系起来。</p><p>比如，除非我打开机器来查看，否则根本无法知道里面是否装了VCR。</p><h2 id="How-Easy-Can-One"><a href="#How-Easy-Can-One" class="headerlink" title="How Easy Can One:"></a>How Easy Can One:</h2><ul><li>Determine the Function of the Device?</li><li>tell what actions are possible?</li><li>determine mapping from intention to physical movement?</li><li>perform the action?</li><li>tell if system is in desired state?</li><li>determine mapping from system state to interpretation?</li><li>tell what state the system is in?</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;错误地怪罪自身&quot;&gt;&lt;a href=&quot;#错误地怪罪自身&quot; class=&quot;headerlink&quot; title=&quot;错误地怪罪自身&quot;&gt;&lt;/a&gt;错误地怪罪自身&lt;/h2&gt;&lt;p&gt;在很多情况下，人们发现自己失误的时候不会归罪到设计上，而是觉得自己不行。而且因为这些失误往往过于傻逼，还不好意思告诉别人。就因为缺少反馈，一些设计者根本没有察觉到自己的设计给人们带来了很多不便。&lt;/p&gt;
&lt;p&gt;好的设计应该考虑到所有可能出现的失误，让它们被人易于察觉，并且争取将这些失误的损失最小化。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 1 The Psychopathology of Everyday Things</title>
    <link href="https://blog.sheronw.xyz/2019/05/26/1%20The%20Psychopathology%20of%20Everyday%20Things/"/>
    <id>https://blog.sheronw.xyz/2019/05/26/1 The Psychopathology of Everyday Things/</id>
    <published>2019-05-26T04:25:17.000Z</published>
    <updated>2019-08-17T22:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章节讲述的是与「每天需要打交道的东西」相关的心理学。</p><h2 id="可见性Visibility"><a href="#可见性Visibility" class="headerlink" title="可见性Visibility"></a>可见性Visibility</h2><p>首先是<strong>可见性</strong>（Visiblity）。毕竟想要让用户操作，就需要让用户看到可以操作的界面，进而理解可操作的部件和真正实现的功能之间的<strong>映射</strong>（mapping），让用户能够知道自己的这种操作会引发什么样的功能。操作之后还需要合理的反馈，让用户知道系统执行了这个功能。</p><p>比如「开灯」这个生活中司空见惯的操作：</p><ul><li>灯的开关是我们能够看到的（要是藏在哪个旮旯里就太糟糕了）</li><li>按下开关这个动作我们知道是「让某个东西处于开启状态」的意思</li><li>灯亮，这样我们就知道灯成功地被我们打开了</li></ul><a id="more"></a><p>如果visibility太低，根本没有操作的线索，显然不是一件好事；而visibility太高，先不说美不美观，正常人看到几十个长得差不多的按钮排成一排，都会多少头皮发麻吧。</p><h2 id="功能可见性Affordance"><a href="#功能可见性Affordance" class="headerlink" title="功能可见性Affordance"></a>功能可见性Affordance</h2><p>不管是出于什么样的原因，看到某些东西之后，我们下意识就会知道如何去操作——比如开关是用来按的，一个门上的拉手是用来拉的，而平板是用来推的，这个就是affordance。</p><p>一个有趣的例子是，如果在火车站里面装玻璃，总有搞事情的人就把它给砸了，要是换成三合板，搞事情的人开始在上面乱涂乱画。</p><p>而好的设计不要让用户有太多的想象空间——比如什么都没有的玻璃门，又简洁又美观，可我应该推它？拉它？左右滑动？上下滑动？（当然要是自动门就好了），affordance应该限制在一定程度之内。</p><h2 id="概念模型Concept-Model"><a href="#概念模型Concept-Model" class="headerlink" title="概念模型Concept Model"></a>概念模型Concept Model</h2><p>通过Visibility和Affordance，外加对于他们的一些限制，用户可以大概地推断出，不同的操作会引发什么不同的效果。</p><p>当然用户从visilibility和affordance中推断出来的概念模型，很有可能和设计者所想的概念模型（也就是说实际的概念模型）有一定差别（届不到届不到QvQ）。好的设计应该尽量避免这种误差。</p><h3 id="设计的准则"><a href="#设计的准则" class="headerlink" title="设计的准则"></a>设计的准则</h3><h4 id="好的概念模型"><a href="#好的概念模型" class="headerlink" title="好的概念模型"></a>好的概念模型</h4><p>随着各种日常事物的复杂化，普通人已经很难掌握它们所有的机理了——就好比我现在正在用笔记本电脑，但我无法确切地明白电脑中的每一个精细部件的用途。因此他们的设计者需要一个抽象的概念模型，来让用户把操作和效果联系起来。</p><p>——听上去像是把复杂的问题简单化，然而设计者和用户之间很容易在理解方面出现偏差，作者提到了一下几个概念：</p><ol><li>Design Model<strong>设计模型</strong>，即设计者所了解的概念模型</li><li>User’s Model<strong>用户模型</strong>，即用户通过系统的界面以及能够得到的信息所理解的概念模型</li><li>System Image<strong>系统映像</strong>，即这个系统的客观存在的实际结构，比如我们所看到的按钮和显示屏</li></ol><p>其中，设计模型影响系统映像的形态，而用户通过与系统映像的交互不断修改脑中的用户模型。理想状态下，设计模型和用户模型应该是无限接近的。</p><p>作者举了一个反例——他的冰箱有两个调温档，一个标签上写着「制冷」，另一个写着「保鲜」。用户很容易就会想当然地觉得一个用来调节制冷仓，另一个用来调节保鲜仓。</p><p>然而设计者脑中的概念模型是这样的：「制冷」的调温档同时负责两个仓的制冷，而「保鲜」的调温档负责控制通向保鲜仓的冷气的多少。然而实际的系统映像就是照着设计者的想法制造的，用户在使用中就很容易出现问题。</p><h4 id="确保可见性"><a href="#确保可见性" class="headerlink" title="确保可见性"></a>确保可见性</h4><p>作者比对了（那个年代的）电话与汽车的设计。</p><p>电话的许多功能都是通过那几个电话按键的排列组合（没有什么特殊的映射）实现的，比如<em>拨打#27实现某功能</em>，并且执行完毕之后没有任何提示。</p><p>而汽车中的开关按钮都放在不同的位置，基本上一个开关对应一个功能，而且大部分功能都是可以立即看到反馈的，即使不能立即看到也有指示灯。</p><p>正因为汽车的整个系统是可见的，所以用户能够更好地理解系统映像，并且进行相应的操作。而电话中可以控制的部分（那几个数字键）比能够实现的功能数量要少很多，很多功能是不可见的，就会让用户迷惑。</p><h4 id="映射的设计准则"><a href="#映射的设计准则" class="headerlink" title="映射的设计准则"></a>映射的设计准则</h4><p>之前有提到过，映射是操作和结果之间的联系。理想中的映射要顺其自然，才容易让用户理解，以下是几个例子：</p><ul><li>操作方向与结果的方向相同，比如方向盘这个东西，向左转的话车就左拐，反之亦然——要是方向盘向左车子向右，那还真是挑战人类极限。</li><li>所控制的东西的顺序和按键的顺序相同，比如开关的排列顺序应该和灯的排列顺序相同。</li><li>反馈的响度、亮度等和效果的程度成正比。</li></ul><p>虽然听上去很简单，但实际操作中还是很容易出错，比如音响设备中，调节声音从前后音箱中流出的比例时，滑块却是左右排列的——如何将滑块的左右映射到前后关系上，就很令人迷惑。</p><h4 id="反馈的设计准则"><a href="#反馈的设计准则" class="headerlink" title="反馈的设计准则"></a>反馈的设计准则</h4><p>在现实中，虽然一些好的设计方案得以提出，但并没有得到普及，这里是作者的一个解释：在市场经济环境下，如果某方面的尝试在第一个产品推出之后并没有得到理想的反馈，几乎所有人都会放弃这个方向，因此许多原本有潜力的产品无法成功问世。</p><p>作者还提到了科技发展对设计产生的影响是U字型的——一个新的事物面世是，受众群体往往比较小，操作也比较复杂；随着科技继续发展，操作会变得越来越简单易懂；然而从某个时间点开始，大量的新功能开始加入到这个事物中来，于是操作难度又再一次升高了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节讲述的是与「每天需要打交道的东西」相关的心理学。&lt;/p&gt;
&lt;h2 id=&quot;可见性Visibility&quot;&gt;&lt;a href=&quot;#可见性Visibility&quot; class=&quot;headerlink&quot; title=&quot;可见性Visibility&quot;&gt;&lt;/a&gt;可见性Visibility&lt;/h2&gt;&lt;p&gt;首先是&lt;strong&gt;可见性&lt;/strong&gt;（Visiblity）。毕竟想要让用户操作，就需要让用户看到可以操作的界面，进而理解可操作的部件和真正实现的功能之间的&lt;strong&gt;映射&lt;/strong&gt;（mapping），让用户能够知道自己的这种操作会引发什么样的功能。操作之后还需要合理的反馈，让用户知道系统执行了这个功能。&lt;/p&gt;
&lt;p&gt;比如「开灯」这个生活中司空见惯的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灯的开关是我们能够看到的（要是藏在哪个旮旯里就太糟糕了）&lt;/li&gt;
&lt;li&gt;按下开关这个动作我们知道是「让某个东西处于开启状态」的意思&lt;/li&gt;
&lt;li&gt;灯亮，这样我们就知道灯成功地被我们打开了&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计心理学 - 0 The Psychology of Everyday Things</title>
    <link href="https://blog.sheronw.xyz/2019/05/23/0%20index/"/>
    <id>https://blog.sheronw.xyz/2019/05/23/0 index/</id>
    <published>2019-05-24T00:31:47.000Z</published>
    <updated>2019-08-17T22:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本讲「设计」的书。</p><p>说到设计先偏个题，我一直以来坚信设计的精髓是「颜值即正义」，只不过颜值正如艺术品一样，品味有差异。</p><p>高中的时候我读了原研哉的「设计中的设计」，虽然书里面讲了哪些内容我一概都不记得了，但是我意识到「原来世上可以有这么有好看的东西呀」，然后喜欢无印良品，坚信「极简主义」是最高级的品味。的确，当我们在说「设计」的时候，可能百分之九十九以上都在说「美感」——夸一个东西好看但不知道怎么表达？你可以试试「设计感」这个奇妙的词。</p><a id="more"></a><p>读完了这本「The Psychology of Everyday Things」（中译本初版叫「设计心理学」）之后，才意识到之前自己对「设计」的定义太过狭隘了。「得了设计奖」在这本书里很可能是贬义词，作者认为好的设计，美学上的水准有时并不是最重要的，然而要易用，要安全，要有反馈，还要有错误防御机制……（印象比较深刻的是一个叫做Safety Engineering的方向，我之前一直没想到过有这么一群人，专门研究如何让工程项目和各种复杂系统保持一定安全水平）</p><p>现在想想，为什么会觉得自己看到的东西「有设计感」，可能并不仅仅只是因为它有着简洁的外观，而是因为它在可用性的角度上来讲，的确符合「好设计」的准则。就包括这种设计风格为什么能够大行其道，也可能是和日益复杂的事物和操作有关系吧。</p><p>一个有趣的事实：明明是1988年的书，作者却精准地预言了物联网、智能手机、语音助手。</p><p>目标：运用书中的知识点，研究一个app或者一个网站，总之就是我们每天都要打交道的界面，然后进行简单评估。</p><p>一些奇奇怪怪的问题：</p><p>触摸屏左右滑动、双击home键显示菜单栏是不是需要习得的社会规则？</p><p>用单向玻璃，不同方向，不设置任何把手，需要推的就可见，需要拉的就不可见，这个设计可行吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一本讲「设计」的书。&lt;/p&gt;
&lt;p&gt;说到设计先偏个题，我一直以来坚信设计的精髓是「颜值即正义」，只不过颜值正如艺术品一样，品味有差异。&lt;/p&gt;
&lt;p&gt;高中的时候我读了原研哉的「设计中的设计」，虽然书里面讲了哪些内容我一概都不记得了，但是我意识到「原来世上可以有这么有好看的东西呀」，然后喜欢无印良品，坚信「极简主义」是最高级的品味。的确，当我们在说「设计」的时候，可能百分之九十九以上都在说「美感」——夸一个东西好看但不知道怎么表达？你可以试试「设计感」这个奇妙的词。&lt;/p&gt;
    
    </summary>
    
      <category term="设计心理学笔记" scheme="https://blog.sheronw.xyz/categories/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>以学年总结为题的未来展望</title>
    <link href="https://blog.sheronw.xyz/2019/05/21/bye_sophomore/"/>
    <id>https://blog.sheronw.xyz/2019/05/21/bye_sophomore/</id>
    <published>2019-05-21T19:02:12.000Z</published>
    <updated>2019-05-29T22:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在大二学年的末尾，我觉得自己又多上了两年高中。</p><p>大一我没有像以前那样装模作样地写一篇学年总结，唯一写过的东西大概是一条朋友圈，大意是「今年就像做梦一样幸福希望明年也能够继续这样的生活」，而大二也如愿以偿地，基本上就是大一生活的延续——一整个学校都没有我讨厌或者讨厌我的人、有每天能见到的有男有女的三五好友、小圈子里她喜欢他喜欢她的捕风捉影的绯闻、虽然也努力学习但没有名为「高考」的压力、出成绩之后同学之间的商业互吹和自贬……</p><p>虽然听上去有些滑稽，但初中时向往的「玫瑰色的高中生活」正是如此。</p><a id="more"></a><p>我想我是很幸福了，真的很幸福，只是偶尔会在大家聊得最开心的时候突然呆住，然后质疑自己想要的是不是就是这种生活——</p><p>可能就是「绝美之城」里的Jep提到的「中带」（La Fess）吧。</p><p>当然我并不是要全盘否定自己过去的两年，也不是说要从现在的圈子中淡出，但在这被戏称为「与世隔绝的考研读博预备军学校」的地方，一切的一切似乎都在教学生如何在象牙塔中生存，当然这条路也并非外人想得那样一帆风顺。可是，我并不像我的好友那样对象牙塔、或者「科研事业」「做学问」有着狂热的兴趣。对他们来说，读研、甚至直接读博，并不是选择，而是理所应当的。而我虽然也在装模作样地帮教授打着杂，但我打心底明白，这不是那种能够激发我的兴趣、让我不受安排就会去做的事情。</p><p>我高三只申了一所LAC，还是带奖没指望能录的那种，结果阴差阳错就来了这里，从一开始就与大家多多少少格格不入，甚至有些跪舔的心态。但大家都是很善良的人，愿意包容我并和我做朋友，我也的确成长了许多。</p><p>不过，是时候作出一些改变了。</p><p>下文是一些在我的大学前两年没有做到、但自认为明年有必要试着去做的杂七杂八的事情，以总结和规划结合的方式展开叙述。</p><h1 id="总体规划"><a href="#总体规划" class="headerlink" title="总体规划"></a>总体规划</h1><p>意识到自己大概率不会去搞科研之后，我决定通过combined plan转到某大学的工院。和负责人聊了之后才发现，因为前两年过于努力（不是），只要再上两节物理导论就够了，于是我的大三变得十分自由。</p><p>按照惯例，努力勤奋的中国学生都会在这里先修个数学专业再走，但学了很多门数学课之后我意识到，自己并没有那个能力将数学学好，即使能够靠应试技巧（这是我在中国的高中学到的）应付完作业和考试，考完期末考试也会把它们全部忘掉，并且不会想碰第二遍，所以我无法学到令我满意的程度——靠死记硬背、甚至作弊来痛苦地学数学、只想修一个毕业证的也大有人在，但我认为这毫无意义。</p><p>所以明年一整年，我会选尽可能少的课，选一些之前想都不会想的人文社科类课程（历史绘画戏剧乐理之类的），然后利用好LAC的福利，尽可能多地做自主规划的课程（学校现成的cs课少得可怜）。</p><p>下学期的课全部被我有意地排在了一三五。这样，我可以在周一、周三、周五专心学习课内的知识并完成作业，周六休息一天不做任何事情，周二、周四、周日可以安排固定时间来自学——学习只有在大学才有时间和精力学习的「软技能」，预习工院中比较难懂的理论类课程，还有我比较感兴趣的前端类和设计类知识。</p><h1 id="跳脱同温层"><a href="#跳脱同温层" class="headerlink" title="跳脱同温层"></a>跳脱同温层</h1><p>我在刚入学的时候，深切体会到了自己和同学之间的差异（原生家庭、生活圈子、人生规划etc.），并且因此自闭了好久。但两年下来，作为一个（前）自闭儿童还是有了那么几个朋友。现在将自己与在初高中认识的人相比，又觉得自己好像和他们也有了不小的差异。就因为这样，我决定对现在的圈子保持警惕——一旦与他们渐渐熟络，我的思想也会被他们同化，因此需要接受一些与他们不同的信息源。用之前不知道哪里看的人生经验帖的话来讲，就是「看周围的人肯定不会看的东西」。</p><p>首先，LAC人少专业杂，我可以轻易认识各种与我专业差异很大的同学，与他们聊天，得到一些意想不到的观点和思路。</p><p>其次，为了能够了解到除了LAC之外的大学生都在做些什么，我开始试着和与我有不同教育背景的前同学交流，然后在网路上默默视奸一些我觉得有趣的同龄人or大佬<del>，没有跟他们搭话还不是因为社恐，能够看到这篇文章的人请务必来骚扰我并和我做朋友(つω`｡)</del>。</p><p>至于信息源，我觉得很难在「自己认为有趣的内容」和「不会让自己陷入回声室效应的内容」之间取舍，因为我觉得有意思的内容，和我类似的人也很有可能觉得有意思。一个解决方法是寻找一个足够优质、能够综合多个领域、并且精简的信息源，如果有人发现了可以给我推荐下？不过因为上文提到过的差异，我平时关注的信息源和我身边的好友都不太一样，一些本来在我的信息流中刷不到的消息都会通过他们传到我这里来。</p><p>还有就是，周二周四因为没课所以应该会宅在宿舍里，这样也会减少与周围人的一些交流。</p><h1 id="拒绝内卷学习"><a href="#拒绝内卷学习" class="headerlink" title="拒绝内卷学习"></a>拒绝内卷学习</h1><p>「内卷学习」这个梗好像是当初在知乎某个关于衡中的答案里找到的，大意是那种无视效率和健康的「既然学不死 就往死里学」。</p><p>在上高中之前，我是没有认真学习过课内的知识的，课外探索的一些东西，不管是看书，还是写东西，还是做电子杂志网站之类的都属于单纯的个人兴趣探索（现在想想这才是最理想的学习状态）。</p><p>然而高中之后，好像周围所有的人采用的都是衡中式的「内卷学习」法，于是我也被卷入了这种潮水中。就如之前我写过的读书笔记「<a href="https://sheronw.github.io/2019/03/27/make_it_stick/" target="_blank" rel="noopener">我果然一直都在无效学习</a>」中说的那样，做出一副每时每刻都在好好学习的样子，相信自己可以靠一点睡五点半起来取得好成绩，把时间用来不断地反复理解或记忆表层的内容，然后觉得自己应该掌握了，然后直接跳到下一个知识点。</p><p>题外话，高中收获的唯一有益的建议应该是出自高一时的物理老师（虽然年逾花甲但还是超漂亮呀，感觉年轻的时候一定是一个超级大美女）：如果做不出来题就出去跑几圈回来。</p><p>因为我放弃了高考，高三的实际学习时间并没有高一高二那样多，大多数时间都在城市里闲逛、看闲书、保持充足睡眠，结果却得到了对我来说还算不错的成绩。但那个时候我仍然还是憧憬着「内卷学习」，还经常为自己学习时间不够而自责（。</p><p>在大学学习的这两年，我意识到了所谓「真正的知识」与「应试教育需要的技巧」的差异，而「内卷学习」显然不能够满足我现阶段的要求。</p><p>就因为我这两年其实做得也不怎么样，所以以下皆为计划：</p><h2 id="睡眠质量-睡眠质量"><a href="#睡眠质量-睡眠质量" class="headerlink" title="睡眠质量 睡眠质量"></a>睡眠质量 睡眠质量</h2><p>我觉得我睡眠质量极差。可能是天生的吧，因为我也不知道为什么。从很小的时候我就需要在床上躺个一个小时以上才能真正睡着（大部分时间都在意淫赢取白富美出任CEO走上人生巅峰了），而且从来不觉得有什么不对的（哪怕是熬到很晚很困也是这样）。而且下半夜总会醒一次，从四点到七点总是处于半梦半醒的那种很低效睡眠的状态。</p><p>然后学期末清空宿舍，一天之内扛着东西往返住家好几趟，当晚洗了把脸就直接瘫倒在床上了，睡得很快，只是下半夜还是醒了一次。于是下学期的计划是，要在周日、周二、周四（就是自主安排学习的日子）的下午保证一小时运动（作为一个死宅每天运动还是太勉强我了，先从一周三次开始吧）。<del>每天早上要是有时间就做一套养生气功八段锦？？？</del></p><p>还有一个是保证充足的睡眠时间，毋庸置疑。我从小没有午睡的习惯，中午一旦因为某种原因睡着就会一睡不醒荒废一下午，所以我晚上需要比别人多睡一个小时。大一的时候还能保证十点半睡七点起，大二不知怎么着拖着拖着就十二点了……但还是七点多起，所以白天很容易出问题，下学期要更正回去。要是睡不着就不要干躺着，爬起来做一些诸如写日记之类的轻负荷活动<del>，比如把意淫的人赢小剧场给写下来做成galgame呀</del>。</p><h2 id="保证最优学习时间"><a href="#保证最优学习时间" class="headerlink" title="保证最优学习时间"></a>保证最优学习时间</h2><p>回想起高中的时候，最痛苦的莫过于早自习——六点多刚跑完步，还没吃早饭，就坐在教室里硬熬，全部精力都用在保持自己别睡着被值班老师逮着了，这个时候要是真的学习你跟我开玩笑？</p><p>——所以上了大学之后我发誓，状态不好就别硬撑着，都二十岁了，知道自己不能成就一番大事业了，干嘛头悬梁锥刺股的。</p><p>首先，根据这两年的实验以及观察，我并不是那种「深更半夜灵感如泉涌」的人。在保证十点半睡七点起的前提下，自己能够空出来的有效时间应该是上午9:30AM-12:00AM，下午2:00PM-5:00PM，晚上7:00PM-9:00PM。一般来说，下午的状态会好一些。除了这些时间之外，就干脆不学了。</p><p>（一个有意思的现象是，吃完饭后的一个小时，尤其是摄入大量碳水之后，会出现大约半小时的低效率状态。按照我的作息时间大概是9:30AM-10:00AM和1:30PM-2:00PM左右，这个时候安排不了专注度需求比较高的事）</p><h2 id="要么集中精力-要么干脆不学"><a href="#要么集中精力-要么干脆不学" class="headerlink" title="要么集中精力 要么干脆不学"></a>要么集中精力 要么干脆不学</h2><p>虽然我对李笑来这种人生导师的鸡汤持批判性态度，但他有句话我觉得说得有点道理：其实一般人每天坚持学一个东西学两个小时，时间长了也能够在这方面出类拔萃。</p><p>两个小时听上去很小，但想想其实「心无旁骛地学两个小时」其实并不是很容易，据我所知的大部分人，都是学着学着就开始玩手机或者聊天，虽然一下午都在学习但并没有学多少罢了。我虽然自认为还算比较注意，但有的时候也会发现自己浪费了很多学习时间。</p><p>也就是说，自己的所谓「学习时间」并不是完全有效的。所以接下来的目标是，在做事情的时候保持专心致志，多休息几次、或者少学一会儿也可以的。</p><p>有两个方案有待尝试；第一个就是所谓的什么番茄时钟，简单粗暴一刀切；另一种方法就是把任务分解成许许多多的小目标，然后全力以赴完成一个就休息一次。</p><h1 id="培养可转移技能"><a href="#培养可转移技能" class="headerlink" title="培养可转移技能"></a>培养可转移技能</h1><p>「可转移技能」其实就是个营销号骗职场新人的名词，我不管这个词一开始是什么意思，在这里简单粗暴地将所有我认为需要掌握的非专业技能都归类其中。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我，社恐。刚上大一的时候别说和有语言隔阂的美国人聊天了，连中国来的留学生都不敢搭话，后来渐渐地好了一点，然后渐渐地也能够和别人用英语来交流了。幸亏是在个小村子里呆着，从来没因为自己英语垃圾被歧视过，感谢就是那些一看就是典型中产阶级功德圆满闲得没事也耐心的老太太老大爷。</p><p>当然我自认为也算是付出了一丁点儿的努力，比如我大一的时候因为太过讨厌自己就直接在写作部门找了个人美心善的教授每个周专门腾出一个小时的时间就光陪我尬聊，有的时候也会去找那些要去亚洲支教的同学给他们当小白鼠。</p><p>不过我的确意识到了，能够跟别人好好说话是一种虽然不强求、但仍然需要具备的技能。而且认识各种不同的人可能的确也很有意思吧，总之接下来的一年也要加油。</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>我觉得国内的语文教育都太把文学当回事了，我不是说文学不好，而是「阅读」和「写作」应该是一个更宽泛的概念，不仅能够用于学习文学或者写文学作品上。</p><p>所以明年的目标是，多写。一方面，写那种能够把一件事情给讲清楚的文章，比如学习笔记、阅读笔记；另一方面写一些总结，比如我现在正在写的不知道是什么东西的东西。</p><p>如果学校有相关的非学术写作的课程的话，我应该会乐意去上；如果没有的话，就想办法搞一个自主学习的课程吧，争取每个周些一篇出来（目标是不是有点太大了）？</p><h2 id="知识的应用能力"><a href="#知识的应用能力" class="headerlink" title="知识的应用能力"></a>知识的应用能力</h2><p>至少现在对我来说，有网络，有图书馆，基本上想要搜索到感兴趣的领域中优质的学习资源基本上是分分钟的事情，基本上不用一个下午就能大概明白想入门都需要学哪些内容、需要做什么。并没有学习资源不足的问题，甚至可能是过于丰富反而把时间浪费在纠结上了。</p><p>那么，接下来的主要问题就是想办法将这些资源有效利用了。感觉这个问题要是展开足够写一本书，目前为止除了熟能生巧之外，运用类比和推理，将某个学科的知识抽象化并用于其他方面也是一个有趣的方向。</p><h2 id="有效学习"><a href="#有效学习" class="headerlink" title="有效学习"></a>有效学习</h2><p>我觉得自己和周围的大佬们比就是垃圾，无法弥补的那种。</p><p>于是我的面前有两种选择，第一种是和大佬在相同的时间内学习同样的内容，但只是流于表面；第二种是少学一点，把能学的都学懂。</p><p>现在想来，国内大学的问题，比如死板的课程规划，绕不过去的马哲毛概，在这里都不是问题，那为什么还要按照国内的逻辑来学习，只是不择手段地刷绩点呢？</p><p>有人可能会反驳了：这些知识你虽然忘记了，但其实都存在你脑子里面，能派上用场的时候自然会点醒你的。</p><p>别别别，我现在就想用，但它并没有跳出来点醒我。</p><p>所以，接下来要保证的是，不论是学习一门课程，还是看一本书，都要慢下来，按照流程走一遍——</p><ol><li>在授课，或者阅读之前，预先思考相关内容，带着问题去学习</li><li>走心地记笔记，我指的是用自己的话来复述的那种</li><li>定时在脑内回顾所学的知识</li><li>多练习，并且得到反馈</li></ol><p>我知道会很慢，至少达不到之前一学期上四门课并且读至少十本书的速度。但因为这一年是一个千载难逢的能够慢下来、培养学习习惯的好机会，我不想浪费它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大二学年的末尾，我觉得自己又多上了两年高中。&lt;/p&gt;
&lt;p&gt;大一我没有像以前那样装模作样地写一篇学年总结，唯一写过的东西大概是一条朋友圈，大意是「今年就像做梦一样幸福希望明年也能够继续这样的生活」，而大二也如愿以偿地，基本上就是大一生活的延续——一整个学校都没有我讨厌或者讨厌我的人、有每天能见到的有男有女的三五好友、小圈子里她喜欢他喜欢她的捕风捉影的绯闻、虽然也努力学习但没有名为「高考」的压力、出成绩之后同学之间的商业互吹和自贬……&lt;/p&gt;
&lt;p&gt;虽然听上去有些滑稽，但初中时向往的「玫瑰色的高中生活」正是如此。&lt;/p&gt;
    
    </summary>
    
      <category term="荒唐言" scheme="https://blog.sheronw.xyz/categories/%E8%8D%92%E5%94%90%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>齿轮化的我们</title>
    <link href="https://blog.sheronw.xyz/2019/03/30/gear_world/"/>
    <id>https://blog.sheronw.xyz/2019/03/30/gear_world/</id>
    <published>2019-03-30T13:59:14.000Z</published>
    <updated>2019-07-06T13:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>读英语言文学专业的同学写的小说，里面某个人物说了这么一句话：</p><blockquote><p>I don’t think about what the world really is like. I learn a skill and I make a living out of that skill.</p></blockquote><p>这让我想起了在『现代社会』的『中国』遇到的很多人。就是几乎『全盘接受普世价值观』，有点精致利己，但往好里夸能算作努力上进，但就没什么同理心，尤其是对和自己没有关系的人和事物。然后莫名其妙就写了一堆其实和这篇小说本身并没有什么卵关系的感想。</p><p>首先是关于『现代社会』。我感觉我认识的很多人，其实都把自己给『齿轮化』了。假设世界，或者社会是一个很大的机器，那么其中的很多人就将自己当作这个机器上的一个齿轮（或者螺丝钉也行）——这并不是说他们麻木，因为他们当中的很多人也想要成为一个好的齿轮，或者能够到这个机器更重要的部分中去当一个齿轮；这也并不是说他们眼界狭隘，只能看到自己作为齿轮对这个机器的贡献，因为『努力成为一个好的齿轮』就已经占据了他们的全部身心和精力了，即使有点空闲也去做一些轻松愉快的事情了（比如哲♂学），因此很难从『齿轮』这个思维定势中跳脱出去考虑一些别的事情，比如整个机器本身。<br><a id="more"></a></p><p>这种想法是人类对于日益复杂、信息爆炸的社会所做出的一种很正常的应激反应。</p><p>我对希腊城邦什么玩意儿的不太熟悉，但假设在几千年前，在希腊有个城邦。城邦里面就那么几个人，每个人一辈子能够有交流、有交集的人也就那么几个，每个人所做的事情（也就是说职业）也就那么几种，远远没有达到高度细分，而且那个时候labor market也没那么发达，基本上每个人都算是『全才』。在那个时候，其实人们心中的『世界』，或者说是『社会』，其实是一种很简单很好理解的东西，再加上也没有那么多信息（不管是有意义的还是没有意义的）来占据人们的空闲时间。在这个时候人们考虑一些关于『社会的』东西，其实是并不难的，所以城邦据说是一个还算比较民主的社会，人们能够通过投票啊什么乱七八糟的决定一些日常事务。</p><p>但是，工业时代以降，社会已经高度复杂化了，随便举几个例子：工种的高度细分，如metropolitan在内的超级系统。这个时候一个人想要看清整个机器的全貌、了解机器的每个组成部分已经是不可能的了。我觉得computer science中的interface是一个很了不起的概念，大概就是计算机硬件和软件的每一个组成部分都是一个black box，你输入input，然后它会得到output。我觉得这个思想一定不是只在cs里面才有，或者说是可能cs其实就是借鉴了这个思想才得以繁荣，因为现代的计算机本身就是一个十分复杂、超出人类认知极限的一个系统。现代社会在很大程度上也是被这么封装起来的。因为看到全貌太过复杂而以至于不可能，因此对于大多数齿轮来说，它看到的机器除了自己能够理解、能够接触到的部分之外，其实就是很多个黑盒子，它知道对于某些黑盒子，它给与input，就能得到某些特定的output。只要能够掌握这些黑盒子的使用方法，然后理解好自己作为一个齿轮的职责并完成这些职责，它就心满意足（或者是竭尽全部精力）了。</p><p>更糟糕的是，信息时代又带来了更多的问题，比如信息过载以及回声室等等。首先，它能够提供用户想要的内容，而且是怎么刷都刷不完的瀑布流，这就导致了很多齿轮将自己的关注点全部放在了自己最关心的那一部分，观察整个机器本身变得更难。其次，为了从（无法辨别真假的）信息洪流中保护自己不至于崩溃，很多人干脆切断了很多信息获取渠道，或者说是，对很多事情漠不关心。</p><p>然后是关于『中国的』。我没怎么跟美国人聊过天，但他们对于政治的关注点显然比我在中国时遇到的同学要多得多。我一直对『他们为什么对很多事情漠不关心』这个问题感到很疑惑。因为我这学期闲着没事去上了个中国政治课，读了一些reading，这里有一种可能的解释：</p><p>其实在Mao的时代，整个中国都是高度政治化的，然后在CR中达到高峰。Mao的思想在很大程度上都是在发动广大人民群众，那个时候每个人都谈政治，甚至可以说是『不得不谈论政治』，甚至很多知识分子和技术人员，都要将日常生活或者科研的时间抽出来一部分用来应付政治。</p><p>之后的事情更像是一些矫枉过正，或者说对那个年代的事情避而不谈。80年代的改革派为了更好地发展经济，试图将政治这种事情从日常生活中消除，希望人们能把更多的精力放在私人生活（促进消费和商品化）和研究自己的专业技能（促进现代化）上来。</p><p>但现在的问题是，之前我们破坏掉了代表着封建乡绅与农民二维对立的儒家思想，换成了马列主义毛泽东思想，但80年后他们又被小心翼翼地替换成了有利于市场经济的某种意识形态，外加上一些外来的思想，其实这几代人对于『这个社会』是很迷惑的，再加上大环境不鼓励，那么还不如冷漠一点好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读英语言文学专业的同学写的小说，里面某个人物说了这么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I don’t think about what the world really is like. I learn a skill and I make a living out of that skill.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这让我想起了在『现代社会』的『中国』遇到的很多人。就是几乎『全盘接受普世价值观』，有点精致利己，但往好里夸能算作努力上进，但就没什么同理心，尤其是对和自己没有关系的人和事物。然后莫名其妙就写了一堆其实和这篇小说本身并没有什么卵关系的感想。&lt;/p&gt;
&lt;p&gt;首先是关于『现代社会』。我感觉我认识的很多人，其实都把自己给『齿轮化』了。假设世界，或者社会是一个很大的机器，那么其中的很多人就将自己当作这个机器上的一个齿轮（或者螺丝钉也行）——这并不是说他们麻木，因为他们当中的很多人也想要成为一个好的齿轮，或者能够到这个机器更重要的部分中去当一个齿轮；这也并不是说他们眼界狭隘，只能看到自己作为齿轮对这个机器的贡献，因为『努力成为一个好的齿轮』就已经占据了他们的全部身心和精力了，即使有点空闲也去做一些轻松愉快的事情了（比如哲♂学），因此很难从『齿轮』这个思维定势中跳脱出去考虑一些别的事情，比如整个机器本身。&lt;br&gt;
    
    </summary>
    
      <category term="荒唐言" scheme="https://blog.sheronw.xyz/categories/%E8%8D%92%E5%94%90%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>我果然一直都在无效学习</title>
    <link href="https://blog.sheronw.xyz/2019/03/27/make_it_stick/"/>
    <id>https://blog.sheronw.xyz/2019/03/27/make_it_stick/</id>
    <published>2019-03-28T03:39:14.000Z</published>
    <updated>2019-05-21T19:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>高中的时候，由于被整个大环境洗了脑，我拿出了前所未有的干劲，开始随着全日制高中每一个小时都被安排好的作息，做出一副每时每刻都在好好学习的样子，但我很快就意识到，自己对所谓『知识』的掌握程度并不好，以至于到底学到了什么，我自己也说不出来。虽然隐约地觉得自己的学习方式可能出了些问题，但那时的我更认为自己只是还不够努力，只要没有学到死就没有资格去考虑这个问题，至于那些取得好成绩的同学，我统统将他们纳入天赋异禀的范畴。</p><p>直到这个春假忙里偷闲地看了本叫做『<a href="https://books.google.com/books/about/Make_It_Stick.html?id=t9JoAwAAQBAJ&amp;source=kp_book_description" target="_blank" rel="noopener">Make It Stick</a>』的书，自己隐约的猜想才算成了现实——是的，我之前接近二十年的人生中，很多时候的所谓『学习』都是无效的，为什么？因为没有动脑。现在想来，正如高中的我相信自己可以靠一点睡五点半起来取得好成绩一样，其实只是自己感动自己罢了——因为认真地去分析、去记忆很累，因此把时间用来不断地反复理解或记忆表层的内容，然后觉得自己应该掌握了，然后直接跳到下一个知识点。</p><p>这本书里面提到了一个叫做effortful learning的概念，其实这东西没什么可解释的，就是动脑子学的意思，基本上是个学生可能都能明白『真正动脑子学』是什么意思。我先解释一下为什么很多人都做不到effortful learning，然后再直接上方法论，至于effortful learning的益处暂时略去不谈，一些心理学和神经科学的原理我也不解释了。另外，书中针对教育者（父母、老师、培训机构等）也有一些针对性的建议，这里也略去不谈，以下内容主要针对像我这样的（苦逼）学生。<br><a id="more"></a></p><h1 id="为什么会无效学习"><a href="#为什么会无效学习" class="headerlink" title="为什么会无效学习"></a>为什么会无效学习</h1><h2 id="有效学习的缓慢与困难"><a href="#有效学习的缓慢与困难" class="headerlink" title="有效学习的缓慢与困难"></a>有效学习的缓慢与困难</h2><p>印象中第一次接触到所谓的『有效学习』，是在初中快会考的时候，历史老师建议我们晚上睡觉前把眼一闭，想一想自己这一天都学了什么，还有哪些需要学习或者改进的（其实就是之后我会提到的retrieval和reflection）。我想了想好有道理诶，然而坚持了一天就放弃了。</p><p>原因很简单，浪了一整天之后，晚上躺在床上的时候就已经很累了，回忆当天学了啥真的太难了，要很努力才能回忆起来，还不如看会儿<del>里</del>番放飞自我。</p><p>于是我用自己的亲身经历告诉了大家effortful learning有多困难。但是事实上，当你在努力回忆今天学了什么的时候，即使最后也没法全想出来，也是对学习很有利的。或者说，如果你回忆或者复习的时候越吃力，其实学到的东西就更多，真正掌握知识的学习曲线是很陡峭的。</p><p>可惜大多数人（比如我）都只是大概扫一眼，从来不在脑子里自己过一遍知识，把整个思考过程都复原一遍，因为『这么思考下去太慢了，肯定做不完作业』，想着『啊我觉得我应该会了吧』，就开始盲目地练习一些比较简单的题，如果会做更加引证了自己会做的假象，不会做就抄抄课本和笔记，照葫芦画瓢也能做出来，想着『那就考试之前看一下笔记吧』，也就这么搁置了下去。</p><p>除了学习曲线缓慢之外，effortful learning的过程中还有很多困难，比如下课之后回忆起之前课上讲过的内容，就会发现自己很多内容都不记得了，或者说认认真真做题不看课本的时候发现自己很多概念并不理解所以并不会做之类的。</p><p>不过这个也不用太担心，因为不断地试错，即使最后都没做对，同样有利于学习。</p><p>这里灌一下原书提到的一段鸡汤：</p><blockquote><p>People who believe that their intellectual ability is fixed from birth, wired in their genes, tend to avoid challenges at which they may not succeed, because failure would appear to be an indication of lesser native ability.<br>By contrast, people who are helped to understand that effort and learning change the brain, and that their intellectual abilities lie to a large degree within their own control, are more likely to tackle difficult challenges and persist at them. They view failure as a sign of effort and as a turn in the road rather than as a measure of inability and the end of the road.<br>如果一个人相信自己的智力是与生俱来、嵌在基因里的，那么他会倾向于避免他们可能做不到的挑战，因为失败就代表着他们的先天能力不足。<br>与之相反地，如果一个人经过指点，明白努力和学习可以改变自己的大脑，并且自己的智力在很大程度上都是可以受自己控制，那么他就会更可能解决困难的挑战并在这上面坚持下去。他们将失败看作努力的证明或是一个转折点，而不是无能的标志或是死路一条。</p></blockquote><h2 id="知识被掌握的假象"><a href="#知识被掌握的假象" class="headerlink" title="知识被掌握的假象"></a>知识被掌握的假象</h2><p>只要说到复习，我做出的实际行动其实永远只有一项——『看错题和笔记』，真的只是来来回回地看，看到觉得自己好像已经背下来了就停下。其实我也知道最好的方式是重新做一遍，但想了想觉得自己既然已经重新做过一遍了，那么应该就不用再做、只要看看错在那里应该就会了。</p><p>于是我又中枪了——事实证明反反复复阅读笔记和文本是效率最低下的复习方式，因为缺少更深层的思考，很多时候我们只是掌握了『文本』，而不是『知识』本身。</p><p>更糟糕的是，这种『付出努力』的错觉，更加强化了我的错误认知，让我自己认为自己对于知识的掌握已经很熟练了，然后陷入了死循环。</p><p>心理学中的Imagination Inflation说的就是这种情况，如果一个人幻想过发生了某事，那么最后他真的会把它当真。我幻想反复阅读文本就能掌握知识，结果最后自己真的相信我已经把这些都学会了。</p><p>想要打破这种幻象，就要给自己设定一些指标，然后检查自己是否能够达到这些要求。对于一些没有硬性指标的抽象内容，可以时不时进行自测，或者和同学相互交流学习的内容。</p><h1 id="如何做到有效地学习"><a href="#如何做到有效地学习" class="headerlink" title="如何做到有效地学习"></a>如何做到有效地学习</h1><p>以下内容全部出自原书第八章。其实很多技巧我们都早已知道，只是由于思维惰性却迟迟不去实践。虽然开始改变很难，并且没啥成就感，但贵在坚持。</p><h2 id="Practice-Retrieving-New-Learning-from-memory"><a href="#Practice-Retrieving-New-Learning-from-memory" class="headerlink" title="Practice Retrieving New Learning from memory"></a>Practice Retrieving New Learning from memory</h2><p>有的时候，学到的知识其实已经储存到我们的大脑里了，只是我们仍然无法在需要的时候熟练调用。因此我们要为『调用』这个过程进行足够的练习。</p><p>首先，在学习，尤其是容易出现掌握假象的阅读笔记和文本时，要时不时停下来考虑以下几个问题：</p><ul><li>这些文本的要点有哪些？</li><li>其中有哪些我不熟悉的术语？如何定义它们？</li><li>其中有哪些我不熟悉的观点？如何把它们和我已知的内容连系起来？</li></ul><p>其次，<del>虽然大家都知道，</del>不要满足于翻来覆去地看课本和笔记，所有的知识最好都在脑子里自己重构一遍，并且课后习题做起来（除了练习retreving之外，也可以作为自己掌握程度的指标）。</p><p>当然，不要忘了每个周、每个月还有考试前温习学过的内容。</p><h2 id="Space-Out-Your-Retrieval-Practice"><a href="#Space-Out-Your-Retrieval-Practice" class="headerlink" title="Space Out Your Retrieval Practice"></a>Space Out Your Retrieval Practice</h2><p>首先，从真正掌握知识的角度上看，考前临时抱佛脚什么的绝对不可取，记得快忘得更快。因为知识需要时间来巩固，因此将知识分块，中间给予时间间隔的话学习效果更好。</p><p>对名词和脸来说，学完了如果不立刻复习的话很容易忘记。对于文本类的话，当天也要复习一次，一个月后一定要重新复习。</p><p>对于自己已经掌握的内容，也依然要复习。可以使用Leitner Box来管理自己掌握程度不同的知识。</p><p>不要总是学一种科目，在不同的科目间切换效果会更好。</p><h2 id="Interleave-the-Study-of-Different-Problem-types"><a href="#Interleave-the-Study-of-Different-Problem-types" class="headerlink" title="Interleave the Study of Different Problem types"></a>Interleave the Study of Different Problem types</h2><p>比起一口气突击一个知识点并进行盲目的单项训练，同时学习几个知识点，并且比较它们的相同点和不同点更好。</p><h2 id="Other-Effective-Study-Strategies"><a href="#Other-Effective-Study-Strategies" class="headerlink" title="Other Effective Study Strategies"></a>Other Effective Study Strategies</h2><h3 id="Elaboration"><a href="#Elaboration" class="headerlink" title="Elaboration"></a>Elaboration</h3><ul><li>试图用自己的话来总结所学知识</li><li>将所学内容与生活联系起来</li><li>寻找新知识与已知知识的关系</li></ul><h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><p>其实就是在学习之前预先进行思考。比如在阅读文本前，先思考一下作者会针对这个topic讲哪些观点。做题的话，即使知道自己可能做不出来，也要在看答案之前自己做一做。学习理科的时候可以在课前根据已经有的知识试着做一下这一章节的题目。</p><h3 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h3><p>回顾最近的学习内容并思考以下问题：</p><ul><li>哪些是自己做得比较好的？哪些还需要改进和温习？</li><li>这些知识能够联想到哪些别的内容？</li><li>自己还可以做哪些？</li></ul><h3 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h3><p>寻找一些标准来确认自己对于知识的掌握内容程度。之前已经说过。如果有标准的话就和标准比较，如果没有的话就自己测试，比如课后的习题，自我回顾等等。</p><h3 id="Mnemonic-Devices"><a href="#Mnemonic-Devices" class="headerlink" title="Mnemonic Devices"></a>Mnemonic Devices</h3><p>这就比较骚了，只要搜索『记忆方法』就能找出一大堆，这里不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高中的时候，由于被整个大环境洗了脑，我拿出了前所未有的干劲，开始随着全日制高中每一个小时都被安排好的作息，做出一副每时每刻都在好好学习的样子，但我很快就意识到，自己对所谓『知识』的掌握程度并不好，以至于到底学到了什么，我自己也说不出来。虽然隐约地觉得自己的学习方式可能出了些问题，但那时的我更认为自己只是还不够努力，只要没有学到死就没有资格去考虑这个问题，至于那些取得好成绩的同学，我统统将他们纳入天赋异禀的范畴。&lt;/p&gt;
&lt;p&gt;直到这个春假忙里偷闲地看了本叫做『&lt;a href=&quot;https://books.google.com/books/about/Make_It_Stick.html?id=t9JoAwAAQBAJ&amp;amp;source=kp_book_description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Make It Stick&lt;/a&gt;』的书，自己隐约的猜想才算成了现实——是的，我之前接近二十年的人生中，很多时候的所谓『学习』都是无效的，为什么？因为没有动脑。现在想来，正如高中的我相信自己可以靠一点睡五点半起来取得好成绩一样，其实只是自己感动自己罢了——因为认真地去分析、去记忆很累，因此把时间用来不断地反复理解或记忆表层的内容，然后觉得自己应该掌握了，然后直接跳到下一个知识点。&lt;/p&gt;
&lt;p&gt;这本书里面提到了一个叫做effortful learning的概念，其实这东西没什么可解释的，就是动脑子学的意思，基本上是个学生可能都能明白『真正动脑子学』是什么意思。我先解释一下为什么很多人都做不到effortful learning，然后再直接上方法论，至于effortful learning的益处暂时略去不谈，一些心理学和神经科学的原理我也不解释了。另外，书中针对教育者（父母、老师、培训机构等）也有一些针对性的建议，这里也略去不谈，以下内容主要针对像我这样的（苦逼）学生。&lt;br&gt;
    
    </summary>
    
      <category term="阅读笔记" scheme="https://blog.sheronw.xyz/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>EH Forwarder Bot 2.0保持后台运行（Screen）</title>
    <link href="https://blog.sheronw.xyz/2019/02/22/efbscreen/"/>
    <id>https://blog.sheronw.xyz/2019/02/22/efbscreen/</id>
    <published>2019-02-22T22:41:17.000Z</published>
    <updated>2019-08-17T13:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信升级到7之后就经常收不到后台推送（不知道问题是出在美国的网络还是我的pixel），但网页版的推送显然是正常的，于是决定时隔一年再次卸载微信，使用efb。<br><del>要是有空顺便把Facebook Messenger也部署了吧</del><br><a href="https://ehforwarderbot.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">感兴趣的话可以看一下这个documentation</a><br><a id="more"></a><br>用的是Vultr的VPS，5刀一个月的那个（之前用的是digitalocean，github student package里面有优惠），有点肉疼……<br>安装方法和当初装1.0没什么区别，只不过后台运行的方法和之前不太一样，所以从<a href="https://whitecodes.github.io/2018/02/Eh-Forwarder-Bot-2-0/" target="_blank" rel="noopener">这里</a>找到了解决方案，记在下面：</p><ol><li>首先要用screen保持后台运行</li><li>将其后台化需要Ctrl+a、Ctrl+d</li><li>再次打开的话需要执行screen -ls命令，然后再screen -r XXXXX</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信升级到7之后就经常收不到后台推送（不知道问题是出在美国的网络还是我的pixel），但网页版的推送显然是正常的，于是决定时隔一年再次卸载微信，使用efb。&lt;br&gt;&lt;del&gt;要是有空顺便把Facebook Messenger也部署了吧&lt;/del&gt;&lt;br&gt;&lt;a href=&quot;https://ehforwarderbot.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;感兴趣的话可以看一下这个documentation&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.sheronw.xyz/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>浮点数的表示法以及加法乘法</title>
    <link href="https://blog.sheronw.xyz/2019/02/20/float/"/>
    <id>https://blog.sheronw.xyz/2019/02/20/float/</id>
    <published>2019-02-20T18:40:28.000Z</published>
    <updated>2019-08-17T21:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浮点数的表示法"><a href="#浮点数的表示法" class="headerlink" title="浮点数的表示法"></a>浮点数的表示法</h2><p>每一个浮点数都要转换成二进制版本的科学计数法再储存起来（也就是x*2<sup>y</sup>），因此需要存储如下数据：正负号（0正1负），科学计数法的幂（2的次方数），科学计数法的小数部分（用-2进制来表示）。</p><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p>把这个数分成小数和整数两种形式。<br>整数直接转二进制然后使用科学计数法。<br>分数部分，每次乘2，取该数的整数部分（要么取不到整数，要么取走1），直到啥都不剩为止。取到的数从左往右写，最前面加0.。</p><a id="more"></a><h3 id="IEEE-Floating-Point-Standard-754标准"><a href="#IEEE-Floating-Point-Standard-754标准" class="headerlink" title="IEEE Floating Point Standard 754标准"></a>IEEE Floating Point Standard 754标准</h3><p>32bits（float）从左往右依次为：</p><ul><li>31: 正负号</li><li>30-23: 8 bits的幂数</li><li>22-0: 23 bits的小数部分（因为科学记数法，所以第一位（小数点左侧）必然是1，就不计算在内了）</li></ul><p>64bits（double）从左往右依次为：</p><ul><li>63：正负号</li><li>62-52：11 bits的幂数</li><li>51-0：52 bits的小数部分</li></ul><h3 id="exponent-bias-method"><a href="#exponent-bias-method" class="headerlink" title="exponent bias method"></a>exponent bias method</h3><p>为了表示负数次幂，转换时在原本的幂数中加一些数字。<br>32位+127，64位+1023<br>这样32位幂的表示范围为-126~127，64为-1022~1023<br>在这里我们没有用two’s complement，原因是这种方法更容易比较两个数的大小。</p><h2 id="浮点数的加法"><a href="#浮点数的加法" class="headerlink" title="浮点数的加法"></a>浮点数的加法</h2><p>首先要把他们对齐，也就是说把两个数字的幂转换成一样的。然后和十进制一样相加减，最后再把得到的结果转换成科学记数法。</p><h2 id="浮点数的乘法"><a href="#浮点数的乘法" class="headerlink" title="浮点数的乘法"></a>浮点数的乘法</h2><p>和加法同理。<br>不过可以在乘之前先判断一下结果的符号，同号为正异号为负。<br>然后相乘（小数部分相乘，幂数相加），最后转回科学记数法。</p><p>不过在实现运算的过程中要注意，储存幂数的时候用的是bias method，而且小数部分中小数点左边的部分并没有实际存储在浮点数中。（血一样的教训）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浮点数的表示法&quot;&gt;&lt;a href=&quot;#浮点数的表示法&quot; class=&quot;headerlink&quot; title=&quot;浮点数的表示法&quot;&gt;&lt;/a&gt;浮点数的表示法&lt;/h2&gt;&lt;p&gt;每一个浮点数都要转换成二进制版本的科学计数法再储存起来（也就是x*2&lt;sup&gt;y&lt;/sup&gt;），因此需要存储如下数据：正负号（0正1负），科学计数法的幂（2的次方数），科学计数法的小数部分（用-2进制来表示）。&lt;/p&gt;
&lt;h3 id=&quot;十进制转二进制&quot;&gt;&lt;a href=&quot;#十进制转二进制&quot; class=&quot;headerlink&quot; title=&quot;十进制转二进制&quot;&gt;&lt;/a&gt;十进制转二进制&lt;/h3&gt;&lt;p&gt;把这个数分成小数和整数两种形式。&lt;br&gt;整数直接转二进制然后使用科学计数法。&lt;br&gt;分数部分，每次乘2，取该数的整数部分（要么取不到整数，要么取走1），直到啥都不剩为止。取到的数从左往右写，最前面加0.。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机科学" scheme="https://blog.sheronw.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>bit level operators</title>
    <link href="https://blog.sheronw.xyz/2019/02/13/bit_level_operators/"/>
    <id>https://blog.sheronw.xyz/2019/02/13/bit_level_operators/</id>
    <published>2019-02-14T00:40:21.000Z</published>
    <updated>2019-08-17T21:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程语言中的操作符"><a href="#编程语言中的操作符" class="headerlink" title="编程语言中的操作符"></a>编程语言中的操作符</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>&lt;&lt; left shift</li><li>>> signed right shift (filled with sign bits)</li><li>>>> unsigned right shift (filled with 0s)</li><li>&amp; bitwise and</li><li>| bitwise or</li><li>^ bitwise exclusive or</li></ul><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>大致与Java相同，只是没有unsigned right shift，具体会怎么shift取决于数据型本身。</p><a id="more"></a><h2 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h2><h3 id="set-bits-to-0"><a href="#set-bits-to-0" class="headerlink" title="set bits to 0"></a>set bits to 0</h3><p>x&amp;0=0</p><p>x&amp;1=x</p><h3 id="set-bits-to-1"><a href="#set-bits-to-1" class="headerlink" title="set bits to 1"></a>set bits to 1</h3><p>x|0=x</p><p>x|1=1</p><h3 id="invert-bits"><a href="#invert-bits" class="headerlink" title="invert bits"></a>invert bits</h3><p>x^0=x</p><p>x^1=!x</p><h2 id="应用……？"><a href="#应用……？" class="headerlink" title="应用……？"></a>应用……？</h2><p>刚刚看到了<a href="https://blog.coca.moe/post/er-jin-zhi-mei-ju" target="_blank" rel="noopener">这么一道题</a>，发现和当初学离散数学的时候遇到的那个小朋友分饼干的题型有点像，都是二进制的应用，就当是位运算的一个实例放在这里了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编程语言中的操作符&quot;&gt;&lt;a href=&quot;#编程语言中的操作符&quot; class=&quot;headerlink&quot; title=&quot;编程语言中的操作符&quot;&gt;&lt;/a&gt;编程语言中的操作符&lt;/h2&gt;&lt;h3 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;&amp;lt; left shift&lt;/li&gt;
&lt;li&gt;&gt;&gt; signed right shift (filled with sign bits)&lt;/li&gt;
&lt;li&gt;&gt;&gt;&gt; unsigned right shift (filled with 0s)&lt;/li&gt;
&lt;li&gt;&amp;amp; bitwise and&lt;/li&gt;
&lt;li&gt;| bitwise or&lt;/li&gt;
&lt;li&gt;^ bitwise exclusive or&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h3&gt;&lt;p&gt;大致与Java相同，只是没有unsigned right shift，具体会怎么shift取决于数据型本身。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机科学" scheme="https://blog.sheronw.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>十进制、二进制与十六进制的相互转换，以及Two’s Complement Notation</title>
    <link href="https://blog.sheronw.xyz/2019/02/13/10,2,16&amp;Two&#39;s%20Complement%20Notation/"/>
    <id>https://blog.sheronw.xyz/2019/02/13/10,2,16&amp;Two&#39;s Complement Notation/</id>
    <published>2019-02-13T23:47:37.000Z</published>
    <updated>2019-08-17T21:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h2><p>很简单，从右往左加，第一位乘以2的零次方，第二位乘以2的一次方，然后以此类推……<br>10101<sub>10</sub>=1*2^4+0*2^3+1*2^2+0*2^1+1*2^0=21<br>还有一种方法是Horner’s Rule，从左往右算，每次把下一位加在这个结果中作为一个整体。<br>10101<sub>10</sub>=(((1*2+0)*2+1)*2+0)*2+1=21</p><a id="more"></a><h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p>不断地除以二，直到除不动了为止，每一步得到的余数倒过来就是所求的二进制。</p><ul><li><strong>10</strong>/2=5 …0</li><li>5/2=2 … 1</li><li>2/2=1 … 0</li><li>1/2=0 … 1</li></ul><p>所以10的二进制为1010<br>当然，如果不想最后再颠倒一遍的话，可以算的时候从下往上写XD</p><h2 id="十六进制转二进制"><a href="#十六进制转二进制" class="headerlink" title="十六进制转二进制"></a>十六进制转二进制</h2><p>十六进制的每一位都能转换成一个四位的二进制，然后把它们拼起来就好，其实还有一个转换表，但算起来也不麻烦，我觉得不背也行。</p><h2 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h2><p>和上面一个道理，每四位二进制都能转换成一位十六进制，如果最后一组不足四位填上几个零就好。</p><h2 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h2><p>和二进制转十进制一个道理，只不过把2换成16了而已。</p><h2 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h2><p>同上，和二进制一样，只不过不断除以16。</p><h2 id="Two’s-Complement"><a href="#Two’s-Complement" class="headerlink" title="Two’s Complement"></a>Two’s Complement</h2><p>这是一种用二进制表达整数（包括正负）的一种方法。<br>首先，从最左边的那一位可以看出这个数字的正负——0为正，1为负。<br>如果是正数的话，和之前讲到的传统二进制表达是相同的。<br>如果是负数的话，想要知道它的具体值，我们需要将Two’s Complement转换成它的相反数（也就是说这个数字的整数版本）。<br>转换成相反数的算法如下（同时适用与正数和负数）：</p><ul><li>将每一位的数字颠倒（颠倒指的是，1换成0，0换成1）</li><li>在颠倒之后的基础上再+1</li></ul><p>比如这里有个我瞎编的32bits的数字：<br>1010 0100 0100 1111 1010 1100 0101 0000<br>第一位是1，所以这个数是小于零的<br>首先我们要把它变成这样的：<br>0101 1011 1011 0000 0101 0011 1010 1111<br>然后再+1就变成了这样：<br>0101 1011 1011 0000 0101 0011 1011 0000<br>这个数就是最前面瞎编的那个数的相反数</p><p>哦对了，因为32bits的二进制写起来太长了，所以经常会用十六进制来表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二进制转十进制&quot;&gt;&lt;a href=&quot;#二进制转十进制&quot; class=&quot;headerlink&quot; title=&quot;二进制转十进制&quot;&gt;&lt;/a&gt;二进制转十进制&lt;/h2&gt;&lt;p&gt;很简单，从右往左加，第一位乘以2的零次方，第二位乘以2的一次方，然后以此类推……&lt;br&gt;10101&lt;sub&gt;10&lt;/sub&gt;=1*2^4+0*2^3+1*2^2+0*2^1+1*2^0=21&lt;br&gt;还有一种方法是Horner’s Rule，从左往右算，每次把下一位加在这个结果中作为一个整体。&lt;br&gt;10101&lt;sub&gt;10&lt;/sub&gt;=(((1*2+0)*2+1)*2+0)*2+1=21&lt;/p&gt;
    
    </summary>
    
      <category term="计算机科学" scheme="https://blog.sheronw.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
</feed>
