<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>折腾记录 on シャロン</title><link>https://sheronw.xyz/tags/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</link><description>Recent content in 折腾记录 on シャロン</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 04 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sheronw.xyz/tags/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Assign a Subdomain to Elastic Beanstalk and Enable HTTPS</title><link>https://sheronw.xyz/posts/2021-01-04-subdomain-https-for-eb/</link><pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate><guid>https://sheronw.xyz/posts/2021-01-04-subdomain-https-for-eb/</guid><description>&lt;blockquote>
&lt;p>To enable HTTPS (easily), make sure you created one Elastic Beanstalk environment with Load Balancer option.&lt;/p>
&lt;/blockquote>
&lt;h2 id="create-hosted-zone">Create Hosted Zone&lt;/h2>
&lt;ul>
&lt;li>find Route 53 in AWS console&lt;/li>
&lt;li>choose &lt;code>hosted zones&lt;/code> on the left&lt;/li>
&lt;li>click &lt;code>create hosted zone&lt;/code>&lt;/li>
&lt;li>write your &lt;code>subdomain.example.com&lt;/code> as domain name, choose &lt;code>public hosted zone&lt;/code> and then click &lt;code>create hosted zone&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="edit-ttl-optional-for-testing">Edit TTL (optional for testing)&lt;/h2>
&lt;ul>
&lt;li>find the NS record in this hosted zone, select and click &lt;code>edit&lt;/code>&lt;/li>
&lt;li>change TTL to some value like 900 (15 min), by default the value is 172800 (2 days)&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="add-alias-resource-record">Add Alias Resource Record&lt;/h2>
&lt;ul>
&lt;li>click &lt;code>create record&lt;/code> in this hosted zone&lt;/li>
&lt;li>just leave blank for &lt;code>record name&lt;/code>&lt;/li>
&lt;li>enable &lt;code>alias&lt;/code> and assign &lt;code>route traffic to&lt;/code> as your elastic beanstalk application&lt;/li>
&lt;li>click &lt;code>create&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="add-ns-records-for-the-subdomain">Add NS Records for the Subdomain&lt;/h2>
&lt;ul>
&lt;li>go to your domain provider and find the place to add records, for example, in Google Domains, go to &lt;code>DNS&lt;/code> and find &lt;code>custom resource records&lt;/code> section&lt;/li>
&lt;li>copy and paste the NS record in the hosted zone that you created just now, for example, in Google Domains, name should be &lt;code>subdomain&lt;/code> (some providers use &lt;code>subdomain.example.com&lt;/code>), type should be &lt;code>NS&lt;/code> and data should be the values from NS record in the hosted zone, there might be several lines of value and you could use the smaller &lt;code>+&lt;/code> sign to add them in one record&lt;/li>
&lt;li>could also set TTL to 900&lt;/li>
&lt;/ul>
&lt;h2 id="change-ttl-back-optional">Change TTL back (optional)&lt;/h2>
&lt;ul>
&lt;li>if you lowered TTL for testing, don&amp;rsquo;t forget to change them back to default value&lt;/li>
&lt;/ul>
&lt;h2 id="request-a-certificate">Request a Certificate&lt;/h2>
&lt;ul>
&lt;li>go to Certificate Manager in aws&lt;/li>
&lt;li>click &lt;code>request a certificate&lt;/code>, choose &lt;code>request a public certificate&lt;/code>&lt;/li>
&lt;li>type your &lt;code>subdomain.example.com&lt;/code> and then choose DNS validation&lt;/li>
&lt;li>choose to import the CNAME record into Route 53 automatically&lt;/li>
&lt;/ul>
&lt;h2 id="load-balancer-configuration">Load Balancer Configuration&lt;/h2>
&lt;ul>
&lt;li>make sure you created an environment with load balancer&lt;/li>
&lt;li>go to your elastic beanstalk environment&lt;/li>
&lt;li>click &lt;code>configuration&lt;/code> on the left side bar&lt;/li>
&lt;li>find &lt;code>load balancer&lt;/code> and edit&lt;/li>
&lt;li>click &lt;code>add listener&lt;/code>&lt;/li>
&lt;li>port is &lt;code>443&lt;/code>, protocol is &lt;code>HTTPS&lt;/code> and choose the previous created certificate as your ssl certificate&lt;/li>
&lt;li>click &lt;code>add&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>IMGUI 中文支持方案</title><link>https://sheronw.xyz/posts/2020-07-01-imgui-chinese/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://sheronw.xyz/posts/2020-07-01-imgui-chinese/</guid><description>&lt;p>没学过 c++，单纯想头铁汉化个东西，就查资料折腾了一下，这里做一个小的总结。如果有更好的方案请指正。&lt;/p>
&lt;h2 id="加载字体">加载字体&lt;/h2>
&lt;p>首先需要加载支持中文的字体。
网上最多的解决方案是读取外部的&lt;code>.ttf/.otf&lt;/code>字体，亲测可用。但需要用户的目录读取权限，而且可能出现字体不存在的情况。&lt;/p>
&lt;p>对于源码内嵌字体，IMGUI 的作者其实也给出了一个解决方案：&lt;a href="https://github.com/ocornut/imgui/blob/0738611559b0a51c7fa0c376eb9601587231f841/misc/fonts/binary_to_compressed_c.cpp">将 binary 转换为 C array 的工具&lt;/a>。如果软件只是使用拉丁字集的话，文件不大应该也没什么问题，我打算汉化的软件本身用的也是这个解决方案，但将中文字集转换为 C Array 的话大小至少是西文字集的几千倍吧。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>ImGuiIO&lt;span style="color:#f92672">&amp;amp;&lt;/span> io &lt;span style="color:#f92672">=&lt;/span> ImGui&lt;span style="color:#f92672">::&lt;/span>GetIO();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IMFont&lt;span style="color:#f92672">*&lt;/span> ttf_font &lt;span style="color:#f92672">=&lt;/span> io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AddFontFromFileTTF(&lt;span style="color:#e6db74">&amp;#34;res/simhei.ttf&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16.0f&lt;/span>, Null, io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetGlyphRangesChinese());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IMFont&lt;span style="color:#f92672">*&lt;/span> compressed_font &lt;span style="color:#f92672">=&lt;/span> io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AddFontFromMemoryCompressedTTF(SimHei_compressed_data,SimHei_compressed_size, &lt;span style="color:#ae81ff">16.f&lt;/span>, Null, io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetGlyphRangesChinese());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里解释一下，&lt;code>GetGlyphRangesChinese()&lt;/code> 用来指定加载字符集，我需要改动的软件基于 IMGUI 1.4，所以只有这个方法，在更新的版本中，这个被加载常用汉字的&lt;code>GetGlyphRangesChineseSimplifiedCommon()&lt;/code>和加载所有汉字的&lt;code>GetGlyphRangesChineseFull()&lt;/code>所取代。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="汉字编码">汉字编码&lt;/h2>
&lt;p>如果是 c++11，直接给中文字符串添加&lt;code>u8&lt;/code>前缀就可以了，源代码本身应该也是&lt;code>UTF-8&lt;/code>。之前的版本可以上网找个转换函数复制下来用。&lt;/p>
&lt;h2 id="调整-oversampling-配置">调整 OverSampling 配置&lt;/h2>
&lt;p>参考 &lt;a href="https://github.com/ocornut/imgui/issues/1434#issuecomment-344205472">Github 上的这个 Issue&lt;/a>。之前提到过中文字集特别占内存，而 IMGUI 的字体基于 FontAlas，至少在我这个版本（1.4）中不能动态加载，所以可能编译跑起来之后发现满屏黑白方块。&lt;/p>
&lt;p>在作者提供的解决办法中，其中看起来最简单粗暴的方法是减少 OverSampling。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>ImFontConfig config_words;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config_words.OversampleV &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config_words.OversampleH &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 默认为3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>font_14 &lt;span style="color:#f92672">=&lt;/span> io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AddFontFromMemoryCompressedTTF(SimHei_compressed_data,SimHei_compressed_size, &lt;span style="color:#ae81ff">16.f&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>config_words, io.Fonts&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetGlyphRangesChinese());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外还可以请求 Alpha Texture （超出我能力范围了 QvQ）或者手动缩小&lt;code>glyphRange&lt;/code>，只保留自己用到的字符。&lt;/p></description></item><item><title>利用 IFTTT 将 Toggl Report 发送到 Telegram Channel</title><link>https://sheronw.xyz/posts/2020-04-13-ifttt_toggl_telegram/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><guid>https://sheronw.xyz/posts/2020-04-13-ifttt_toggl_telegram/</guid><description>&lt;p>【2020.11.5 更新】趣闻一则：因为 star 了 Toggl API，被一个英国的独立开发者发了 cold email，于是就花了十分钟在 zoom 上和他聊了聊，老哥似乎是想做一个使用类似 Toggl 这样的工具收集数据，然后用机器学习分析码农生产力的产品。&lt;/p>
&lt;p>【2020.9.25 更新】现在 IFTTT 开始付费，感觉不值，散了吧散了吧（虽然 Toggl Report 的获取依然可以参考）。&lt;/p>
&lt;h2 id="主要思路">主要思路&lt;/h2>
&lt;p>&lt;!-- raw HTML omitted -->生写一个 Telegram Bot 也不是不行但我就是想找借口玩 IFTTT&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>VPS 或树莓派：写一个自动化的程序并定时运行，从 Toggl Report API 获取数据，整理之后 Post 给 IFTTT 的 Webhook。&lt;/p>
&lt;p>IFTTT：&lt;code>if&lt;/code> 收到服务器端的 Post &lt;code>then&lt;/code> 发消息到 Telegram 指定 chat&lt;/p>
&lt;p>Telegram：利用&lt;a href="https://t.me/IFTTT">@IFTTT&lt;/a>实现 IFTTT 与 Telegram 的联动&lt;/p>
&lt;p>本记录使用的是目前的 Toggl API v8 以及 Toggl Report API v2。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="获取-toggl-api-token-及-workspace-id">获取 Toggl API Token 及 Workspace ID&lt;/h2>
&lt;p>登录 Toggl 网页版，进入&lt;code>Profile Settings&lt;/code>页面翻到下面有自己的&lt;code>api_token&lt;/code>，把这玩意儿记下来待会儿用。切换到自己想要获取 Report 的 Workspace，点 Settings，把地址栏中&lt;code>https://toggl.com/app/{workspace_id}/settings/general&lt;/code>的&lt;code>workspace_id&lt;/code>记下来。&lt;/p></description></item></channel></rss>